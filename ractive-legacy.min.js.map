{"version":3,"file":"ractive-legacy.min.js","sources":["../../../src/utils/dom.js","../../../src/utils/object.js","../../../src/utils/is.js","../../../src/utils/log.js","../../../src/shared/registry.js","../../../src/shared/interpolate.js","../../../src/Ractive/prototype/shared/add.js","../../../src/Ractive/prototype/add.js","../../../src/Ractive/prototype/shared/hooks/Hook.js","../../../src/utils/array.js","../../../src/utils/Promise.js","../../../src/utils/getPotentialWildcardMatches.js","../../../src/shared/keypaths.js","../../../src/shared/resolveRef.js","../../../src/shared/methodCallers.js","../../../src/global/TransitionManager.js","../../../src/global/runloop.js","../../../src/Ractive/prototype/animate.js","../../../src/Ractive/prototype/detach.js","../../../src/Ractive/prototype/find.js","../../../src/Ractive/prototype/shared/makeQuery/sortByItemPosition.js","../../../src/Ractive/prototype/shared/makeQuery/_makeQuery.js","../../../src/Ractive/prototype/findAll.js","../../../src/Ractive/prototype/findAllComponents.js","../../../src/Ractive/prototype/findComponent.js","../../../src/Ractive/prototype/findContainer.js","../../../src/Ractive/prototype/findParent.js","../../../src/Ractive/prototype/shared/fireEvent.js","../../../src/Ractive/prototype/fire.js","../../../src/Ractive/prototype/get.js","../../../src/Ractive/prototype/insert.js","../../../src/Ractive/prototype/merge.js","../../../src/Ractive/prototype/observe/getPattern.js","../../../src/Ractive/prototype/observe/getObserverFacade.js","../../../src/Ractive/prototype/observe.js","../../../src/Ractive/prototype/observeOnce.js","../../../src/Ractive/prototype/off.js","../../../src/Ractive/prototype/on.js","../../../src/Ractive/prototype/once.js","../../../src/shared/getNewIndices.js","../../../src/Ractive/prototype/render.js","../../../src/Ractive/static/adaptors/magic.js","../../../src/Ractive/config/custom/adapt.js","../../../src/Ractive/config/custom/css/transform.js","../../../src/Ractive/config/custom/css/css.js","../../../src/utils/wrapMethod.js","../../../src/Ractive/config/custom/data.js","../../../src/parse/converters/mustache/readDelimiterChange.js","../../../src/parse/converters/readMustache.js","../../../src/parse/converters/expressions/primary/literal/readNumberLiteral.js","../../../src/parse/converters/expressions/primary/literal/readBooleanLiteral.js","../../../src/parse/converters/expressions/shared/readKey.js","../../../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePair.js","../../../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePairs.js","../../../src/parse/converters/expressions/shared/readExpressionList.js","../../../src/parse/converters/expressions/primary/readLiteral.js","../../../src/parse/converters/expressions/primary/readReference.js","../../../src/parse/converters/expressions/primary/readBracketedExpression.js","../../../src/parse/converters/expressions/shared/readRefinement.js","../../../src/parse/converters/expressions/readConditional.js","../../../src/parse/converters/readExpression.js","../../../src/parse/utils/flattenExpression.js","../../../src/parse/utils/refineExpression.js","../../../src/parse/converters/mustache/readTriple.js","../../../src/parse/converters/mustache/readUnescaped.js","../../../src/parse/converters/mustache/readPartial.js","../../../src/parse/converters/mustache/readMustacheComment.js","../../../src/parse/converters/readExpressionOrReference.js","../../../src/parse/converters/mustache/readInterpolator.js","../../../src/parse/converters/mustache/readYielder.js","../../../src/parse/converters/mustache/section/readClosing.js","../../../src/parse/converters/mustache/readPartialDefinitionSection.js","../../../src/parse/converters/mustache/section/readElse.js","../../../src/parse/converters/mustache/section/readElseIf.js","../../../src/parse/converters/mustache/readSection.js","../../../src/parse/converters/readHtmlComment.js","../../../src/utils/html.js","../../../src/parse/converters/element/readClosingTag.js","../../../src/parse/converters/element/readAttribute.js","../../../src/utils/parseJSON.js","../../../src/parse/converters/element/processDirective.js","../../../src/parse/converters/readElement.js","../../../src/utils/escapeRegExp.js","../../../src/parse/converters/readPartialDefinitionComment.js","../../../src/parse/converters/readText.js","../../../src/parse/utils/stripStandalones.js","../../../src/parse/converters/partial/processPartials.js","../../../src/parse/_parse.js","../../../src/Ractive/config/custom/template/parser.js","../../../src/Ractive/config/custom/template/template.js","../../../src/Ractive/config/wrapPrototypeMethod.js","../../../src/Ractive/config/deprecate.js","../../../src/Ractive/config/config.js","../../../src/virtualdom/Fragment/prototype/bubble.js","../../../src/virtualdom/Fragment/prototype/detach.js","../../../src/virtualdom/Fragment/prototype/find.js","../../../src/virtualdom/Fragment/prototype/findAll.js","../../../src/virtualdom/Fragment/prototype/findAllComponents.js","../../../src/virtualdom/Fragment/prototype/findComponent.js","../../../src/virtualdom/Fragment/prototype/findNextNode.js","../../../src/virtualdom/Fragment/prototype/firstNode.js","../../../src/virtualdom/Fragment/prototype/shared/processItems.js","../../../src/virtualdom/Fragment/prototype/getArgsList.js","../../../src/virtualdom/Fragment/prototype/getNode.js","../../../src/virtualdom/Fragment/prototype/getValue.js","../../../src/virtualdom/items/shared/unbind.js","../../../src/virtualdom/items/shared/Mustache/getValue.js","../../../src/virtualdom/items/shared/Resolvers/SpecialResolver.js","../../../src/virtualdom/items/shared/Resolvers/findIndexRefs.js","../../../src/virtualdom/items/shared/Resolvers/createReferenceResolver.js","../../../src/shared/getFunctionFromString.js","../../../src/virtualdom/items/shared/Resolvers/ExpressionResolver.js","../../../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js","../../../src/virtualdom/items/shared/Mustache/initialise.js","../../../src/virtualdom/items/shared/Mustache/resolve.js","../../../src/virtualdom/items/shared/Mustache/rebind.js","../../../src/virtualdom/items/Section/prototype/bubble.js","../../../src/virtualdom/items/Section/prototype/detach.js","../../../src/virtualdom/items/Section/prototype/find.js","../../../src/virtualdom/items/Section/prototype/findAll.js","../../../src/virtualdom/items/Section/prototype/findAllComponents.js","../../../src/virtualdom/items/Section/prototype/findComponent.js","../../../src/virtualdom/items/Section/prototype/findNextNode.js","../../../src/virtualdom/items/Section/prototype/firstNode.js","../../../src/virtualdom/items/Section/prototype/shuffle.js","../../../src/virtualdom/items/Section/prototype/render.js","../../../src/virtualdom/items/Section/prototype/setValue.js","../../../src/virtualdom/items/Section/prototype/toString.js","../../../src/virtualdom/items/Section/prototype/unbind.js","../../../src/virtualdom/items/Section/prototype/unrender.js","../../../src/virtualdom/items/Section/prototype/update.js","../../../src/virtualdom/items/Triple/prototype/detach.js","../../../src/virtualdom/items/Triple/prototype/find.js","../../../src/virtualdom/items/Triple/prototype/findAll.js","../../../src/virtualdom/items/Triple/prototype/firstNode.js","../../../src/virtualdom/items/Triple/helpers/insertHtml.js","../../../src/virtualdom/items/Triple/helpers/updateSelect.js","../../../src/virtualdom/items/Triple/prototype/render.js","../../../src/virtualdom/items/Triple/prototype/setValue.js","../../../src/virtualdom/items/Triple/prototype/toString.js","../../../src/virtualdom/items/Triple/prototype/unrender.js","../../../src/virtualdom/items/Triple/prototype/update.js","../../../src/virtualdom/items/Element/prototype/detach.js","../../../src/virtualdom/items/Element/prototype/findNextNode.js","../../../src/virtualdom/items/Element/prototype/firstNode.js","../../../src/virtualdom/items/Element/prototype/getAttribute.js","../../../src/virtualdom/items/Element/Attribute/prototype/bubble.js","../../../src/virtualdom/items/Element/Attribute/helpers/getInterpolator.js","../../../src/virtualdom/items/Element/Attribute/prototype/init.js","../../../src/virtualdom/items/Element/Attribute/prototype/rebind.js","../../../src/virtualdom/items/Element/Attribute/prototype/render.js","../../../src/virtualdom/items/Element/Attribute/prototype/toString.js","../../../src/virtualdom/items/Element/Attribute/prototype/unbind.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateClassName.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateValue.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js","../../../src/virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js","../../../src/virtualdom/items/Element/Attribute/prototype/update.js","../../../src/virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js","../../../src/virtualdom/items/Element/Binding/Binding.js","../../../src/virtualdom/items/Element/Binding/shared/handleDomEvent.js","../../../src/virtualdom/items/Element/Binding/shared/getSiblings.js","../../../src/virtualdom/items/Element/Binding/CheckboxNameBinding.js","../../../src/virtualdom/items/Element/Binding/GenericBinding.js","../../../src/virtualdom/items/Element/prototype/init/createTwowayBinding.js","../../../src/virtualdom/items/Element/EventHandler/prototype/bubble.js","../../../src/virtualdom/items/Element/EventHandler/prototype/fire.js","../../../src/virtualdom/items/Element/EventHandler/prototype/getAction.js","../../../src/virtualdom/items/Element/EventHandler/prototype/init.js","../../../src/virtualdom/items/Element/EventHandler/shared/genericHandler.js","../../../src/virtualdom/items/Element/EventHandler/prototype/listen.js","../../../src/virtualdom/items/Element/EventHandler/prototype/rebind.js","../../../src/virtualdom/items/Element/EventHandler/prototype/render.js","../../../src/virtualdom/items/Element/EventHandler/prototype/resolve.js","../../../src/virtualdom/items/Element/EventHandler/prototype/unbind.js","../../../src/virtualdom/items/Element/EventHandler/prototype/unrender.js","../../../src/virtualdom/items/Element/special/select.js","../../../src/virtualdom/items/Element/special/option.js","../../../src/virtualdom/items/Element/prototype/init.js","../../../src/virtualdom/items/Element/prototype/rebind.js","../../../src/virtualdom/items/Element/special/img.js","../../../src/virtualdom/items/Element/special/form.js","../../../src/virtualdom/items/Element/Transition/prototype/init.js","../../../src/shared/Ticker.js","../../../src/virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js","../../../src/virtualdom/items/Element/Transition/prototype/start.js","../../../src/virtualdom/items/Element/prototype/render.js","../../../src/virtualdom/items/Element/prototype/toString.js","../../../src/virtualdom/items/Element/prototype/unbind.js","../../../src/virtualdom/items/Element/prototype/unrender.js","../../../src/virtualdom/items/Partial/deIndent.js","../../../src/virtualdom/items/Partial/getPartialTemplate.js","../../../src/virtualdom/items/Component/getComponent.js","../../../src/virtualdom/items/Component/prototype/detach.js","../../../src/virtualdom/items/Component/prototype/find.js","../../../src/virtualdom/items/Component/prototype/findAll.js","../../../src/virtualdom/items/Component/prototype/findAllComponents.js","../../../src/virtualdom/items/Component/prototype/findComponent.js","../../../src/virtualdom/items/Component/prototype/findNextNode.js","../../../src/virtualdom/items/Component/prototype/firstNode.js","../../../src/viewmodel/prototype/adapt.js","../../../src/viewmodel/helpers/getUpstreamChanges.js","../../../src/viewmodel/prototype/applyChanges/notifyPatternObservers.js","../../../src/viewmodel/prototype/applyChanges.js","../../../src/viewmodel/prototype/capture.js","../../../src/viewmodel/prototype/clearCache.js","../../../src/viewmodel/Computation/getComputationSignature.js","../../../src/viewmodel/Computation/Computation.js","../../../src/viewmodel/prototype/compute.js","../../../src/viewmodel/prototype/get.js","../../../src/viewmodel/prototype/init.js","../../../src/shared/parameters/DataTracker.js","../../../src/shared/parameters/Mapping.js","../../../src/viewmodel/prototype/map.js","../../../src/viewmodel/prototype/mark.js","../../../src/viewmodel/prototype/merge.js","../../../src/viewmodel/prototype/register.js","../../../src/viewmodel/prototype/release.js","../../../src/viewmodel/prototype/set.js","../../../src/viewmodel/prototype/smartUpdate.js","../../../src/viewmodel/prototype/teardown.js","../../../src/viewmodel/prototype/unregister.js","../../../src/Ractive/prototype/shared/hooks/HookQueue.js","../../../src/Ractive/initialise.js","../../../src/shared/parameters/ComplexParameter.js","../../../src/shared/parameters/createComponentData.js","../../../src/shared/parameters/ParameterResolver.js","../../../src/shared/parameters/createParameters.js","../../../src/virtualdom/items/Component/initialise/propagateEvents.js","../../../src/virtualdom/items/Component/prototype/init.js","../../../src/virtualdom/items/Component/prototype/rebind.js","../../../src/virtualdom/items/Component/prototype/render.js","../../../src/virtualdom/items/Component/prototype/toString.js","../../../src/virtualdom/items/Component/prototype/unbind.js","../../../src/virtualdom/items/Component/prototype/unrender.js","../../../src/virtualdom/Fragment/prototype/init.js","../../../src/virtualdom/Fragment/prototype/rebind.js","../../../src/virtualdom/Fragment/prototype/render.js","../../../src/virtualdom/Fragment/prototype/toString.js","../../../src/virtualdom/Fragment/prototype/unbind.js","../../../src/virtualdom/Fragment/prototype/unrender.js","../../../src/Ractive/prototype/reset.js","../../../src/Ractive/prototype/resetTemplate.js","../../../src/Ractive/prototype/set.js","../../../src/Ractive/prototype/subtract.js","../../../src/Ractive/prototype/teardown.js","../../../src/Ractive/prototype/toggle.js","../../../src/Ractive/prototype/toHTML.js","../../../src/Ractive/prototype/unrender.js","../../../src/Ractive/prototype/update.js","../../../src/Ractive/prototype/updateModel.js","../../../src/extend/unwrapExtended.js","../../../src/extend/_extend.js","../../../src/Ractive/config/defaults.js","../../../src/Ractive/static/easing.js","../../../src/config/environment.js","../../../src/legacy.js","../../../src/config/errors.js","../../../src/Ractive/static/interpolators.js","../../../src/utils/requestAnimationFrame.js","../../../src/utils/getTime.js","../../../src/shared/getInnerContext.js","../../../src/shared/animations.js","../../../src/Ractive/prototype/animate/Animation.js","../../../src/Ractive/prototype/shared/makeQuery/test.js","../../../src/Ractive/prototype/shared/makeQuery/cancel.js","../../../src/Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js","../../../src/Ractive/prototype/shared/makeQuery/sort.js","../../../src/Ractive/prototype/shared/makeQuery/dirty.js","../../../src/Ractive/prototype/shared/makeQuery/remove.js","../../../src/Ractive/prototype/shared/eventStack.js","../../../src/Ractive/prototype/observe/Observer.js","../../../src/Ractive/prototype/observe/PatternObserver.js","../../../src/global/css.js","../../../src/Ractive/prototype/shared/trim.js","../../../src/Ractive/prototype/shared/notEmptyString.js","../../../src/Ractive/prototype/shared/makeArrayMethod.js","../../../src/Ractive/prototype/pop.js","../../../src/Ractive/prototype/push.js","../../../src/Ractive/static/adaptors/array/patch.js","../../../src/Ractive/static/adaptors/array/processWrapper.js","../../../src/Ractive/static/adaptors/array/index.js","../../../src/utils/createBranch.js","../../../src/Ractive/static/adaptors/magicArray.js","../../../src/parse/Parser.js","../../../src/config/types.js","../../../src/parse/converters/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js","../../../src/parse/converters/expressions/primary/literal/readStringLiteral.js","../../../src/parse/converters/expressions/primary/literal/readObjectLiteral.js","../../../src/parse/converters/expressions/primary/literal/readArrayLiteral.js","../../../src/parse/converters/expressions/readPrimary.js","../../../src/parse/converters/expressions/readMemberOrInvocation.js","../../../src/parse/converters/expressions/readTypeof.js","../../../src/parse/converters/expressions/readLogicalOr.js","../../../src/parse/converters/mustache/handlebarsBlockCodes.js","../../../src/parse/converters/utils/getLowestIndex.js","../../../src/parse/utils/trimWhitespace.js","../../../src/Ractive/config/registries.js","../../../src/virtualdom/items/shared/detach.js","../../../src/virtualdom/items/Text.js","../../../src/virtualdom/items/shared/Resolvers/ReferenceResolver.js","../../../src/virtualdom/items/shared/Resolvers/IndexResolver.js","../../../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js","../../../src/virtualdom/items/Interpolator.js","../../../src/virtualdom/items/Section/prototype/rebind.js","../../../src/virtualdom/items/Section/_Section.js","../../../src/virtualdom/items/Triple/_Triple.js","../../../src/virtualdom/items/Element/prototype/bubble.js","../../../src/virtualdom/items/Element/prototype/find.js","../../../src/virtualdom/items/Element/prototype/findAll.js","../../../src/virtualdom/items/Element/prototype/findAllComponents.js","../../../src/virtualdom/items/Element/prototype/findComponent.js","../../../src/virtualdom/items/Element/prototype/init/processBindingAttributes.js","../../../src/virtualdom/items/Element/shared/enforceCase.js","../../../src/virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js","../../../src/virtualdom/items/Element/Attribute/_Attribute.js","../../../src/virtualdom/items/Element/prototype/init/createAttributes.js","../../../src/virtualdom/items/Element/prototype/init/createConditionalAttributes.js","../../../src/virtualdom/items/Element/Binding/ContentEditableBinding.js","../../../src/virtualdom/items/Element/Binding/RadioBinding.js","../../../src/virtualdom/items/Element/Binding/RadioNameBinding.js","../../../src/virtualdom/items/Element/Binding/CheckboxBinding.js","../../../src/virtualdom/items/Element/Binding/SelectBinding.js","../../../src/virtualdom/items/Element/Binding/MultipleSelectBinding.js","../../../src/virtualdom/items/Element/Binding/FileListBinding.js","../../../src/virtualdom/items/Element/Binding/NumericBinding.js","../../../src/virtualdom/items/Element/EventHandler/_EventHandler.js","../../../src/virtualdom/items/Element/prototype/init/createEventHandlers.js","../../../src/virtualdom/items/Element/Decorator/_Decorator.js","../../../src/utils/camelCase.js","../../../src/virtualdom/items/Element/Transition/helpers/prefix.js","../../../src/virtualdom/items/Element/Transition/prototype/getStyle.js","../../../src/virtualdom/items/Element/Transition/prototype/setStyle.js","../../../src/virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js","../../../src/virtualdom/items/Element/Transition/helpers/unprefix.js","../../../src/virtualdom/items/Element/Transition/helpers/hyphenate.js","../../../src/virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js","../../../src/virtualdom/items/Element/Transition/prototype/processParams.js","../../../src/virtualdom/items/Element/Transition/_Transition.js","../../../src/virtualdom/items/Element/_Element.js","../../../src/virtualdom/items/Partial/applyIndent.js","../../../src/virtualdom/items/Partial/_Partial.js","../../../src/viewmodel/Computation/UnresolvedDependency.js","../../../src/viewmodel/prototype/merge/mapOldToNewIndex.js","../../../src/viewmodel/Viewmodel.js","../../../src/virtualdom/items/Component/initialise/createInstance.js","../../../src/virtualdom/items/Component/initialise/updateLiveQueries.js","../../../src/virtualdom/items/Component/_Component.js","../../../src/virtualdom/items/Comment.js","../../../src/virtualdom/items/Yielder.js","../../../src/virtualdom/items/Doctype.js","../../../src/virtualdom/Fragment.js","../../../src/Ractive/prototype/resetPartial.js","../../../src/Ractive/prototype/reverse.js","../../../src/Ractive/prototype/shift.js","../../../src/Ractive/prototype/sort.js","../../../src/Ractive/prototype/splice.js","../../../src/Ractive/prototype/unshift.js","../../../src/Ractive/prototype.js","../../../src/Ractive/static/getNodeInfo.js","../../../src/Ractive.js"],"sourcesContent":["import { isClient, namespaces, svg, vendors } from 'config/environment';\n\nvar createElement, matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;\n\n// Test for SVG support\nif ( !svg ) {\n\tcreateElement = function ( type, ns ) {\n\t\tif ( ns && ns !== namespaces.html ) {\n\t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n\t\t}\n\n\t\treturn document.createElement( type );\n\t};\n} else {\n\tcreateElement = function ( type, ns ) {\n\t\tif ( !ns || ns === namespaces.html ) {\n\t\t\treturn document.createElement( type );\n\t\t}\n\n\t\treturn document.createElementNS( ns, type );\n\t};\n}\n\nfunction getElement ( input ) {\n\tvar output;\n\n\tif ( !input || typeof input === 'boolean' ) { return; }\n\n\tif ( typeof window === 'undefined' || !document || !input ) {\n\t\treturn null;\n\t}\n\n\t// We already have a DOM node - no work to do. (Duck typing alert!)\n\tif ( input.nodeType ) {\n\t\treturn input;\n\t}\n\n\t// Get node from string\n\tif ( typeof input === 'string' ) {\n\t\t// try ID first\n\t\toutput = document.getElementById( input );\n\n\t\t// then as selector, if possible\n\t\tif ( !output && document.querySelector ) {\n\t\t\toutput = document.querySelector( input );\n\t\t}\n\n\t\t// did it work?\n\t\tif ( output && output.nodeType ) {\n\t\t\treturn output;\n\t\t}\n\t}\n\n\t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n\tif ( input[0] && input[0].nodeType ) {\n\t\treturn input[0];\n\t}\n\n\treturn null;\n}\n\nif ( !isClient ) {\n\tmatches = null;\n} else {\n\tdiv = createElement( 'div' );\n\tmethodNames = [ 'matches', 'matchesSelector' ];\n\n\tmakeFunction = function ( methodName ) {\n\t\treturn function ( node, selector ) {\n\t\t\treturn node[ methodName ]( selector );\n\t\t};\n\t};\n\n\ti = methodNames.length;\n\n\twhile ( i-- && !matches ) {\n\t\tunprefixed = methodNames[i];\n\n\t\tif ( div[ unprefixed ] ) {\n\t\t\tmatches = makeFunction( unprefixed );\n\t\t} else {\n\t\t\tj = vendors.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\tprefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\n\t\t\t\tif ( div[ prefixed ] ) {\n\t\t\t\t\tmatches = makeFunction( prefixed );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IE8...\n\tif ( !matches ) {\n\t\tmatches = function ( node, selector ) {\n\t\t\tvar nodes, parentNode, i;\n\n\t\t\tparentNode = node.parentNode;\n\n\t\t\tif ( !parentNode ) {\n\t\t\t\t// empty dummy <div>\n\t\t\t\tdiv.innerHTML = '';\n\n\t\t\t\tparentNode = div;\n\t\t\t\tnode = node.cloneNode();\n\n\t\t\t\tdiv.appendChild( node );\n\t\t\t}\n\n\t\t\tnodes = parentNode.querySelectorAll( selector );\n\n\t\t\ti = nodes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( nodes[i] === node ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\t}\n}\n\nfunction detachNode ( node ) {\n\tif ( node && node.parentNode ) {\n\t\tnode.parentNode.removeChild( node );\n\t}\n\n\treturn node;\n}\n\nexport { createElement, detachNode, getElement, matches };\n","import { isClient } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport 'legacy';\n\nvar create, defineProperty, defineProperties;\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\n\tif ( isClient ) {\n\t\tObject.defineProperty( document.createElement( 'div' ), 'test', { value: 0 });\n\t}\n\n\tdefineProperty = Object.defineProperty;\n} catch ( err ) {\n\t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n\t// only use it with DOM objects (what were you smoking, MSFT?)\n\tdefineProperty = function ( obj, prop, desc ) {\n\t\tobj[ prop ] = desc.value;\n\t};\n}\n\ntry {\n\ttry {\n\t\tObject.defineProperties({}, { test: { value: 0 } });\n\t} catch ( err ) {\n\t\t// TODO how do we account for this? noMagic = true;\n\t\tthrow err;\n\t}\n\n\tif ( isClient ) {\n\t\tObject.defineProperties( createElement( 'div' ), { test: { value: 0 } });\n\t}\n\n\tdefineProperties = Object.defineProperties;\n} catch ( err ) {\n\tdefineProperties = function ( obj, props ) {\n\t\tvar prop;\n\n\t\tfor ( prop in props ) {\n\t\t\tif ( props.hasOwnProperty( prop ) ) {\n\t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n\t\t\t}\n\t\t}\n\t};\n}\n\ntry {\n\tObject.create( null );\n\n\tcreate = Object.create;\n} catch ( err ) {\n\t// sigh\n\tcreate = (function () {\n\t\tvar F = function () {};\n\n\t\treturn function ( proto, props ) {\n\t\t\tvar obj;\n\n\t\t\tif ( proto === null ) {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tF.prototype = proto;\n\t\t\tobj = new F();\n\n\t\t\tif ( props ) {\n\t\t\t\tObject.defineProperties( obj, props );\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t};\n\t}());\n}\n\nexport { create, defineProperty, defineProperties };\n\nexport function extend ( target, ...sources ) {\n\tvar prop, source;\n\n\twhile ( source = sources.shift() ) {\n\t\tfor ( prop in source ) {\n\t\t\tif ( source.hasOwnProperty ( prop ) ) {\n\t\t\t\ttarget[ prop ] = source[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target;\n}\n\nexport function fillGaps ( target, ...sources ) {\n\tsources.forEach( s => {\n\t\tfor ( let key in s ) {\n\t\t\tif ( s.hasOwnProperty( key ) && !( key in target ) ) {\n\t\t\t\ttarget[ key ] = s[ key ];\n\t\t\t}\n\t\t}\n\t});\n\n\treturn target;\n}\n\nexport var hasOwn = Object.prototype.hasOwnProperty;\n","var toString = Object.prototype.toString,\n\tarrayLikePattern = /^\\[object (?:Array|FileList)\\]$/;\n\n// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\nexport function isArray ( thing ) {\n\treturn toString.call( thing ) === '[object Array]';\n}\n\nexport function isArrayLike ( obj ) {\n\treturn arrayLikePattern.test( toString.call( obj ) );\n}\n\nexport function isEmptyObject ( obj ) {\n\t// if it's not an object, it's not an empty object\n\tif ( !isObject( obj ) ) {\n\t\treturn false;\n\t}\n\n\tfor ( var k in obj ) {\n\t\tif ( obj.hasOwnProperty( k ) ) return false;\n\t}\n\n\treturn true;\n}\n\nexport function isEqual ( a, b ) {\n\tif ( a === null && b === null ) {\n\t\treturn true;\n\t}\n\n\tif ( typeof a === 'object' || typeof b === 'object' ) {\n\t\treturn false;\n\t}\n\n\treturn a === b;\n}\n\nexport function isNumber ( thing ) {\n\treturn ( typeof thing  === 'number' || (typeof thing === 'object' && toString.call( thing ) === '[object Number]') );\n}\n\n// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\nexport function isNumeric ( thing ) {\n\treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n}\n\nexport function isObject ( thing ) {\n\treturn ( thing && toString.call( thing ) === '[object Object]' );\n}\n\nexport function isFunction ( thing ) {\n\treturn typeof thing === 'function';\n}\n","/* global console */\nimport { hasConsole } from 'config/environment';\nimport noop from 'utils/noop';\n\nvar alreadyWarned = {}, log, printWarning;\n\nif ( hasConsole ) {\n\tprintWarning = ( message, args ) => {\n\t\tconsole.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );\n\t};\n\n\tlog = function () {\n\t\tconsole.log.apply( console, arguments );\n\t};\n} else {\n\tprintWarning = log = noop;\n}\n\nfunction format ( message, args ) {\n\treturn message.replace( /%s/g, () => args.shift() );\n}\n\nexport function consoleError ( err ) {\n\tif ( hasConsole ) {\n\t\tconsole.error( err );\n\t} else {\n\t\tthrow err;\n\t}\n}\n\nexport function fatal ( message, ...args ) {\n\tmessage = format( message, args );\n\tthrow new Error( message );\n}\n\nexport { log };\n\nexport function warn ( message, ...args ) {\n\tmessage = format( message, args );\n\tprintWarning( message, args );\n}\n\nexport function warnOnce ( message, ...args ) {\n\tmessage = format( message, args );\n\n\tif ( alreadyWarned[ message ] ) {\n\t\treturn;\n\t}\n\n\talreadyWarned[ message ] = true;\n\tprintWarning( message, args );\n}","export function findInViewHierarchy ( registryName, ractive, name ) {\n\tvar instance = findInstance( registryName, ractive, name );\n\treturn instance ? instance[ registryName ][ name ] : null;\n}\n\nexport function findInstance ( registryName, ractive, name ) {\n\twhile ( ractive ) {\n\t\tif ( name in ractive[ registryName ] ) {\n\t\t\treturn ractive;\n\t\t}\n\n\t\tif ( ractive.isolated ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tractive = ractive.parent;\n\t}\n}","import { warnOnce } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport interpolators from 'Ractive/static/interpolators';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar interpolate = function ( from, to, ractive, type ) {\n\tif ( from === to ) {\n\t\treturn snap( to );\n\t}\n\n\tif ( type ) {\n\n\t\tlet interpol = findInViewHierarchy( 'interpolators', ractive, type );\n\t\tif ( interpol ) {\n\t\t\treturn interpol( from, to ) || snap( to );\n\t\t}\n\n\t\twarnOnce( missingPlugin( type, 'interpolator' ) );\n\t}\n\n\treturn interpolators.number( from, to ) ||\n\t       interpolators.array( from, to ) ||\n\t       interpolators.object( from, to ) ||\n\t       snap( to );\n};\n\nexport default interpolate;\n\nfunction snap ( to ) {\n\treturn () => to;\n}\n","import { isNumeric } from 'utils/is';\n\nexport default function add ( root, keypath, d ) {\n\tvar value;\n\n\tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n\t\tthrow new Error( 'Bad arguments' );\n\t}\n\n\tvalue = +root.get( keypath ) || 0;\n\n\tif ( !isNumeric( value ) ) {\n\t\tthrow new Error( 'Cannot add to a non-numeric value' );\n\t}\n\n\treturn root.set( keypath, value + d );\n}\n","import add from './shared/add';\n\nexport default function Ractive$add ( keypath, d ) {\n\treturn add( this, keypath, ( d === undefined ? 1 : +d ) );\n}\n","import { warn } from 'utils/log';\n\n// TODO: deprecate in future release\nvar deprecations = {\n\tconstruct: {\n\t\tdeprecated: 'beforeInit',\n\t\treplacement: 'onconstruct'\n\t},\n\trender: {\n\t\tdeprecated: 'init',\n\t\tmessage: 'The \"init\" method has been deprecated ' +\n\t\t\t'and will likely be removed in a future release. ' +\n\t\t\t'You can either use the \"oninit\" method which will fire ' +\n\t\t\t'only once prior to, and regardless of, any eventual ractive ' +\n\t\t\t'instance being rendered, or if you need to access the ' +\n\t\t\t'rendered DOM, use \"onrender\" instead. ' +\n\t\t\t'See http://docs.ractivejs.org/latest/migrating for more information.'\n\t},\n\tcomplete: {\n\t\tdeprecated: 'complete',\n\t\treplacement: 'oncomplete'\n\t}\n};\n\nfunction Hook ( event ) {\n\tthis.event = event;\n\tthis.method = 'on' + event;\n\tthis.deprecate = deprecations[ event ];\n}\n\nHook.prototype.fire = function ( ractive, arg ) {\n\tfunction call ( method ) {\n\t\tif ( ractive[ method ] ) {\n\t\t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tcall( this.method );\n\n\tif ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {\n\t\tif ( this.deprecate.message ) {\n\t\t\twarn( this.deprecate.message );\n\t\t} else {\n\t\t\twarn( 'The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.', this.deprecate.deprecated, this.deprecate.replacement );\n\t\t}\n\t}\n\n\targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n};\n\nexport default Hook;\n","import { isArray } from 'utils/is';\n\nexport function addToArray ( array, value ) {\n\tvar index = array.indexOf( value );\n\n\tif ( index === -1 ) {\n\t\tarray.push( value );\n\t}\n}\n\nexport function arrayContains ( array, value ) {\n\tfor ( let i = 0, c = array.length; i < c; i++ ) {\n\t\tif ( array[i] == value ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n    return false;\n}\n\nexport function arrayContentsMatch ( a, b ) {\n\tvar i;\n\n\tif ( !isArray( a ) || !isArray( b ) ) {\n\t\treturn false;\n\t}\n\n\tif ( a.length !== b.length ) {\n\t\treturn false;\n\t}\n\n\ti = a.length;\n\twhile ( i-- ) {\n\t\tif ( a[i] !== b[i] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function ensureArray ( x ) {\n\tif ( typeof x === 'string' ) {\n\t\treturn [ x ];\n\t}\n\n\tif ( x === undefined ) {\n\t\treturn [];\n\t}\n\n\treturn x;\n}\n\nexport function lastItem ( array ) {\n\treturn array[ array.length - 1 ];\n}\n\nexport function removeFromArray ( array, member ) {\n\tvar index = array.indexOf( member );\n\n\tif ( index !== -1 ) {\n\t\tarray.splice( index, 1 );\n\t}\n}\n\nexport function toArray ( arrayLike ) {\n\tvar array = [], i = arrayLike.length;\n\twhile ( i-- ) {\n\t\tarray[i] = arrayLike[i];\n\t}\n\n\treturn array;\n}\n","var _Promise,\n\tPENDING = {},\n\tFULFILLED = {},\n\tREJECTED = {};\n\nif ( typeof Promise === 'function' ) {\n\t// use native Promise\n\t_Promise = Promise;\n} else {\n\t_Promise = function ( callback ) {\n\t\tvar fulfilledHandlers = [],\n\t\t\trejectedHandlers = [],\n\t\t\tstate = PENDING,\n\n\t\t\tresult,\n\t\t\tdispatchHandlers,\n\t\t\tmakeResolver,\n\t\t\tfulfil,\n\t\t\treject,\n\n\t\t\tpromise;\n\n\t\tmakeResolver = function ( newState ) {\n\t\t\treturn function ( value ) {\n\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult = value;\n\t\t\t\tstate = newState;\n\n\t\t\t\tdispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );\n\n\t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t\t\t\twait( dispatchHandlers );\n\t\t\t};\n\t\t};\n\n\t\tfulfil = makeResolver( FULFILLED );\n\t\treject = makeResolver( REJECTED );\n\n\t\ttry {\n\t\t\tcallback( fulfil, reject );\n\t\t} catch ( err ) {\n\t\t\treject( err );\n\t\t}\n\n\t\tpromise = {\n\t\t\t// `then()` returns a Promise - 2.2.7\n\t\t\tthen: function ( onFulfilled, onRejected ) {\n\t\t\t\tvar promise2 = new _Promise( function ( fulfil, reject ) {\n\n\t\t\t\t\tvar processResolutionHandler = function ( handler, handlers, forward ) {\n\n\t\t\t\t\t\t// 2.2.1.1\n\t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t\t\t\t\t\t\thandlers.push( function ( p1result ) {\n\t\t\t\t\t\t\t\tvar x;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t\t\t\t\t\t\t// are not given\n\t\t\t\t\t\t\thandlers.push( forward );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// 2.2\n\t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\n\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\treturn promise2;\n\t\t\t}\n\t\t};\n\n\t\tpromise[ 'catch' ] = function ( onRejected ) {\n\t\t\treturn this.then( null, onRejected );\n\t\t};\n\n\t\treturn promise;\n\t};\n\n\t_Promise.all = function ( promises ) {\n\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\tvar result = [], pending, i, processPromise;\n\n\t\t\tif ( !promises.length ) {\n\t\t\t\tfulfil( result );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocessPromise = function ( i ) {\n\t\t\t\tpromises[i].then( function ( value ) {\n\t\t\t\t\tresult[i] = value;\n\n\t\t\t\t\tif ( !--pending ) {\n\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t}\n\t\t\t\t}, reject );\n\t\t\t};\n\n\t\t\tpending = i = promises.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprocessPromise( i );\n\t\t\t}\n\t\t});\n\t};\n\n\t_Promise.resolve = function ( value ) {\n\t\treturn new _Promise( function ( fulfil ) {\n\t\t\tfulfil( value );\n\t\t});\n\t};\n\n\t_Promise.reject = function ( reason ) {\n\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\treject( reason );\n\t\t});\n\t};\n}\n\nexport default _Promise;\n\n// TODO use MutationObservers or something to simulate setImmediate\nfunction wait ( callback ) {\n\tsetTimeout( callback, 0 );\n}\n\nfunction makeDispatcher ( handlers, result ) {\n\treturn function () {\n\t\tvar handler;\n\n\t\twhile ( handler = handlers.shift() ) {\n\t\t\thandler( result );\n\t\t}\n\t};\n}\n\nfunction resolve ( promise, x, fulfil, reject ) {\n\t// Promise Resolution Procedure\n\tvar then;\n\n\t// 2.3.1\n\tif ( x === promise ) {\n\t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t}\n\n\t// 2.3.2\n\tif ( x instanceof _Promise ) {\n\t\tx.then( fulfil, reject );\n\t}\n\n\t// 2.3.3\n\telse if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t\ttry {\n\t\t\tthen = x.then; // 2.3.3.1\n\t\t} catch ( e ) {\n\t\t\treject( e ); // 2.3.3.2\n\t\t\treturn;\n\t\t}\n\n\t\t// 2.3.3.3\n\t\tif ( typeof then === 'function' ) {\n\t\t\tvar called, resolvePromise, rejectPromise;\n\n\t\t\tresolvePromise = function ( y ) {\n\t\t\t\tif ( called ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\tresolve( promise, y, fulfil, reject );\n\t\t\t};\n\n\t\t\trejectPromise = function ( r ) {\n\t\t\t\tif ( called ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\treject( r );\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t\t\t} catch ( e ) {\n\t\t\t\tif ( !called ) { // 2.3.3.3.4.1\n\t\t\t\t\treject( e ); // 2.3.3.3.4.2\n\t\t\t\t\tcalled = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tfulfil( x );\n\t\t}\n\t}\n\n\telse {\n\t\tfulfil( x );\n\t}\n}\n","var starMaps = {};\n\n// This function takes a keypath such as 'foo.bar.baz', and returns\n// all the variants of that keypath that include a wildcard in place\n// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n// to see if any pattern observers are downstream of one or more of\n// these wildcard keypaths (e.g. 'foo.bar.*.status')\nexport default function getPotentialWildcardMatches ( keypath ) {\n\tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\n\tkeys = keypath.split( '.' );\n\tif( !( starMap = starMaps[ keys.length ]) ) {\n\t\tstarMap = getStarMap( keys.length );\n\t}\n\n\tresult = [];\n\n\tmapper = function ( star, i ) {\n\t\treturn star ? '*' : keys[i];\n\t};\n\n\ti = starMap.length;\n\twhile ( i-- ) {\n\t\twildcardKeypath = starMap[i].map( mapper ).join( '.' );\n\n\t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n\t\t\tresult.push( wildcardKeypath );\n\t\t\tresult[ wildcardKeypath ] = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// This function returns all the possible true/false combinations for\n// a given number - e.g. for two, the possible combinations are\n// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n// It does so by getting all the binary values between 0 and e.g. 11\nfunction getStarMap ( num ) {\n\tvar ones = '', max, binary, starMap, mapper, i;\n\n\tif ( !starMaps[ num ] ) {\n\t\tstarMap = [];\n\n\t\twhile ( ones.length < num ) {\n\t\t\tones += 1;\n\t\t}\n\n\t\tmax = parseInt( ones, 2 );\n\n\t\tmapper = function ( digit ) {\n\t\t\treturn digit === '1';\n\t\t};\n\n\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\tbinary = i.toString( 2 );\n\t\t\twhile ( binary.length < num ) {\n\t\t\t\tbinary = '0' + binary;\n\t\t\t}\n\n\t\t\tstarMap[i] = Array.prototype.map.call( binary, mapper );\n\t\t}\n\n\t\tstarMaps[ num ] = starMap;\n\t}\n\n\treturn starMaps[ num ];\n}\n\n\n\n","import { isArray, isNumeric } from 'utils/is';\nimport getPotentialWildcardMatches from 'utils/getPotentialWildcardMatches';\n\nvar refPattern, keypathCache, Keypath;\n\nrefPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n\nkeypathCache = {};\n\nKeypath = function ( str ) {\n\tvar keys = str.split( '.' );\n\n\tthis.str = str;\n\n\tif ( str[0] === '@' ) {\n\t\tthis.isSpecial = true;\n\t\tthis.value = decodeKeypath( str );\n\t}\n\n\tthis.firstKey = keys[0];\n\tthis.lastKey = keys.pop();\n\n\tthis.parent = str === '' ? null : getKeypath( keys.join( '.' ) );\n\tthis.isRoot = !str;\n};\n\nKeypath.prototype = {\n\tequalsOrStartsWith ( keypath ) {\n\t\treturn keypath === this || this.startsWith( keypath );\n\t},\n\n\tjoin ( str ) {\n\t\treturn getKeypath( this.isRoot ? String( str ) : this.str + '.' + str );\n\t},\n\n\treplace ( oldKeypath, newKeypath ) {\n\t\tif ( this === oldKeypath ) {\n\t\t\treturn newKeypath;\n\t\t}\n\n\t\tif ( this.startsWith( oldKeypath ) ) {\n\t\t\treturn newKeypath === null ? newKeypath : getKeypath( this.str.replace( oldKeypath.str + '.', newKeypath.str + '.' ) );\n\t\t}\n\t},\n\n\tstartsWith ( keypath ) {\n\t\tif ( !keypath ) {\n\t\t\t// TODO under what circumstances does this happen?\n\t\t\treturn false;\n\t\t}\n\n\t\treturn keypath && this.str.substr( 0, keypath.str.length + 1 ) === keypath.str + '.';\n\t},\n\n\ttoString () {\n\t\tthrow new Error( 'Bad coercion' );\n\t},\n\n\tvalueOf () {\n\t\tthrow new Error( 'Bad coercion' );\n\t},\n\n\twildcardMatches () {\n\t\treturn this._wildcardMatches || ( this._wildcardMatches = getPotentialWildcardMatches( this.str ) );\n\t}\n};\n\nexport function assignNewKeypath ( target, property, oldKeypath, newKeypath ) {\n\tvar existingKeypath = target[ property ];\n\n\tif ( existingKeypath && ( existingKeypath.equalsOrStartsWith( newKeypath ) || !existingKeypath.equalsOrStartsWith( oldKeypath ) ) ) {\n\t\treturn;\n\t}\n\n\ttarget[ property ] = existingKeypath ? existingKeypath.replace( oldKeypath, newKeypath ) : newKeypath;\n\treturn true;\n}\n\nexport function decodeKeypath ( keypath ) {\n\tvar value = keypath.slice( 2 );\n\n\tif ( keypath[1] === 'i' ) {\n\t\treturn isNumeric( value ) ? +value : value;\n\t} else {\n\t\treturn value;\n\t}\n}\n\nexport function getKeypath ( str ) {\n\tif ( str == null ) {\n\t\treturn str;\n\t}\n\n\t// TODO it *may* be worth having two versions of this function - one where\n\t// keypathCache inherits from null, and one for IE8. Depends on how\n\t// much of an overhead hasOwnProperty is - probably negligible\n\tif ( !keypathCache.hasOwnProperty( str ) ) {\n\t\tkeypathCache[ str ] = new Keypath( str );\n\t}\n\n\treturn keypathCache[ str ];\n}\n\nexport function getMatchingKeypaths ( ractive, pattern ) {\n\tvar keys, key, matchingKeypaths;\n\n\tkeys = pattern.split( '.' );\n\tmatchingKeypaths = [ rootKeypath ];\n\n\twhile ( key = keys.shift() ) {\n\t\tif ( key === '*' ) {\n\t\t\t// expand to find all valid child keypaths\n\t\t\tmatchingKeypaths = matchingKeypaths.reduce( expand, [] );\n\t\t}\n\n\t\telse {\n\t\t\tif ( matchingKeypaths[0] === rootKeypath ) { // first key\n\t\t\t\tmatchingKeypaths[0] = getKeypath( key );\n\t\t\t} else {\n\t\t\t\tmatchingKeypaths = matchingKeypaths.map( concatenate( key ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matchingKeypaths;\n\n\tfunction expand ( matchingKeypaths, keypath ) {\n\t\tvar wrapper, value, key;\n\n\t\twrapper = ractive.viewmodel.wrapped[ keypath.str ];\n\t\tvalue = wrapper ? wrapper.get() : ractive.viewmodel.get( keypath );\n\n\t\tfor ( key in value ) {\n\t\t\tif ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) { // for benefit of IE8\n\t\t\t\tmatchingKeypaths.push( keypath.join( key ) );\n\t\t\t}\n\t\t}\n\n\t\treturn matchingKeypaths;\n\t}\n}\n\nfunction concatenate ( key ) {\n\treturn function ( keypath ) {\n\t\treturn keypath.join( key );\n\t};\n}\n\nexport function normalise ( ref ) {\n\treturn ref ? ref.replace( refPattern, '.$1' ) : '';\n}\n\nexport var rootKeypath = getKeypath( '' );\n","import { getKeypath, normalise } from 'shared/keypaths';\nimport getInnerContext from 'shared/getInnerContext';\n\nexport default function resolveRef ( ractive, ref, fragment ) {\n\tvar keypath;\n\n\tref = normalise( ref );\n\n\t// If a reference begins '~/', it's a top-level reference\n\tif ( ref.substr( 0, 2 ) === '~/' ) {\n\t\tkeypath = getKeypath( ref.substring( 2 ) );\n\t\tcreateMappingIfNecessary( ractive, keypath.firstKey, fragment );\n\t}\n\n\t// If a reference begins with '.', it's either a restricted reference or\n\t// an ancestor reference...\n\telse if ( ref[0] === '.' ) {\n\t\tkeypath = resolveAncestorRef( getInnerContext( fragment ), ref );\n\n\t\tif ( keypath ) {\n\t\t\tcreateMappingIfNecessary( ractive, keypath.firstKey, fragment );\n\t\t}\n\t}\n\n\t// ...otherwise we need to figure out the keypath based on context\n\telse {\n\t\tkeypath = resolveAmbiguousReference( ractive, getKeypath( ref ), fragment );\n\t}\n\n\treturn keypath;\n}\n\nfunction resolveAncestorRef ( baseContext, ref ) {\n\tvar contextKeys;\n\n\t// TODO...\n\tif ( baseContext != undefined && typeof baseContext !== 'string' ) {\n\t\tbaseContext = baseContext.str;\n\t}\n\n\t// {{.}} means 'current context'\n\tif ( ref === '.' ) return getKeypath( baseContext );\n\n\tcontextKeys = baseContext ? baseContext.split( '.' ) : [];\n\n\t// ancestor references (starting \"../\") go up the tree\n\tif ( ref.substr( 0, 3 ) === '../' ) {\n\t\twhile ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\tif ( !contextKeys.length ) {\n\t\t\t\tthrow new Error( 'Could not resolve reference - too many \"../\" prefixes' );\n\t\t\t}\n\n\t\t\tcontextKeys.pop();\n\t\t\tref = ref.substring( 3 );\n\t\t}\n\n\t\tcontextKeys.push( ref );\n\t\treturn getKeypath( contextKeys.join( '.' ) );\n\t}\n\n\t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n\tif ( !baseContext ) {\n\t\treturn getKeypath( ref.replace( /^\\.\\/?/, '' ) );\n\t}\n\n\treturn getKeypath( baseContext + ref.replace( /^\\.\\//, '.' ) );\n}\n\nfunction resolveAmbiguousReference ( ractive, ref, fragment, isParentLookup ) {\n\tvar context,\n\t\tkey,\n\t\tparentValue,\n\t\thasContextChain,\n\t\tparentKeypath;\n\n\tif ( ref.isRoot ) {\n\t\treturn ref;\n\t}\n\n\tkey = ref.firstKey;\n\n\twhile ( fragment ) {\n\t\tcontext = fragment.context;\n\t\tfragment = fragment.parent;\n\n\t\tif ( !context ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\thasContextChain = true;\n\t\tparentValue = ractive.viewmodel.get( context );\n\n\t\tif ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {\n\t\t\treturn context.join( ref.str );\n\t\t}\n\t}\n\n\t// Root/computed/mapped property?\n\tif ( isRootProperty( ractive, key ) ) {\n\t\treturn ref;\n\t}\n\n\t// If this is an inline component, and it's not isolated, we\n\t// can try going up the scope chain\n\tif ( ractive.parent && !ractive.isolated ) {\n\t\thasContextChain = true;\n\t\tfragment = ractive.component.parentFragment;\n\n\t\tkey = getKeypath( key );\n\n\t\tif ( parentKeypath = resolveAmbiguousReference( ractive.parent, key, fragment, true ) ) {\n\t\t\t// We need to create an inter-component binding\n\t\t\tractive.viewmodel.map( key, {\n\t\t\t\torigin: ractive.parent.viewmodel,\n\t\t\t\tkeypath: parentKeypath\n\t\t\t});\n\n\t\t\treturn ref;\n\t\t}\n\t}\n\n\t// If there's no context chain, and the instance is either a) isolated or\n\t// b) an orphan, then we know that the keypath is identical to the reference\n\tif ( !isParentLookup && !hasContextChain ) {\n\t\t// the data object needs to have a property by this name,\n\t\t// to prevent future failed lookups\n\t\tractive.viewmodel.set( ref, undefined );\n\t\treturn ref;\n\t}\n}\n\nfunction createMappingIfNecessary ( ractive, key ) {\n\tvar parentKeypath;\n\n\tif ( !ractive.parent || ractive.isolated || isRootProperty( ractive, key ) ) {\n\t\treturn;\n\t}\n\n\tkey = getKeypath( key );\n\n\tif ( parentKeypath = resolveAmbiguousReference( ractive.parent, key, ractive.component.parentFragment, true ) ) {\n\t\tractive.viewmodel.map( key, {\n\t\t\torigin: ractive.parent.viewmodel,\n\t\t\tkeypath: parentKeypath\n\t\t});\n\t}\n}\n\nfunction isRootProperty ( ractive, key ) {\n\t// special case for reference to root\n\treturn key === '' || key in ractive.data || key in ractive.viewmodel.computations || key in ractive.viewmodel.mappings;\n}\n","export function teardown ( x ) { x.teardown(); }\nexport function unbind ( x ) { x.unbind(); }\nexport function unrender ( x ) { x.unrender(); }","import { removeFromArray } from 'utils/array';\nimport { teardown } from 'shared/methodCallers';\n\nvar TransitionManager = function ( callback, parent ) {\n\tthis.callback = callback;\n\tthis.parent = parent;\n\n\tthis.intros = [];\n\tthis.outros = [];\n\n\tthis.children = [];\n\tthis.totalChildren = this.outroChildren = 0;\n\n\tthis.detachQueue = [];\n\tthis.decoratorQueue = [];\n\tthis.outrosComplete = false;\n\n\tif ( parent ) {\n\t\tparent.addChild( this );\n\t}\n};\n\nTransitionManager.prototype = {\n\taddChild: function ( child ) {\n\t\tthis.children.push( child );\n\n\t\tthis.totalChildren += 1;\n\t\tthis.outroChildren += 1;\n\t},\n\n\tdecrementOutros: function () {\n\t\tthis.outroChildren -= 1;\n\t\tcheck( this );\n\t},\n\n\tdecrementTotal: function () {\n\t\tthis.totalChildren -= 1;\n\t\tcheck( this );\n\t},\n\n\tadd: function ( transition ) {\n\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\tlist.push( transition );\n\t},\n\n\taddDecorator: function ( decorator ) {\n\t\tthis.decoratorQueue.push( decorator );\n\t},\n\n\tremove: function ( transition ) {\n\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\tremoveFromArray( list, transition );\n\t\tcheck( this );\n\t},\n\n\tinit: function () {\n\t\tthis.ready = true;\n\t\tcheck( this );\n\t},\n\n\tdetachNodes: function () {\n\t\tthis.decoratorQueue.forEach( teardown );\n\t\tthis.detachQueue.forEach( detach );\n\t\tthis.children.forEach( detachNodes );\n\t}\n};\n\nfunction detach ( element ) {\n\telement.detach();\n}\n\nfunction detachNodes ( tm ) {\n\ttm.detachNodes();\n}\n\nfunction check ( tm ) {\n\tif ( !tm.ready || tm.outros.length || tm.outroChildren ) return;\n\n\t// If all outros are complete, and we haven't already done this,\n\t// we notify the parent if there is one, otherwise\n\t// start detaching nodes\n\tif ( !tm.outrosComplete ) {\n\t\tif ( tm.parent ) {\n\t\t\ttm.parent.decrementOutros( tm );\n\t\t} else {\n\t\t\ttm.detachNodes();\n\t\t}\n\n\t\ttm.outrosComplete = true;\n\t}\n\n\t// Once everything is done, we can notify parent transition\n\t// manager and call the callback\n\tif ( !tm.intros.length && !tm.totalChildren ) {\n\t\tif ( typeof tm.callback === 'function' ) {\n\t\t\ttm.callback();\n\t\t}\n\n\t\tif ( tm.parent ) {\n\t\t\ttm.parent.decrementTotal();\n\t\t}\n\t}\n}\n\nexport default TransitionManager;\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\nimport Promise from 'utils/Promise';\nimport resolveRef from 'shared/resolveRef';\nimport TransitionManager from './TransitionManager';\n\nvar batch, runloop, unresolved = [], changeHook = new Hook( 'change' );\n\nrunloop = {\n\tstart: function ( instance, returnPromise ) {\n\t\tvar promise, fulfilPromise;\n\n\t\tif ( returnPromise ) {\n\t\t\tpromise = new Promise( f => ( fulfilPromise = f ) );\n\t\t}\n\n\t\tbatch = {\n\t\t\tpreviousBatch: batch,\n\t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t\t\tviews: [],\n\t\t\ttasks: [],\n\t\t\tviewmodels: [],\n\t\t\tinstance: instance\n\t\t};\n\n\t\tif ( instance ) {\n\t\t\tbatch.viewmodels.push( instance.viewmodel );\n\t\t}\n\n\t\treturn promise;\n\t},\n\n\tend: function () {\n\t\tflushChanges();\n\n\t\tbatch.transitionManager.init();\n\t\tif ( !batch.previousBatch && !!batch.instance ) batch.instance.viewmodel.changes = [];\n\t\tbatch = batch.previousBatch;\n\t},\n\n\taddViewmodel: function ( viewmodel ) {\n\t\tif ( batch ) {\n\t\t\tif ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {\n\t\t\t\tbatch.viewmodels.push( viewmodel );\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tviewmodel.applyChanges();\n\t\t\treturn false;\n\t\t}\n\t},\n\n\tregisterTransition: function ( transition ) {\n\t\ttransition._manager = batch.transitionManager;\n\t\tbatch.transitionManager.add( transition );\n\t},\n\n\tregisterDecorator: function ( decorator ) {\n\t\tbatch.transitionManager.addDecorator( decorator );\n\t},\n\n\taddView: function ( view ) {\n\t\tbatch.views.push( view );\n\t},\n\n\taddUnresolved: function ( thing ) {\n\t\tunresolved.push( thing );\n\t},\n\n\tremoveUnresolved: function ( thing ) {\n\t\tremoveFromArray( unresolved, thing );\n\t},\n\n\t// synchronise node detachments with transition ends\n\tdetachWhenReady: function ( thing ) {\n\t\tbatch.transitionManager.detachQueue.push( thing );\n\t},\n\n\tscheduleTask: function ( task, postRender ) {\n\t\tvar _batch;\n\n\t\tif ( !batch ) {\n\t\t\ttask();\n\t\t} else {\n\t\t\t_batch = batch;\n\t\t\twhile ( postRender && _batch.previousBatch ) {\n\t\t\t\t// this can't happen until the DOM has been fully updated\n\t\t\t\t// otherwise in some situations (with components inside elements)\n\t\t\t\t// transitions and decorators will initialise prematurely\n\t\t\t\t_batch = _batch.previousBatch;\n\t\t\t}\n\n\t\t\t_batch.tasks.push( task );\n\t\t}\n\t}\n};\n\nexport default runloop;\n\nfunction flushChanges () {\n\tvar i, thing, changeHash;\n\n\twhile ( batch.viewmodels.length ) {\n\t\tthing = batch.viewmodels.pop();\n\t\tchangeHash = thing.applyChanges();\n\n\t\tif ( changeHash ) {\n\t\t\tchangeHook.fire( thing.ractive, changeHash );\n\t\t}\n\t}\n\n\tattemptKeypathResolution();\n\n\t// Now that changes have been fully propagated, we can update the DOM\n\t// and complete other tasks\n\tfor ( i = 0; i < batch.views.length; i += 1 ) {\n\t\tbatch.views[i].update();\n\t}\n\tbatch.views.length = 0;\n\n\tfor ( i = 0; i < batch.tasks.length; i += 1 ) {\n\t\tbatch.tasks[i]();\n\t}\n\tbatch.tasks.length = 0;\n\n\t// If updating the view caused some model blowback - e.g. a triple\n\t// containing <option> elements caused the binding on the <select>\n\t// to update - then we start over\n\tif ( batch.viewmodels.length ) return flushChanges();\n}\n\nfunction attemptKeypathResolution () {\n\tvar i, item, keypath, resolved;\n\n\ti = unresolved.length;\n\n\t// see if we can resolve any unresolved references\n\twhile ( i-- ) {\n\t\titem = unresolved[i];\n\n\t\tif ( item.keypath ) {\n\t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n\t\t\t// weird that we'd still end up here\n\t\t\tunresolved.splice( i, 1 );\n\t\t\tcontinue; // avoid removing the wrong thing should the next condition be true\n\t\t}\n\n\t\tif ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {\n\t\t\t( resolved || ( resolved = [] ) ).push({\n\t\t\t\titem: item,\n\t\t\t\tkeypath: keypath\n\t\t\t});\n\n\t\t\tunresolved.splice( i, 1 );\n\t\t}\n\t}\n\n\tif ( resolved ) {\n\t\tresolved.forEach( resolve );\n\t}\n}\n\nfunction resolve ( resolved ) {\n\tresolved.item.resolve( resolved.keypath );\n}\n","import animations from 'shared/animations';\nimport Animation from './animate/Animation';\nimport { isEqual } from 'utils/is';\nimport { consoleError } from 'utils/log';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport Promise from 'utils/Promise';\nimport noop from 'utils/noop';\n\nvar noAnimation = { stop: noop };\n\nexport default function Ractive$animate ( keypath, to, options ) {\n\n\tvar promise,\n\t\tfulfilPromise,\n\t\tk,\n\t\tanimation,\n\t\tanimations,\n\t\teasing,\n\t\tduration,\n\t\tstep,\n\t\tcomplete,\n\t\tmakeValueCollector,\n\t\tcurrentValues,\n\t\tcollectValue,\n\t\tdummy,\n\t\tdummyOptions;\n\n\tpromise = new Promise( function ( fulfil ) { fulfilPromise = fulfil; });\n\n\t// animate multiple keypaths\n\tif ( typeof keypath === 'object' ) {\n\t\toptions = to || {};\n\t\teasing = options.easing;\n\t\tduration = options.duration;\n\n\t\tanimations = [];\n\n\t\t// we don't want to pass the `step` and `complete` handlers, as they will\n\t\t// run for each animation! So instead we'll store the handlers and create\n\t\t// our own...\n\t\tstep = options.step;\n\t\tcomplete = options.complete;\n\n\t\tif ( step || complete ) {\n\t\t\tcurrentValues = {};\n\n\t\t\toptions.step = null;\n\t\t\toptions.complete = null;\n\n\t\t\tmakeValueCollector = function ( keypath ) {\n\t\t\t\treturn function ( t, value ) {\n\t\t\t\t\tcurrentValues[ keypath ] = value;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\n\t\tfor ( k in keypath ) {\n\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\tif ( step || complete ) {\n\t\t\t\t\tcollectValue = makeValueCollector( k );\n\t\t\t\t\toptions = {\n\t\t\t\t\t\teasing: easing,\n\t\t\t\t\t\tduration: duration\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( step ) {\n\t\t\t\t\t\toptions.step = collectValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toptions.complete = complete ? collectValue : noop;\n\t\t\t\tanimations.push( animate( this, k, keypath[k], options ) );\n\t\t\t}\n\t\t}\n\n\t\t// Create a dummy animation, to facilitate step/complete\n\t\t// callbacks, and Promise fulfilment\n\t\tdummyOptions = {\n\t\t\teasing: easing,\n\t\t\tduration: duration\n\t\t};\n\n\t\tif ( step ) {\n\t\t\tdummyOptions.step = function ( t ) {\n\t\t\t\tstep( t, currentValues );\n\t\t\t};\n\t\t}\n\n\t\tif ( complete ) {\n\n\t\t\tpromise\n\t\t\t\t.then( function ( t ) {\n\t\t\t\t\tcomplete( t, currentValues );\n\t\t\t\t})\n\t\t\t\t.then( null, consoleError );\n\t\t}\n\n\t\tdummyOptions.complete = fulfilPromise;\n\n\t\tdummy = animate( this, null, null, dummyOptions );\n\t\tanimations.push( dummy );\n\n\t\tpromise.stop = function () {\n\t\t\tvar animation;\n\n\t\t\twhile ( animation = animations.pop() ) {\n\t\t\t\tanimation.stop();\n\t\t\t}\n\n\t\t\tif ( dummy ) {\n\t\t\t\tdummy.stop();\n\t\t\t}\n\t\t};\n\n\t\treturn promise;\n\t}\n\n\t// animate a single keypath\n\toptions = options || {};\n\n\tif ( options.complete ) {\n\t\tpromise\n\t\t\t.then( options.complete )\n\t\t\t.then( null, consoleError );\n\t}\n\n\toptions.complete = fulfilPromise;\n\tanimation = animate( this, keypath, to, options );\n\n\tpromise.stop = function () {\n\t\tanimation.stop();\n\t};\n\treturn promise;\n}\n\nfunction animate ( root, keypath, to, options ) {\n\tvar easing, duration, animation, from;\n\n\tif ( keypath ) {\n\t\tkeypath = getKeypath( normalise( keypath ) );\n\t}\n\n\tif ( keypath !== null ) {\n\t\tfrom = root.viewmodel.get( keypath );\n\t}\n\n\t// cancel any existing animation\n\t// TODO what about upstream/downstream keypaths?\n\tanimations.abort( keypath, root );\n\n\t// don't bother animating values that stay the same\n\tif ( isEqual( from, to ) ) {\n\t\tif ( options.complete ) {\n\t\t\toptions.complete( options.to );\n\t\t}\n\n\t\treturn noAnimation;\n\t}\n\n\t// easing function\n\tif ( options.easing ) {\n\t\tif ( typeof options.easing === 'function' ) {\n\t\t\teasing = options.easing;\n\t\t}\n\n\t\telse {\n\t\t\teasing = root.easing[ options.easing ];\n\t\t}\n\n\t\tif ( typeof easing !== 'function' ) {\n\t\t\teasing = null;\n\t\t}\n\t}\n\n\t// duration\n\tduration = ( options.duration === undefined ? 400 : options.duration );\n\n\t// TODO store keys, use an internal set method\n\tanimation = new Animation({\n\t\tkeypath: keypath,\n\t\tfrom: from,\n\t\tto: to,\n\t\troot: root,\n\t\tduration: duration,\n\t\teasing: easing,\n\t\tinterpolator: options.interpolator,\n\n\t\t// TODO wrap callbacks if necessary, to use instance as context\n\t\tstep: options.step,\n\t\tcomplete: options.complete\n\t});\n\n\tanimations.add( animation );\n\troot._animations.push( animation );\n\n\treturn animation;\n}\n","import Hook from './shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Ractive$detach () {\n\tif ( this.detached ) {\n\t\treturn this.detached;\n\t}\n\n\tif ( this.el ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\tthis.detached = this.fragment.detach();\n\tdetachHook.fire( this );\n\treturn this.detached;\n}\n","export default function Ractive$find ( selector ) {\n\tif ( !this.el ) {\n\t\treturn null;\n\t}\n\n\treturn this.fragment.find( selector );\n}\n","import { lastItem } from 'utils/array';\n\nexport default function ( a, b ) {\n\tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n\tancestryA = getAncestry( a.component || a._ractive.proxy );\n\tancestryB = getAncestry( b.component || b._ractive.proxy );\n\n\toldestA = lastItem( ancestryA );\n\toldestB = lastItem( ancestryB );\n\n\t// remove items from the end of both ancestries as long as they are identical\n\t// - the final one removed is the closest mutual ancestor\n\twhile ( oldestA && ( oldestA === oldestB ) ) {\n\t\tancestryA.pop();\n\t\tancestryB.pop();\n\n\t\tmutualAncestor = oldestA;\n\n\t\toldestA = lastItem( ancestryA );\n\t\toldestB = lastItem( ancestryB );\n\t}\n\n\t// now that we have the mutual ancestor, we can find which is earliest\n\toldestA = oldestA.component || oldestA;\n\toldestB = oldestB.component || oldestB;\n\n\tfragmentA = oldestA.parentFragment;\n\tfragmentB = oldestB.parentFragment;\n\n\t// if both items share a parent fragment, our job is easy\n\tif ( fragmentA === fragmentB ) {\n\t\tindexA = fragmentA.items.indexOf( oldestA );\n\t\tindexB = fragmentB.items.indexOf( oldestB );\n\n\t\t// if it's the same index, it means one contains the other,\n\t\t// so we see which has the longest ancestry\n\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t}\n\n\t// if mutual ancestor is a section, we first test to see which section\n\t// fragment comes first\n\tif ( fragments = mutualAncestor.fragments ) {\n\t\tindexA = fragments.indexOf( fragmentA );\n\t\tindexB = fragments.indexOf( fragmentB );\n\n\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t}\n\n\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );\n}\n\nfunction getParent ( item ) {\n\tvar parentFragment;\n\n\tif ( parentFragment = item.parentFragment ) {\n\t\treturn parentFragment.owner;\n\t}\n\n\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\treturn parentFragment.owner;\n\t}\n}\n\nfunction getAncestry ( item ) {\n\tvar ancestry, ancestor;\n\n\tancestry = [ item ];\n\n\tancestor = getParent( item );\n\n\twhile ( ancestor ) {\n\t\tancestry.push( ancestor );\n\t\tancestor = getParent( ancestor );\n\t}\n\n\treturn ancestry;\n}\n","import { defineProperties } from 'utils/object';\nimport test from './test';\nimport cancel from './cancel';\nimport sort from './sort';\nimport dirty from './dirty';\nimport remove from './remove';\n\nexport default function makeQuery ( ractive, selector, live, isComponentQuery ) {\n\tvar query = [];\n\n\tdefineProperties( query, {\n\t\tselector: { value: selector },\n\t\tlive: { value: live },\n\n\t\t_isComponentQuery: { value: isComponentQuery },\n\t\t_test: { value: test }\n\t});\n\n\tif ( !live ) {\n\t\treturn query;\n\t}\n\n\tdefineProperties( query, {\n\t\tcancel: { value: cancel },\n\n\t\t_root: { value: ractive },\n\t\t_sort: { value: sort },\n\t\t_makeDirty: { value: dirty },\n\t\t_remove: { value: remove },\n\n\t\t_dirty: { value: false, writable: true }\n\t});\n\n\treturn query;\n}\n","import makeQuery from './shared/makeQuery/_makeQuery';\n\nexport default function Ractive$findAll ( selector, options ) {\n\tvar liveQueries, query;\n\n\tif ( !this.el ) {\n\t\treturn [];\n\t}\n\n\toptions = options || {};\n\tliveQueries = this._liveQueries;\n\n\t// Shortcut: if we're maintaining a live query with this\n\t// selector, we don't need to traverse the parallel DOM\n\tif ( query = liveQueries[ selector ] ) {\n\n\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\treturn ( options && options.live ) ? query : query.slice();\n\t}\n\n\tquery = makeQuery( this, selector, !!options.live, false );\n\n\t// Add this to the list of live queries Ractive needs to maintain,\n\t// if applicable\n\tif ( query.live ) {\n\t\tliveQueries.push( selector );\n\t\tliveQueries[ '_' + selector ] = query;\n\t}\n\n\tthis.fragment.findAll( selector, query );\n\treturn query;\n}\n","import makeQuery from './shared/makeQuery/_makeQuery';\n\nexport default function Ractive$findAllComponents ( selector, options ) {\n\tvar liveQueries, query;\n\n\toptions = options || {};\n\tliveQueries = this._liveComponentQueries;\n\n\t// Shortcut: if we're maintaining a live query with this\n\t// selector, we don't need to traverse the parallel DOM\n\tif ( query = liveQueries[ selector ] ) {\n\n\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\treturn ( options && options.live ) ? query : query.slice();\n\t}\n\n\tquery = makeQuery( this, selector, !!options.live, true );\n\n\t// Add this to the list of live queries Ractive needs to maintain,\n\t// if applicable\n\tif ( query.live ) {\n\t\tliveQueries.push( selector );\n\t\tliveQueries[ '_' + selector ] = query;\n\t}\n\n\tthis.fragment.findAllComponents( selector, query );\n\treturn query;\n}\n","export default function Ractive$findComponent ( selector ) {\n\treturn this.fragment.findComponent( selector );\n}\n","export default function Ractive$findContainer ( selector ) {\n\tif ( this.container ) {\n\t\tif ( this.container.component && this.container.component.name === selector ) {\n\t\t\treturn this.container;\n\t\t} else {\n\t\t\treturn this.container.findContainer( selector );\n\t\t}\n\t}\n\n\treturn null;\n}","export default function Ractive$findParent ( selector ) {\n\n\tif ( this.parent ) {\n\t\tif ( this.parent.component && this.parent.component.name === selector ) {\n\t\t\treturn this.parent;\n\t\t} else {\n\t\t\treturn this.parent.findParent ( selector );\n\t\t}\n\t}\n\n\treturn null;\n}\n","import { getKeypath } from 'shared/keypaths'; // TODO bit of a hack, using getKeypath - should maybe have dedicated utility for this\nimport eventStack from './eventStack';\n\nexport default function fireEvent ( ractive, eventName, options = {} ) {\n\tif ( !eventName ) { return; }\n\n\tif ( !options.event ) {\n\n\t\toptions.event = {\n\t\t\tname: eventName,\n\t\t\tcontext: ractive.data,\n\t\t\tkeypath: '',\n\t\t\t// until event not included as argument default\n\t\t\t_noArg: true\n\t\t};\n\n\t}\n\telse {\n\t\toptions.event.name = eventName;\n\t}\n\n\tvar eventNames = getKeypath( eventName ).wildcardMatches();\n\tfireEventAs( ractive, eventNames, options.event, options.args, true );\n}\n\nfunction fireEventAs  ( ractive, eventNames, event, args, initialFire = false ) {\n\n\tvar subscribers, i, bubble = true;\n\n\teventStack.enqueue( ractive, event );\n\n\tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\n\t\tif ( subscribers ) {\n\t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t\t}\n\t}\n\n\teventStack.dequeue( ractive );\n\n\tif ( ractive.parent && bubble ) {\n\n\t\tif ( initialFire && ractive.component ) {\n\t\t\tlet fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];\n\t\t\teventNames = getKeypath( fullName ).wildcardMatches();\n\n\t\t\tif( event ) {\n\t\t\t\tevent.component = ractive;\n\t\t\t}\n\t\t}\n\n\t\tfireEventAs( ractive.parent, eventNames, event, args );\n\t}\n}\n\nfunction notifySubscribers ( ractive, subscribers, event, args ) {\n\n\tvar originalEvent = null, stopEvent = false;\n\n\tif ( event && !event._noArg ) {\n\t\targs = [ event ].concat( args );\n\t}\n\n\t// subscribers can be modified inflight, e.g. \"once\" functionality\n\t// so we need to copy to make sure everyone gets called\n\tsubscribers = subscribers.slice();\n\n\tfor ( let i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t\tif ( subscribers[ i ].apply( ractive, args ) === false ) {\n\t\t\tstopEvent = true;\n\t\t}\n\t}\n\n\tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t}\n\n\treturn !stopEvent;\n}\n\n\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\n\nexport default function Ractive$fire ( eventName ) {\n\n\tvar options = {\n\t\targs: Array.prototype.slice.call( arguments, 1 )\n\t};\n\n\tfireEvent( this, eventName, options );\n}\n","import { getKeypath, normalise } from 'shared/keypaths';\nimport resolveRef from 'shared/resolveRef';\n\nvar options = {\n\tcapture: true, // top-level calls should be intercepted\n\tnoUnwrap: true // wrapped values should NOT be unwrapped\n};\n\nexport default function Ractive$get ( keypath ) {\n\tvar value;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\tvalue = this.viewmodel.get( keypath, options );\n\n\t// Create inter-component binding, if necessary\n\tif ( value === undefined && this.parent && !this.isolated ) {\n\t\tif ( resolveRef( this, keypath.str, this.component.parentFragment ) ) { // creates binding as side-effect, if appropriate\n\t\t\tvalue = this.viewmodel.get( keypath );\n\t\t}\n\t}\n\n\treturn value;\n}\n","import Hook from './shared/hooks/Hook';\nimport { getElement } from 'utils/dom';\n\nvar insertHook = new Hook( 'insert' );\n\nexport default function Ractive$insert ( target, anchor ) {\n\tif ( !this.fragment.rendered ) {\n\t\t// TODO create, and link to, documentation explaining this\n\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t}\n\n\ttarget = getElement( target );\n\tanchor = getElement( anchor ) || null;\n\n\tif ( !target ) {\n\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t}\n\n\ttarget.insertBefore( this.detach(), anchor );\n\tthis.el = target;\n\n\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\tthis.detached = null;\n\n\tfireInsertHook( this );\n}\n\nfunction fireInsertHook( ractive ) {\n\tinsertHook.fire( ractive );\n\n\tractive.findAllComponents('*').forEach( child => {\n\t\tfireInsertHook( child.instance );\n\t});\n}\n","import { isArray } from 'utils/is';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\n\nexport default function Ractive$merge ( keypath, array, options ) {\n\tvar currentArray,\n\t\tpromise;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\tcurrentArray = this.viewmodel.get( keypath );\n\n\t// If either the existing value or the new value isn't an\n\t// array, just do a regular set\n\tif ( !isArray( currentArray ) || !isArray( array ) ) {\n\t\treturn this.set( keypath, array, options && options.complete );\n\t}\n\n\t// Manage transitions\n\tpromise = runloop.start( this, true );\n\tthis.viewmodel.merge( keypath, currentArray, array, options );\n\trunloop.end();\n\n\treturn promise;\n}\n","import { getMatchingKeypaths } from 'shared/keypaths';\n\nexport default function getPattern ( ractive, pattern ) {\n\tvar matchingKeypaths, values;\n\n\tmatchingKeypaths = getMatchingKeypaths( ractive, pattern.str );\n\n\tvalues = {};\n\tmatchingKeypaths.forEach( keypath => {\n\t\tvalues[ keypath.str ] = ractive.get( keypath.str );\n\t});\n\n\treturn values;\n}\n","import { getKeypath, normalise } from 'shared/keypaths';\nimport Observer from './Observer';\nimport PatternObserver from './PatternObserver';\n\nvar wildcard = /\\*/, emptyObject = {};\n\nexport default function getObserverFacade ( ractive, keypath, callback, options ) {\n\tvar observer, isPatternObserver, cancelled;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\toptions = options || emptyObject;\n\n\t// pattern observers are treated differently\n\tif ( wildcard.test( keypath.str ) ) {\n\t\tobserver = new PatternObserver( ractive, keypath, callback, options );\n\t\tractive.viewmodel.patternObservers.push( observer );\n\t\tisPatternObserver = true;\n\t} else {\n\t\tobserver = new Observer( ractive, keypath, callback, options );\n\t}\n\n\tobserver.init( options.init );\n\tractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );\n\n\t// This flag allows observers to initialise even with undefined values\n\tobserver.ready = true;\n\n\treturn {\n\t\tcancel: function () {\n\t\t\tvar index;\n\n\t\t\tif ( cancelled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isPatternObserver ) {\n\t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf( observer );\n\n\t\t\t\tractive.viewmodel.patternObservers.splice( index, 1 );\n\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'patternObservers' );\n\t\t\t} else {\n\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'observers' );\n\t\t\t}\n\t\t\tcancelled = true;\n\t\t}\n\t};\n}\n","import { isObject } from 'utils/is';\nimport getObserverFacade from './observe/getObserverFacade';\n\nexport default function Ractive$observe ( keypath, callback, options ) {\n\n\tvar observers, map, keypaths, i;\n\n\t// Allow a map of keypaths to handlers\n\tif ( isObject( keypath ) ) {\n\t\toptions = callback;\n\t\tmap = keypath;\n\n\t\tobservers = [];\n\n\t\tfor ( keypath in map ) {\n\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\tcallback = map[ keypath ];\n\t\t\t\tobservers.push( this.observe( keypath, callback, options ) );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcancel: function () {\n\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Allow `ractive.observe( callback )` - i.e. observe entire model\n\tif ( typeof keypath === 'function' ) {\n\t\toptions = callback;\n\t\tcallback = keypath;\n\t\tkeypath = '';\n\n\t\treturn getObserverFacade( this, keypath, callback, options );\n\t}\n\n\tkeypaths = keypath.split( ' ' );\n\n\t// Single keypath\n\tif ( keypaths.length === 1 ) {\n\t\treturn getObserverFacade( this, keypath, callback, options );\n\t}\n\n\t// Multiple space-separated keypaths\n\tobservers = [];\n\n\ti = keypaths.length;\n\twhile ( i-- ) {\n\t\tkeypath = keypaths[i];\n\n\t\tif ( keypath ) {\n\t\t\tobservers.push( getObserverFacade( this, keypath, callback, options ) );\n\t\t}\n\t}\n\n\treturn {\n\t\tcancel: function () {\n\t\t\twhile ( observers.length ) {\n\t\t\t\tobservers.pop().cancel();\n\t\t\t}\n\t\t}\n\t};\n}\n","export default function Ractive$observeOnce ( property, callback, options ) {\n\n\tvar observer = this.observe( property, function () {\n\t\tcallback.apply( this, arguments );\n\t\tobserver.cancel();\n\t}, { init: false, defer: options && options.defer });\n\n\treturn observer;\n}\n","import trim from './shared/trim';\nimport notEmptyString from './shared/notEmptyString';\n\nexport default function Ractive$off ( eventName, callback ) {\n\tvar eventNames;\n\n\t// if no arguments specified, remove all callbacks\n\tif ( !eventName ) {\n\t\t// TODO use this code instead, once the following issue has been resolved\n\t\t// in PhantomJS (tests are unpassable otherwise!)\n\t\t// https://github.com/ariya/phantomjs/issues/11856\n\t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t\tfor ( eventName in this._subs ) {\n\t\t\tdelete this._subs[ eventName ];\n\t\t}\n\t}\n\n\telse {\n\t\t// Handle multiple space-separated event names\n\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n\t\teventNames.forEach( eventName => {\n\t\t\tvar subscribers, index;\n\n\t\t\t// If we have subscribers for this event...\n\t\t\tif ( subscribers = this._subs[ eventName ] ) {\n\t\t\t\t// ...if a callback was specified, only remove that\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tindex = subscribers.indexOf( callback );\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ...otherwise remove all callbacks\n\t\t\t\telse {\n\t\t\t\t\tthis._subs[ eventName ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn this;\n}\n","import trim from './shared/trim';\nimport notEmptyString from './shared/notEmptyString';\n\nexport default function Ractive$on ( eventName, callback ) {\n\tvar listeners, n, eventNames;\n\n\t// allow mutliple listeners to be bound in one go\n\tif ( typeof eventName === 'object' ) {\n\t\tlisteners = [];\n\n\t\tfor ( n in eventName ) {\n\t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcancel: function () {\n\t\t\t\tvar listener;\n\n\t\t\t\twhile ( listener = listeners.pop() ) {\n\t\t\t\t\tlistener.cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Handle multiple space-separated event names\n\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n\teventNames.forEach( eventName => {\n\t\t( this._subs[ eventName ] || ( this._subs[ eventName ] = [] ) ).push( callback );\n\t});\n\n\treturn {\n\t\tcancel: () => this.off( eventName, callback )\n\t};\n}\n","export default function Ractive$once ( eventName, handler ) {\n\n\tvar listener = this.on( eventName, function () {\n\t\thandler.apply( this, arguments );\n\t\tlistener.cancel();\n\t});\n\n\t// so we can still do listener.cancel() manually\n\treturn listener;\n}\n","// This function takes an array, the name of a mutator method, and the\n// arguments to call that mutator method with, and returns an array that\n// maps the old indices to their new indices.\n\n// So if you had something like this...\n//\n//     array = [ 'a', 'b', 'c', 'd' ];\n//     array.push( 'e' );\n//\n// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n// have changed. If you then did this...\n//\n//     array.unshift( 'z' );\n//\n// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n// one higher to make room for the 'z'. If you removed an item, the new index\n// would be -1...\n//\n//     array.splice( 2, 2 );\n//\n// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n//\n// This information is used to enable fast, non-destructive shuffling of list\n// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\nexport default function getNewIndices ( array, methodName, args ) {\n\tvar spliceArguments, len, newIndices = [], removeStart, removeEnd, balance, i;\n\n\tspliceArguments = getSpliceEquivalent( array, methodName, args );\n\n\tif ( !spliceArguments ) {\n\t\treturn null; // TODO support reverse and sort?\n\t}\n\n\tlen = array.length;\n\tbalance = ( spliceArguments.length - 2 ) - spliceArguments[1];\n\n\tremoveStart = Math.min( len, spliceArguments[0] );\n\tremoveEnd = removeStart + spliceArguments[1];\n\n\tfor ( i = 0; i < removeStart; i += 1 ) {\n\t\tnewIndices.push( i );\n\t}\n\n\tfor ( ; i < removeEnd; i += 1 ) {\n\t\tnewIndices.push( -1 );\n\t}\n\n\tfor ( ; i < len; i += 1 ) {\n\t\tnewIndices.push( i + balance );\n\t}\n\n\treturn newIndices;\n}\n\n\n// The pop, push, shift an unshift methods can all be represented\n// as an equivalent splice\nfunction getSpliceEquivalent ( array, methodName, args ) {\n\tswitch ( methodName ) {\n\t\tcase 'splice':\n\t\t\tif ( args[0] !== undefined && args[0] < 0 ) {\n\t\t\t\targs[0] = array.length + Math.max( args[0], -array.length );\n\t\t\t}\n\n\t\t\twhile ( args.length < 2 ) {\n\t\t\t\targs.push( 0 );\n\t\t\t}\n\n\t\t\t// ensure we only remove elements that exist\n\t\t\targs[1] = Math.min( args[1], array.length - args[0] );\n\n\t\t\treturn args;\n\n\t\tcase 'sort':\n\t\tcase 'reverse':\n\t\t\treturn null;\n\n\t\tcase 'pop':\n\t\t\tif ( array.length ) {\n\t\t\t\treturn [ array.length - 1, 1 ];\n\t\t\t}\n\t\t\treturn null;\n\n\t\tcase 'push':\n\t\t\treturn [ array.length, 0 ].concat( args );\n\n\t\tcase 'shift':\n\t\t\treturn [ 0, 1 ];\n\n\t\tcase 'unshift':\n\t\t\treturn [ 0, 0 ].concat( args );\n\t}\n}","import css from 'global/css';\nimport Hook from './shared/hooks/Hook';\nimport { getElement } from 'utils/dom';\nimport { consoleError } from 'utils/log';\nimport runloop from 'global/runloop';\n\nvar renderHook = new Hook( 'render' ),\n\tcompleteHook = new Hook( 'complete' );\n\nexport default function Ractive$render ( target, anchor ) {\n\tvar promise, instances, transitionsEnabled;\n\n\t// if `noIntro` is `true`, temporarily disable transitions\n\ttransitionsEnabled = this.transitionsEnabled;\n\tif ( this.noIntro ) {\n\t\tthis.transitionsEnabled = false;\n\t}\n\n\tpromise = runloop.start( this, true );\n\trunloop.scheduleTask( () => renderHook.fire( this ), true );\n\n\tif ( this.fragment.rendered ) {\n\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t}\n\n\ttarget = getElement( target ) || this.el;\n\tanchor = getElement( anchor ) || this.anchor;\n\n\tthis.el = target;\n\tthis.anchor = anchor;\n\n\tif ( !this.append && target ) {\n\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t// avoids certain weird bugs\n\t\tlet others = target.__ractive_instances__;\n\t\tif ( others && others.length ) {\n\t\t\tremoveOtherInstances( others );\n\t\t}\n\n\t\t// make sure we are the only occupants\n\t\ttarget.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n\t}\n\n\t// Add CSS, if applicable\n\tif ( this.constructor.css ) {\n\t\tcss.add( this.constructor );\n\t}\n\n\tif ( target ) {\n\t\tif ( !( instances = target.__ractive_instances__ ) ) {\n\t\t\ttarget.__ractive_instances__ = [ this ];\n\t\t} else {\n\t\t\tinstances.push( this );\n\t\t}\n\n\t\tif ( anchor ) {\n\t\t\ttarget.insertBefore( this.fragment.render(), anchor );\n\t\t} else {\n\t\t\ttarget.appendChild( this.fragment.render() );\n\t\t}\n\t}\n\n\trunloop.end();\n\n\tthis.transitionsEnabled = transitionsEnabled;\n\n\t// It is now more problematic to know if the complete hook\n\t// would fire. Method checking is straight-forward, but would\n\t// also require preflighting event subscriptions. Which seems\n\t// like more work then just letting the promise happen.\n\t// But perhaps I'm wrong about that...\n\tpromise\n\t\t.then( () => completeHook.fire( this ) )\n\t\t.then( null, consoleError );\n\n\treturn promise;\n}\n\nfunction removeOtherInstances( others ) {\n\ttry {\n\t\tothers.splice( 0, others.length ).forEach( r => r.teardown() );\n\t} catch ( err ) {\n\t\t// this can happen with IE8, because it is unbelievably shit. Somehow, in\n\t\t// certain very specific situations, trying to access node.parentNode (which\n\t\t// we need to do in order to detach elements) causes an 'Invalid argument'\n\t\t// error to be thrown. I don't even.\n\t}\n}\n","import runloop from 'global/runloop';\nimport createBranch from 'utils/createBranch';\nimport { getKeypath } from 'shared/keypaths';\nimport { isArray } from 'utils/is';\n\nvar magicAdaptor, MagicWrapper;\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\n\tmagicAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\tvar parentWrapper, parentValue;\n\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tkeypath = getKeypath( keypath );\n\n\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t// we shouldn't wrap this property\n\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ keypath.parent.str ] ) && !parentWrapper.magic ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tparentValue = ractive.viewmodel.get( keypath.parent );\n\n\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( keypath.lastKey ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) );\n\t\t},\n\t\twrap: function ( ractive, property, keypath ) {\n\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t}\n\t};\n\n\tMagicWrapper = function ( ractive, value, keypath ) {\n\t\tvar objKeypath, template, siblings;\n\n\t\tkeypath = getKeypath( keypath );\n\n\t\tthis.magic = true;\n\n\t\tthis.ractive = ractive;\n\t\tthis.keypath = keypath;\n\t\tthis.value = value;\n\n\t\tthis.prop = keypath.lastKey;\n\n\t\tobjKeypath = keypath.parent;\n\t\tthis.obj = objKeypath.isRoot ? ractive.data : ractive.viewmodel.get( objKeypath );\n\n\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\n\t\t// Has this property already been wrapped?\n\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\n\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\tsiblings.push( this );\n\t\t\t}\n\n\t\t\treturn; // already wrapped\n\t\t}\n\n\t\t// No, it hasn't been wrapped\n\t\tcreateAccessors( this, value, template );\n\t};\n\n\tMagicWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\treset: function ( value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updating = true;\n\t\t\tthis.obj[ this.prop ] = value; // trigger set() accessor\n\t\t\trunloop.addViewmodel( this.ractive.viewmodel );\n\t\t\tthis.ractive.viewmodel.mark( this.keypath, { keepExistingWrapper: true } );\n\t\t\tthis.updating = false;\n\t\t\treturn true;\n\t\t},\n\t\tset: function ( key, value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\n\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tvar template, set, value, wrappers, index;\n\n\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t// so that it doesn't get torn down\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\tset = template && template.set;\n\n\t\t\tif ( !set ) {\n\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twrappers = set._ractiveWrappers;\n\n\t\t\tindex = wrappers.indexOf( this );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t}\n\n\t\t\t// Last one out, turn off the lights\n\t\t\tif ( !wrappers.length ) {\n\t\t\t\tvalue = this.obj[ this.prop ];\n\n\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\n\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t}\n\t\t}\n\t};\n} catch ( err ) {\n\tmagicAdaptor = false; // no magic in this browser\n}\n\nexport default magicAdaptor;\n\nfunction createAccessors ( originalWrapper, value, template ) {\n\n\tvar object, property, oldGet, oldSet, get, set;\n\n\tobject = originalWrapper.obj;\n\tproperty = originalWrapper.prop;\n\n\t// Is this template configurable?\n\tif ( template && !template.configurable ) {\n\t\t// Special case - array length\n\t\tif ( property === 'length' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t}\n\n\n\t// Time to wrap this property\n\tif ( template ) {\n\t\toldGet = template.get;\n\t\toldSet = template.set;\n\t}\n\n\tget = oldGet || function () {\n\t\treturn value;\n\t};\n\n\tset = function ( v ) {\n\t\tif ( oldSet ) {\n\t\t\toldSet( v );\n\t\t}\n\n\t\tvalue = oldGet ? oldGet() : v;\n\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t};\n\n\tfunction updateWrapper ( wrapper ) {\n\t\tvar keypath, ractive;\n\n\t\twrapper.value = value;\n\n\t\tif ( wrapper.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tractive = wrapper.ractive;\n\t\tkeypath = wrapper.keypath;\n\n\t\twrapper.updating = true;\n\t\trunloop.start( ractive );\n\n\t\tractive.viewmodel.mark( keypath );\n\n\t\trunloop.end();\n\t\twrapper.updating = false;\n\t}\n\n\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\tset._ractiveWrappers = [ originalWrapper ];\n\tObject.defineProperty( object, property, { get: get, set: set, enumerable: true, configurable: true });\n}\n","import { fatal } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport { magic } from 'config/environment';\nimport { ensureArray } from 'utils/array';\nimport { findInViewHierarchy } from 'shared/registry';\nimport arrayAdaptor from 'Ractive/static/adaptors/array/index';\nimport magicAdaptor from 'Ractive/static/adaptors/magic';\nimport magicArrayAdaptor from 'Ractive/static/adaptors/magicArray';\n\nvar adaptConfigurator = {\n\textend: ( Parent, proto, options ) => {\n\t\tproto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );\n\t},\n\n\tinit: ( Parent, ractive, options ) => {\n\t\tvar protoAdapt, adapt;\n\n\t\tprotoAdapt = ractive.adapt.map( lookup );\n\t\tadapt = ensureArray( options.adapt ).map( lookup );\n\n\t\tfunction lookup ( adaptor ) {\n\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n\t\t\t\tif ( !adaptor ) {\n\t\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn adaptor;\n\t\t}\n\n\t\tractive.adapt = combine( protoAdapt, adapt );\n\n\t\tif ( ractive.magic ) {\n\t\t\tif ( !magic ) {\n\t\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t\t}\n\n\t\t\tif ( ractive.modifyArrays ) {\n\t\t\t\tractive.adapt.push( magicArrayAdaptor );\n\t\t\t}\n\n\t\t\tractive.adapt.push( magicAdaptor );\n\t\t}\n\n\t\tif ( ractive.modifyArrays ) {\n\t\t\tractive.adapt.push( arrayAdaptor );\n\t\t}\n\t}\n};\n\nexport default adaptConfigurator;\n\nfunction combine ( a, b ) {\n\tvar c = a.slice(), i = b.length;\n\n\twhile ( i-- ) {\n\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\tc.push( b[i] );\n\t\t}\n\t}\n\n\treturn c;\n}","var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n\tcommentsPattern = /\\/\\*.*?\\*\\//g,\n\tselectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n\tmediaQueryPattern = /^@media/,\n\tdataRvcGuidPattern = /\\[data-ractive-css=\"[a-z0-9-]+\"]/g;\n\nexport default function transformCss( css, id ) {\n\tvar transformed, dataAttr, addGuid;\n\n\tdataAttr = `[data-ractive-css=\"${id}\"]`;\n\n\taddGuid = function ( selector ) {\n\t\tvar selectorUnits, match, unit, base, prepended, appended, i, transformed = [];\n\n\t\tselectorUnits = [];\n\n\t\twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t\t\tselectorUnits.push({\n\t\t\t\tstr: match[0],\n\t\t\t\tbase: match[1],\n\t\t\t\tmodifiers: match[2]\n\t\t\t});\n\t\t}\n\n\t\t// For each simple selector within the selector, we need to create a version\n\t\t// that a) combines with the id, and b) is inside the id\n\t\tbase = selectorUnits.map( extractString );\n\n\t\ti = selectorUnits.length;\n\t\twhile ( i-- ) {\n\t\t\tappended = base.slice();\n\n\t\t\t// Pseudo-selectors should go after the attribute selector\n\t\t\tunit = selectorUnits[i];\n\t\t\tappended[i] = unit.base + dataAttr + unit.modifiers || '';\n\n\t\t\tprepended = base.slice();\n\t\t\tprepended[i] = dataAttr + ' ' + prepended[i];\n\n\t\t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t\t}\n\n\t\treturn transformed.join( ', ' );\n\t};\n\n\tif ( dataRvcGuidPattern.test( css ) ) {\n\t\ttransformed = css.replace( dataRvcGuidPattern, dataAttr );\n\t} else {\n\t\ttransformed = css\n\t\t.replace( commentsPattern, '' )\n\t\t.replace( selectorsPattern, function ( match, $1 ) {\n\t\t\tvar selectors, transformed;\n\n\t\t\t// don't transform media queries!\n\t\t\tif ( mediaQueryPattern.test( $1 ) ) return match;\n\n\t\t\tselectors = $1.split( ',' ).map( trim );\n\t\t\ttransformed = selectors.map( addGuid ).join( ', ' ) + ' ';\n\n\t\t\treturn match.replace( $1, transformed );\n\t\t});\n\t}\n\n\treturn transformed;\n}\n\nfunction trim ( str ) {\n\tif ( str.trim ) {\n\t\treturn str.trim();\n\t}\n\n\treturn str.replace( /^\\s+/, '' ).replace( /\\s+$/, '' );\n}\n\nfunction extractString ( unit ) {\n\treturn unit.str;\n}\n","import transformCss from './transform';\n\nvar cssConfigurator = {\n\tname: 'css',\n\n\textend: ( Parent, proto, options ) => {\n\t\tvar guid = proto.constructor._guid, css;\n\n\t\tif ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {\n\t\t\tproto.constructor.css = css;\n\t\t}\n\t},\n\n\tinit: () => {}\n};\n\nfunction getCss ( css, target, guid ) {\n\tif ( !css ) { return; }\n\n\treturn target.noCssTransform\n\t\t? css\n\t\t: transformCss( css, guid );\n}\n\nexport default cssConfigurator;\n","export default function ( method, superMethod, force ) {\n\n\tif ( force || needsSuper( method, superMethod ) )  {\n\n\t\treturn function () {\n\n\t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\n\t\t\tthis._super = superMethod;\n\n\t\t\tresult = method.apply( this, arguments );\n\n\t\t\tif ( hasSuper ) {\n\t\t\t\tthis._super = _super;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\telse {\n\t\treturn method;\n\t}\n}\n\nfunction needsSuper ( method, superMethod ) {\n\treturn typeof superMethod === 'function' && /_super/.test( method );\n}\n","import wrap from 'utils/wrapMethod';\n\nvar dataConfigurator = {\n\tname: 'data',\n\n\textend: ( Parent, proto, options ) => {\n\t\tproto.data = combine( Parent, proto, options );\n\t},\n\n\tinit: ( Parent, ractive, options ) => {\n\t\tvar value = options.data,\n\t\t\tresult = combine( Parent, ractive, options );\n\n\t\tif ( typeof result === 'function' ) {\n\t\t\tresult = result.call( ractive, value ) || value;\n\t\t}\n\n\t\treturn ractive.data = result || {};\n\t},\n\n\treset: function ( ractive ) {\n\t\tvar result = this.init( ractive.constructor, ractive, ractive );\n\n\t\tif ( result ) {\n\t\t\tractive.data = result;\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\nexport default dataConfigurator;\n\nfunction combine ( Parent, target, options ) {\n\tvar value = options.data || {},\n\t\tparentValue = getAddedKeys( Parent.prototype.data );\n\n\tif ( typeof value !== 'object' && typeof value !== 'function') {\n\t\tthrow new TypeError( 'data option must be an object or a function, \"' + value + '\" is not valid' );\n\t}\n\n\treturn dispatch( parentValue, value );\n}\n\nfunction getAddedKeys ( parent ) {\n\t// only for functions that had keys added\n\tif ( typeof parent !== 'function' || !Object.keys( parent ).length ) { return parent; }\n\n\t// copy the added keys to temp 'object', otherwise\n\t// parent would be interpreted as 'function' by dispatch\n\tlet temp = {};\n\tcopy( parent, temp );\n\n\t// roll in added keys\n\treturn dispatch( parent, temp );\n}\n\nfunction dispatch ( parent, child ) {\n\tif ( typeof child === 'function' ) {\n\t\treturn extendFn( child, parent );\n\t} else if ( typeof parent === 'function' ){\n\t\treturn fromFn( child, parent );\n\t} else {\n\t\treturn fromProperties( child, parent );\n\t}\n}\n\nfunction copy ( from, to, fillOnly ) {\n\tfor ( let key in from ) {\n\t\tif ( !( to._mappings && to._mappings[ key ] && to._mappings[ key ].updatable ) && fillOnly && key in to ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tto[ key ] = from[ key ];\n\t}\n}\n\nfunction fromProperties ( child, parent ) {\n\tchild = child || {};\n\n\tif ( !parent ) { return child; }\n\n\tcopy( parent, child, true );\n\n\treturn child;\n}\n\nfunction fromFn ( child, parentFn ) {\n\treturn function ( data ) {\n\t\tvar keys;\n\n\t\tif ( child ) {\n\t\t\t// Track the keys that our on the child,\n\t\t\t// but not on the data. We'll need to apply these\n\t\t\t// after the parent function returns.\n\t\t\tkeys = [];\n\n\t\t\tfor ( let key in child ) {\n\t\t\t\tif ( !data || !( key in data ) ) {\n\t\t\t\t\tkeys.push( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// call the parent fn, use data if no return value\n\t\tdata = parentFn.call( this, data ) || data;\n\n\t\t// Copy child keys back onto data. The child keys\n\t\t// should take precedence over whatever the\n\t\t// parent did with the data.\n\t\tif ( keys && keys.length ) {\n\t\t\tdata = data || {};\n\n\t\t\tkeys.forEach( key => {\n\t\t\t\tdata[ key ] = child[ key ];\n\t\t\t});\n\t\t}\n\n\t\treturn data;\n\t};\n}\n\nfunction extendFn ( childFn, parent ) {\n\tvar parentFn;\n\n\tif ( typeof parent !== 'function' ) {\n\t\t// copy props to data\n\t\tparentFn = function ( data ) {\n\t\t\tfromProperties( data, parent );\n\t\t};\n\t} else {\n\t\tparentFn = function ( data ) {\n\t\t\t// give parent function it's own this._super context,\n\t\t\t// otherwise this._super is from child and\n\t\t\t// causes infinite loop\n\t\t\tparent = wrap( parent, () => {}, true );\n\n\t\t\treturn parent.call( this, data ) || data;\n\t\t};\n\t}\n\n\treturn wrap( childFn, parentFn );\n}\n","var delimiterChangePattern = /^[^\\s=]+/, whitespacePattern = /^\\s+/;\n\nexport default function readDelimiterChange ( parser ) {\n\tvar start, opening, closing;\n\n\tif ( !parser.matchString( '=' ) ) {\n\t\treturn null;\n\t}\n\n\tstart = parser.pos;\n\n\t// allow whitespace before new opening delimiter\n\tparser.allowWhitespace();\n\n\topening = parser.matchPattern( delimiterChangePattern );\n\tif ( !opening ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace (in fact, it's necessary...)\n\tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t\treturn null;\n\t}\n\n\tclosing = parser.matchPattern( delimiterChangePattern );\n\tif ( !closing ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace before closing '='\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '=' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn [ opening, closing ];\n}\n","import { DELIMCHANGE } from 'config/types';\nimport readDelimiterChange from './mustache/readDelimiterChange';\n\nvar delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\nexport default function readMustache ( parser ) {\n\tvar mustache, i;\n\n\t// If we're inside a <script> or <style> tag, and we're not\n\t// interpolating, bug out\n\tif ( parser.interpolate[ parser.inside ] === false ) {\n\t\treturn null;\n\t}\n\n\tfor ( i = 0; i < parser.tags.length; i += 1 ) {\n\t\tif ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {\n\t\t\treturn mustache;\n\t\t}\n\t}\n}\n\nfunction readMustacheOfType ( parser, tag ) {\n\tvar start, mustache, reader, i;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\t// delimiter change?\n\tif ( mustache = readDelimiterChange( parser ) ) {\n\t\t// find closing delimiter or abort...\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// ...then make the switch\n\t\ttag.open = mustache[0];\n\t\ttag.close = mustache[1];\n\t\tparser.sortMustacheTags();\n\n\t\treturn delimiterChangeToken;\n\t}\n\n\tparser.allowWhitespace();\n\n\t// illegal section closer\n\tif ( parser.matchString( '/' ) ) {\n\t\tparser.pos -= ( tag.close.length + 1 );\n\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t}\n\n\tfor ( i = 0; i < tag.readers.length; i += 1 ) {\n\t\treader = tag.readers[i];\n\n\t\tif ( mustache = reader( parser, tag ) ) {\n\t\t\tif ( tag.isStatic ) {\n\t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n\t\t\t}\n\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\tmustache.p = parser.getLinePos( start );\n\t\t\t}\n\n\t\t\treturn mustache;\n\t\t}\n\t}\n\n\tparser.pos = start;\n\treturn null;\n}\n","import { NUMBER_LITERAL } from 'config/types';\n\n// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\nvar numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\nexport default function readNumberLiteral ( parser ) {\n\tvar result;\n\n\tif ( result = parser.matchPattern( numberPattern ) ) {\n\t\treturn {\n\t\t\tt: NUMBER_LITERAL,\n\t\t\tv: result\n\t\t};\n\t}\n\n\treturn null;\n}\n","import { BOOLEAN_LITERAL } from 'config/types';\n\nexport default function readBooleanLiteral ( parser ) {\n\tvar remaining = parser.remaining();\n\n\tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t\tparser.pos += 4;\n\t\treturn {\n\t\t\tt: BOOLEAN_LITERAL,\n\t\t\tv: 'true'\n\t\t};\n\t}\n\n\tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t\tparser.pos += 5;\n\t\treturn {\n\t\t\tt: BOOLEAN_LITERAL,\n\t\t\tv: 'false'\n\t\t};\n\t}\n\n\treturn null;\n}\n","import readStringLiteral from '../primary/literal/readStringLiteral';\nimport readNumberLiteral from '../primary/literal/readNumberLiteral';\nimport { name as namePattern } from './patterns';\n\nvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n// http://mathiasbynens.be/notes/javascript-properties\n// can be any name, string literal, or number literal\nexport default function readKey ( parser ) {\n\tvar token;\n\n\tif ( token = readStringLiteral( parser ) ) {\n\t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t}\n\n\tif ( token = readNumberLiteral( parser ) ) {\n\t\treturn token.v;\n\t}\n\n\tif ( token = parser.matchPattern( namePattern ) ) {\n\t\treturn token;\n\t}\n}\n","import { KEY_VALUE_PAIR } from 'config/types';\nimport readKey from '../../../shared/readKey';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readKeyValuePair ( parser ) {\n\tvar start, key, value;\n\n\tstart = parser.pos;\n\n\t// allow whitespace between '{' and key\n\tparser.allowWhitespace();\n\n\tkey = readKey( parser );\n\tif ( key === null ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace between key and ':'\n\tparser.allowWhitespace();\n\n\t// next character must be ':'\n\tif ( !parser.matchString( ':' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace between ':' and value\n\tparser.allowWhitespace();\n\n\t// next expression must be a, well... expression\n\tvalue = readExpression( parser );\n\tif ( value === null ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tt: KEY_VALUE_PAIR,\n\t\tk: key,\n\t\tv: value\n\t};\n}\n","import getKeyValuePair from './keyValuePair';\n\nexport default function readKeyValuePairs ( parser ) {\n\tvar start, pairs, pair, keyValuePairs;\n\n\tstart = parser.pos;\n\n\tpair = getKeyValuePair( parser );\n\tif ( pair === null ) {\n\t\treturn null;\n\t}\n\n\tpairs = [ pair ];\n\n\tif ( parser.matchString( ',' ) ) {\n\t\tkeyValuePairs = readKeyValuePairs( parser );\n\n\t\tif ( !keyValuePairs ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn pairs.concat( keyValuePairs );\n\t}\n\n\treturn pairs;\n}\n","import { expectedExpression } from './errors';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readExpressionList ( parser ) {\n\tvar start, expressions, expr, next;\n\n\tstart = parser.pos;\n\n\tparser.allowWhitespace();\n\n\texpr = readExpression( parser );\n\n\tif ( expr === null ) {\n\t\treturn null;\n\t}\n\n\texpressions = [ expr ];\n\n\t// allow whitespace between expression and ','\n\tparser.allowWhitespace();\n\n\tif ( parser.matchString( ',' ) ) {\n\t\tnext = readExpressionList( parser );\n\t\tif ( next === null ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\tnext.forEach( append );\n\t}\n\n\tfunction append ( expression ) {\n\t\texpressions.push( expression );\n\t}\n\n\treturn expressions;\n}\n","import readNumberLiteral from './literal/readNumberLiteral';\nimport readBooleanLiteral from './literal/readBooleanLiteral';\nimport readStringLiteral from './literal/readStringLiteral';\nimport readObjectLiteral from './literal/readObjectLiteral';\nimport readArrayLiteral from './literal/readArrayLiteral';\n\nexport default function readLiteral ( parser ) {\n\treturn readNumberLiteral( parser )  ||\n\t       readBooleanLiteral( parser ) ||\n\t       readStringLiteral( parser )  ||\n\t       readObjectLiteral( parser )  ||\n\t       readArrayLiteral( parser );\n}\n","import { GLOBAL, REFERENCE } from 'config/types';\nimport { normalise } from 'shared/keypaths';\n\nvar prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n\tglobals,\n\tkeywords;\n\n// if a reference is a browser global, we don't deference it later, so it needs special treatment\nglobals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n// keywords are not valid references, with the exception of `this`\nkeywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\nvar legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\nvar relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n\nexport default function readReference ( parser ) {\n\tvar startPos, prefix, name, global, reference, lastDotIndex;\n\n\tstartPos = parser.pos;\n\n\tname = parser.matchPattern( /^@(?:keypath|index|key)/ );\n\n\tif ( !name ) {\n\t\tprefix = parser.matchPattern( prefixPattern ) || '';\n\t\tname = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||\n\t\t       parser.matchPattern( legalReference );\n\n\t\tif ( !name && prefix === '.' ) {\n\t\t\tprefix = '';\n\t\t\tname = '.';\n\t\t}\n\t}\n\n\tif ( !name ) {\n\t\treturn null;\n\t}\n\n\t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n\tif ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {\n\t\tparser.pos = startPos;\n\t\treturn null;\n\t}\n\n\t// if this is a browser global, stop here\n\tif ( !prefix && globals.test( name ) ) {\n\t\tglobal = globals.exec( name )[0];\n\t\tparser.pos = startPos + global.length;\n\n\t\treturn {\n\t\t\tt: GLOBAL,\n\t\t\tv: global\n\t\t};\n\t}\n\n\treference = ( prefix || '' ) + normalise( name );\n\n\tif ( parser.matchString( '(' ) ) {\n\n\t\t// if this is a method invocation (as opposed to a function) we need\n\t\t// to strip the method name from the reference combo, else the context\n\t\t// will be wrong\n\t\tlastDotIndex = name.lastIndexOf( '.' );\n\t\tif ( lastDotIndex !== -1 ) {\n\t\t\treference = reference.substr( 0, lastDotIndex );\n\t\t\tparser.pos = startPos + reference.length;\n\t\t} else {\n\t\t\tparser.pos -= 1;\n\t\t}\n\t}\n\n\treturn {\n\t\tt: REFERENCE,\n\t\tn: reference.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t};\n}\n","import { BRACKETED } from 'config/types';\nimport { expectedExpression, expectedParen } from '../shared/errors';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readBracketedExpression ( parser ) {\n\tvar start, expr;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( '(' ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\texpr = readExpression( parser );\n\tif ( !expr ) {\n\t\tparser.error( expectedExpression );\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( ')' ) ) {\n\t\tparser.error( expectedParen );\n\t}\n\n\treturn {\n\t\tt: BRACKETED,\n\t\tx: expr\n\t};\n}\n","import { REFINEMENT } from 'config/types';\nimport { expectedExpression } from './errors';\nimport { name as namePattern } from './patterns';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readRefinement ( parser ) {\n\tvar start, name, expr;\n\n\tstart = parser.pos;\n\n\tparser.allowWhitespace();\n\n\t// \".\" name\n\tif ( parser.matchString( '.' ) ) {\n\t\tparser.allowWhitespace();\n\n\t\tif ( name = parser.matchPattern( namePattern ) ) {\n\t\t\treturn {\n\t\t\t\tt: REFINEMENT,\n\t\t\t\tn: name\n\t\t\t};\n\t\t}\n\n\t\tparser.error( 'Expected a property name' );\n\t}\n\n\t// \"[\" expression \"]\"\n\tif ( parser.matchString( '[' ) ) {\n\t\tparser.allowWhitespace();\n\n\t\texpr = readExpression( parser );\n\t\tif ( !expr ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\tparser.error( 'Expected \\']\\'' );\n\t\t}\n\n\t\treturn {\n\t\t\tt: REFINEMENT,\n\t\t\tx: expr\n\t\t};\n\t}\n\n\treturn null;\n}\n","import { CONDITIONAL } from 'config/types';\nimport readLogicalOr from './readLogicalOr';\nimport { expectedExpression } from './shared/errors';\nimport readExpression from 'parse/converters/readExpression';\n\n// The conditional operator is the lowest precedence operator, so we start here\nexport default function getConditional ( parser ) {\n\tvar start, expression, ifTrue, ifFalse;\n\n\texpression = readLogicalOr( parser );\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tstart = parser.pos;\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '?' ) ) {\n\t\tparser.pos = start;\n\t\treturn expression;\n\t}\n\n\tparser.allowWhitespace();\n\n\tifTrue = readExpression( parser );\n\tif ( !ifTrue ) {\n\t\tparser.error( expectedExpression );\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( ':' ) ) {\n\t\tparser.error( 'Expected \":\"' );\n\t}\n\n\tparser.allowWhitespace();\n\n\tifFalse = readExpression( parser );\n\tif ( !ifFalse ) {\n\t\tparser.error( expectedExpression );\n\t}\n\n\treturn {\n\t\tt: CONDITIONAL,\n\t\to: [ expression, ifTrue, ifFalse ]\n\t};\n}\n","import readConditional from './expressions/readConditional';\n\nexport default function readExpression ( parser ) {\n\t// The conditional operator is the lowest precedence operator (except yield,\n\t// assignment operators, and commas, none of which are supported), so we\n\t// start there. If it doesn't match, it 'falls through' to progressively\n\t// higher precedence operators, until it eventually matches (or fails to\n\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\treturn readConditional( parser );\n}","import { REFERENCE, BOOLEAN_LITERAL, GLOBAL, NUMBER_LITERAL, STRING_LITERAL, ARRAY_LITERAL, OBJECT_LITERAL, KEY_VALUE_PAIR, PREFIX_OPERATOR, INFIX_OPERATOR, INVOCATION, BRACKETED, MEMBER, REFINEMENT, CONDITIONAL } from 'config/types';\nimport { isObject } from 'utils/is';\n\nexport default function flattenExpression ( expression ) {\n\tvar refs;\n\n\textractRefs( expression, refs = [] );\n\n\treturn {\n\t\tr: refs,\n\t\ts: stringify( expression )\n\t};\n\n\tfunction stringify ( node ) {\n\t\tswitch ( node.t ) {\n\t\t\tcase BOOLEAN_LITERAL:\n\t\t\tcase GLOBAL:\n\t\t\tcase NUMBER_LITERAL:\n\t\t\treturn node.v;\n\n\t\t\tcase STRING_LITERAL:\n\t\t\treturn JSON.stringify( String( node.v ) );\n\n\t\t\tcase ARRAY_LITERAL:\n\t\t\treturn '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';\n\n\t\t\tcase OBJECT_LITERAL:\n\t\t\treturn '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';\n\n\t\t\tcase KEY_VALUE_PAIR:\n\t\t\treturn node.k + ':' + stringify( node.v );\n\n\t\t\tcase PREFIX_OPERATOR:\n\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );\n\n\t\t\tcase INFIX_OPERATOR:\n\t\t\treturn stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );\n\n\t\t\tcase INVOCATION:\n\t\t\treturn stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';\n\n\t\t\tcase BRACKETED:\n\t\t\treturn '(' + stringify( node.x ) + ')';\n\n\t\t\tcase MEMBER:\n\t\t\treturn stringify( node.x ) + stringify( node.r );\n\n\t\t\tcase REFINEMENT:\n\t\t\treturn ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );\n\n\t\t\tcase CONDITIONAL:\n\t\t\treturn stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );\n\n\t\t\tcase REFERENCE:\n\t\t\treturn '_' + refs.indexOf( node.n );\n\n\t\t\tdefault:\n\t\t\tthrow new Error( 'Expected legal JavaScript' );\n\t\t}\n\t}\n}\n\n// TODO maybe refactor this?\nfunction extractRefs ( node, refs ) {\n\tvar i, list;\n\n\tif ( node.t === REFERENCE ) {\n\t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t\t\trefs.unshift( node.n );\n\t\t}\n\t}\n\n\tlist = node.o || node.m;\n\tif ( list ) {\n\t\tif ( isObject( list ) ) {\n\t\t\textractRefs( list, refs );\n\t\t} else {\n\t\t\ti = list.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\textractRefs( list[i], refs );\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( node.x ) {\n\t\textractRefs( node.x, refs );\n\t}\n\n\tif ( node.r ) {\n\t\textractRefs( node.r, refs );\n\t}\n\n\tif ( node.v ) {\n\t\textractRefs( node.v, refs );\n\t}\n}\n\n","import { REFERENCE, BRACKETED, NUMBER_LITERAL, MEMBER, REFINEMENT } from 'config/types';\nimport flattenExpression from './flattenExpression';\n\nvar arrayMemberPattern = /^[0-9][1-9]*$/;\n\nexport default function refineExpression ( expression, mustache ) {\n\tvar referenceExpression;\n\n\tif ( expression ) {\n\t\twhile ( expression.t === BRACKETED && expression.x ) {\n\t\t\texpression = expression.x;\n\t\t}\n\n\t\t// special case - integers should be treated as array members references,\n\t\t// rather than as expressions in their own right\n\t\tif ( expression.t === REFERENCE ) {\n\t\t\tmustache.r = expression.n;\n\t\t} else {\n\t\t\tif ( expression.t === NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {\n\t\t\t\tmustache.r = expression.v;\n\t\t\t} else if ( referenceExpression = getReferenceExpression( expression ) ) {\n\t\t\t\tmustache.rx = referenceExpression;\n\t\t\t} else {\n\t\t\t\tmustache.x = flattenExpression( expression );\n\t\t\t}\n\t\t}\n\n\t\treturn mustache;\n\t}\n}\n\n// TODO refactor this! it's bewildering\nfunction getReferenceExpression ( expression ) {\n\tvar members = [], refinement;\n\n\twhile ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {\n\t\trefinement = expression.r;\n\n\t\tif ( refinement.x ) {\n\t\t\tif ( refinement.x.t === REFERENCE ) {\n\t\t\t\tmembers.unshift( refinement.x );\n\t\t\t} else {\n\t\t\t\tmembers.unshift( flattenExpression( refinement.x ) );\n\t\t\t}\n\t\t} else {\n\t\t\tmembers.unshift( refinement.n );\n\t\t}\n\n\t\texpression = expression.x;\n\t}\n\n\tif ( expression.t !== REFERENCE ) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tr: expression.n,\n\t\tm: members\n\t};\n}","import { TRIPLE } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readTriple ( parser, tag ) {\n\tvar expression = readExpression( parser ), triple;\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\ttriple = { t: TRIPLE };\n\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n\treturn triple;\n}","import { TRIPLE } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readUnescaped ( parser, tag ) {\n\tvar expression, triple;\n\n\tif ( !parser.matchString( '&' ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\texpression = readExpression( parser );\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\ttriple = { t: TRIPLE };\n\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n\treturn triple;\n}","import { PARTIAL, SECTION, SECTION_WITH } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readPartial ( parser, tag ) {\n\tvar start, nameStart, expression, context, partial;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( '>' ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\tnameStart = parser.pos;\n\n\t// Partial names can include hyphens, so we can't use readExpression\n\t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n\t// `foo-bar` should be read as a single name, rather than 'subtract\n\t// bar from foo'\n\tparser.relaxedNames = true;\n\texpression = readExpression( parser );\n\tparser.relaxedNames = false;\n\n\tparser.allowWhitespace();\n\tcontext = readExpression( parser );\n\tparser.allowWhitespace();\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tpartial = { t: PARTIAL };\n\trefineExpression( expression, partial ); // TODO...\n\n\tparser.allowWhitespace();\n\n\t// if we have another expression - e.g. `{{>foo bar}}` - then\n\t// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n\tif ( context ) {\n\t\tpartial = {\n\t\t\tt: SECTION,\n\t\t\tn: SECTION_WITH,\n\t\t\tf: [ partial ]\n\t\t};\n\n\t\trefineExpression( context, partial );\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\treturn partial;\n}","import { COMMENT } from 'config/types';\n\nexport default function readComment ( parser, tag ) {\n\tvar index;\n\n\tif ( !parser.matchString( '!' ) ) {\n\t\treturn null;\n\t}\n\n\tindex = parser.remaining().indexOf( tag.close );\n\n\tif ( index !== -1 ) {\n\t\tparser.pos += index + tag.close.length;\n\t\treturn { t: COMMENT };\n\t}\n}","import readExpression from './readExpression';\nimport readReference from './expressions/primary/readReference';\n\nexport default function readExpressionOrReference ( parser, expectedFollowers ) {\n\tvar start, expression, i;\n\n\tstart = parser.pos;\n\texpression = readExpression( parser );\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tfor ( i = 0; i < expectedFollowers.length; i += 1 ) {\n\t\tif ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {\n\t\t\treturn expression;\n\t\t}\n\t}\n\n\tparser.pos = start;\n\treturn readReference( parser );\n}","import { INTERPOLATOR } from 'config/types';\nimport readExpressionOrReference from 'parse/converters/readExpressionOrReference';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readInterpolator ( parser, tag ) {\n\tvar start, expression, interpolator, err;\n\n\tstart = parser.pos;\n\n\t// TODO would be good for perf if we could do away with the try-catch\n\ttry {\n\t\texpression = readExpressionOrReference( parser, [ tag.close ]);\n\t} catch ( e ) {\n\t\terr = e;\n\t}\n\n\tif ( !expression ) {\n\t\tif ( parser.str.charAt( start ) === '!' ) {\n\t\t\t// special case - comment\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}' after reference` );\n\n\t\tif ( !expression ) {\n\t\t\t// special case - comment\n\t\t\tif ( parser.nextChar() === '!' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparser.error( `Expected expression or legal reference` );\n\t\t}\n\t}\n\n\tinterpolator = { t: INTERPOLATOR };\n\trefineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious\n\n\treturn interpolator;\n}","import { YIELDER } from 'config/types';\n\nvar yieldPattern = /^yield\\s*/;\n\nexport default function readYielder ( parser, tag ) {\n\tvar start, name, yielder;\n\n\tif ( !parser.matchPattern( yieldPattern ) ) {\n\t\treturn null;\n\t}\n\n\tstart = parser.pos;\n\tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `expected legal partial name` );\n\t}\n\n\tyielder = { t: YIELDER };\n\n\tif ( name ) {\n\t\tyielder.n = name;\n\t}\n\n\treturn yielder;\n}","import { CLOSING } from 'config/types';\n\nexport default function readClosing ( parser, tag ) {\n\tvar start, remaining, index, closing;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '/' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\tremaining = parser.remaining();\n\tindex = remaining.indexOf( tag.close );\n\n\tif ( index !== -1 ) {\n\t\tclosing = {\n\t\t\tt: CLOSING,\n\t\t\tr: remaining.substr( 0, index ).split( ' ' )[0]\n\t\t};\n\n\t\tparser.pos += index;\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t\t}\n\n\t\treturn closing;\n\t}\n\n\tparser.pos = start;\n\treturn null;\n}","import { INLINE_PARTIAL } from 'config/types';\nimport readClosing from './section/readClosing';\n\nvar partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n\nexport default function readPartialDefinitionSection ( parser, tag ) {\n\tvar start, name, content, child, closed;\n\n\tif ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {\n\t\treturn null;\n\t}\n\n\tstart = parser.pos;\n\n\tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\n\tif ( !name ) {\n\t\tparser.error( 'expected legal partial name' );\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\tcontent = [];\n\n\tdo {\n\t\tif ( child = readClosing( parser, tag ) ) {\n\t\t\tif ( !child.r === 'partial' ) {\n\t\t\t\tparser.error( `Expected ${tag.open}/partial${tag.close}` );\n\t\t\t}\n\n\t\t\tclosed = true;\n\t\t}\n\n\t\telse {\n\t\t\tchild = parser.read();\n\n\t\t\tif ( !child ) {\n\t\t\t\tparser.error( `Expected ${tag.open}/partial${tag.close}` );\n\t\t\t}\n\n\t\t\tcontent.push( child );\n\t\t}\n\t} while ( !closed );\n\n\treturn {\n\t\tt: INLINE_PARTIAL,\n\t\tn: name,\n\t\tf: content\n\t};\n}","import { ELSE } from 'config/types';\n\nvar elsePattern = /^\\s*else\\s*/;\n\nexport default function readElse ( parser, tag ) {\n\tvar start = parser.pos;\n\n\tif ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchPattern( elsePattern ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\treturn {\n\t\tt: ELSE\n\t};\n}","import { ELSEIF } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\n\nvar elsePattern = /^\\s*elseif\\s+/;\n\nexport default function readElse ( parser, tag ) {\n\tvar start = parser.pos, expression;\n\n\tif ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchPattern( elsePattern ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\texpression = readExpression( parser );\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\treturn {\n\t\tt: ELSEIF,\n\t\tx: expression\n\t};\n}","import { SECTION, SECTION_IF, SECTION_UNLESS, SECTION_WITH, SECTION_IF_WITH, PREFIX_OPERATOR, INFIX_OPERATOR, BRACKETED } from 'config/types';\nimport readClosing from './section/readClosing';\nimport readElse from './section/readElse';\nimport readElseIf from './section/readElseIf';\nimport handlebarsBlockCodes from './handlebarsBlockCodes';\nimport readExpression from 'parse/converters/readExpression';\nimport flattenExpression from 'parse/utils/flattenExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n\tkeyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n\thandlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' );\n\nexport default function readSection ( parser, tag ) {\n\tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n\tstart = parser.pos;\n\n\tif ( parser.matchString( '^' ) ) {\n\t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n\t} else if ( parser.matchString( '#' ) ) {\n\t\tsection = { t: SECTION, f: [] };\n\n\t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t\t\texpectedClose = block;\n\t\t\tsection.n = handlebarsBlockCodes[ block ];\n\t\t}\n\t} else {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\texpression = readExpression( parser );\n\n\tif ( !expression ) {\n\t\tparser.error( 'Expected expression' );\n\t}\n\n\t// optional index and key references\n\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t\tlet extra;\n\n\t\tif ( extra = parser.matchPattern( keyIndexRefPattern ) ) {\n\t\t\tsection.i = i + ',' + extra;\n\t\t} else {\n\t\t\tsection.i = i;\n\t\t}\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\tparser.sectionDepth += 1;\n\tchildren = section.f;\n\n\tconditions = [];\n\n\tdo {\n\t\tif ( child = readClosing( parser, tag ) ) {\n\t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t\t\t\tparser.error( `Expected ${tag.open}/${expectedClose}${tag.close}` );\n\t\t\t}\n\n\t\t\tparser.sectionDepth -= 1;\n\t\t\tclosed = true;\n\t\t}\n\n\t\telse if ( child = readElseIf( parser, tag ) ) {\n\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t}\n\n\t\t\tif ( hasElse ) {\n\t\t\t\tparser.error( 'illegal {{elseif...}} after {{else}}' );\n\t\t\t}\n\n\t\t\tif ( !unlessBlock ) {\n\t\t\t\tunlessBlock = createUnlessBlock( expression, section.n );\n\t\t\t}\n\n\t\t\tunlessBlock.f.push({\n\t\t\t\tt: SECTION,\n\t\t\t\tn: SECTION_IF,\n\t\t\t\tx: flattenExpression( combine( conditions.concat( child.x ) ) ),\n\t\t\t\tf: children = []\n\t\t\t});\n\n\t\t\tconditions.push( invert( child.x ) );\n\t\t}\n\n\t\telse if ( child = readElse( parser, tag ) ) {\n\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t}\n\n\t\t\tif ( hasElse ) {\n\t\t\t\tparser.error( 'there can only be one {{else}} block, at the end of a section' );\n\t\t\t}\n\n\t\t\thasElse = true;\n\n\t\t\t// use an unless block if there's no elseif\n\t\t\tif ( !unlessBlock ) {\n\t\t\t\tunlessBlock = createUnlessBlock( expression, section.n );\n\t\t\t\tchildren = unlessBlock.f;\n\t\t\t} else {\n\t\t\t\tunlessBlock.f.push({\n\t\t\t\t\tt: SECTION,\n\t\t\t\t\tn: SECTION_IF,\n\t\t\t\t\tx: flattenExpression( combine( conditions ) ),\n\t\t\t\t\tf: children = []\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tchild = parser.read();\n\n\t\t\tif ( !child ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchildren.push( child );\n\t\t}\n\t} while ( !closed );\n\n\tif ( unlessBlock ) {\n\t\t// special case - `with` should become `if-with` (TODO is this right?\n\t\t// seems to me that `with` ought to behave consistently, regardless\n\t\t// of the presence/absence of `else`. In other words should always\n\t\t// be `if-with`\n\t\tif ( section.n === SECTION_WITH ) {\n\t\t\tsection.n = SECTION_IF_WITH;\n\t\t}\n\n\t\tsection.l = unlessBlock;\n\t}\n\n\trefineExpression( expression, section );\n\n\t// TODO if a section is empty it should be discarded. Don't do\n\t// that here though - we need to clean everything up first, as\n\t// it may contain removeable whitespace. As a temporary measure,\n\t// to pass the existing tests, remove empty `f` arrays\n\tif ( !section.f.length ) {\n\t\tdelete section.f;\n\t}\n\n\treturn section;\n}\n\nfunction createUnlessBlock ( expression, sectionType ) {\n\tvar unlessBlock;\n\n\tif ( sectionType === SECTION_WITH ) {\n\t\t// special case - a `{{#with foo}}` section will render if `foo` is\n\t\t// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n\t\t// rather than adhering to the normal `{{#unless foo}}` logic (which\n\t\t// treats empty arrays/objects as falsy)\n\t\tunlessBlock = {\n\t\t\tt: SECTION,\n\t\t\tn: SECTION_IF,\n\t\t\tf: []\n\t\t};\n\n\t\trefineExpression( invert( expression ), unlessBlock );\n\t} else {\n\t\tunlessBlock = {\n\t\t\tt: SECTION,\n\t\t\tn: SECTION_UNLESS,\n\t\t\tf: []\n\t\t};\n\n\t\trefineExpression( expression, unlessBlock );\n\t}\n\n\treturn unlessBlock;\n}\n\nfunction invert ( expression ) {\n\tif ( expression.t === PREFIX_OPERATOR && expression.s === '!' ) {\n\t\treturn expression.o;\n\t}\n\n\treturn {\n\t\tt: PREFIX_OPERATOR,\n\t\ts: '!',\n\t\to: parensIfNecessary( expression )\n\t};\n}\n\nfunction combine ( expressions ) {\n\tif ( expressions.length === 1 ) {\n\t\treturn expressions[0];\n\t}\n\n\treturn {\n\t\tt: INFIX_OPERATOR,\n\t\ts: '&&',\n\t\to: [\n\t\t\tparensIfNecessary( expressions[0] ),\n\t\t\tparensIfNecessary( combine( expressions.slice( 1 ) ) )\n\t\t]\n\t};\n}\n\nfunction parensIfNecessary ( expression ) {\n\t// TODO only wrap if necessary\n\treturn {\n\t\tt: BRACKETED,\n\t\tx: expression\n\t};\n}","import { COMMENT } from 'config/types';\n\nvar OPEN_COMMENT = '<!--',\n\tCLOSE_COMMENT = '-->';\n\nexport default function readHtmlComment ( parser ) {\n\tvar start, content, remaining, endIndex, comment;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( OPEN_COMMENT ) ) {\n\t\treturn null;\n\t}\n\n\tremaining = parser.remaining();\n\tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\n\tif ( endIndex === -1 ) {\n\t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t}\n\n\tcontent = remaining.substr( 0, endIndex );\n\tparser.pos += endIndex + 3;\n\n\tcomment = {\n\t\tt: COMMENT,\n\t\tc: content\n\t};\n\n\tif ( parser.includeLinePositions ) {\n\t\tcomment.p = parser.getLinePos( start );\n\t}\n\n\treturn comment;\n}\n","import 'legacy';\n\nvar booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\nbooleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\nvoidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\nhtmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830\t};\ncontrolCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];\nentityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\nfunction decodeCharacterReferences ( html ) {\n\treturn html.replace( entityPattern, function ( match, entity ) {\n\t\tvar code;\n\n\t\t// Handle named entities\n\t\tif ( entity[0] !== '#' ) {\n\t\t\tcode = htmlEntities[ entity ];\n\t\t} else if ( entity[1] === 'x' ) {\n\t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t\t} else {\n\t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t\t}\n\n\t\tif ( !code ) {\n\t\t\treturn match;\n\t\t}\n\n\t\treturn String.fromCharCode( validateCode( code ) );\n\t});\n}\n\n// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n// to replace them ourselves\n//\n// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\nfunction validateCode ( code ) {\n\tif ( !code ) {\n\t\treturn 65533;\n\t}\n\n\t// line feed becomes generic whitespace\n\tif ( code === 10 ) {\n\t\treturn 32;\n\t}\n\n\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\tif ( code < 128 ) {\n\t\treturn code;\n\t}\n\n\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t// to correct the mistake or we'll end up with missing  signs and so on\n\tif ( code <= 159 ) {\n\t\treturn controlCharacters[ code - 128 ];\n\t}\n\n\t// basic multilingual plane\n\tif ( code < 55296 ) {\n\t\treturn code;\n\t}\n\n\t// UTF-16 surrogate halves\n\tif ( code <= 57343 ) {\n\t\treturn 65533;\n\t}\n\n\t// rest of the basic multilingual plane\n\tif ( code <= 65535 ) {\n\t\treturn code;\n\t}\n\n\treturn 65533;\n}\n\nlessThan = /</g;\ngreaterThan = />/g;\namp = /&/g;\n\nfunction escapeHtml ( str ) {\n\treturn str\n\t\t.replace( amp, '&amp;' )\n\t\t.replace( lessThan, '&lt;' )\n\t\t.replace( greaterThan, '&gt;' );\n}\n\nexport { booleanAttributes, decodeCharacterReferences, escapeHtml, voidElementNames };\n","import { CLOSING_TAG } from 'config/types';\n\nvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\nexport default function readClosingTag ( parser ) {\n\tvar start, tag;\n\n\tstart = parser.pos;\n\n\t// are we looking at a closing tag?\n\tif ( !parser.matchString( '</' ) ) {\n\t\treturn null;\n\t}\n\n\tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t\tif ( parser.inside && tag !== parser.inside ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: CLOSING_TAG,\n\t\t\te: tag\n\t\t};\n\t}\n\n\t// We have an illegal closing tag, report it\n\tparser.pos -= 2;\n\tparser.error( 'Illegal closing tag' );\n}\n","import getLowestIndex from '../utils/getLowestIndex';\nimport readMustache from '../readMustache';\nimport { decodeCharacterReferences } from 'utils/html';\n\nvar attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n\tunquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n\nexport default function readAttribute ( parser ) {\n\tvar attr, name, value;\n\n\tparser.allowWhitespace();\n\n\tname = parser.matchPattern( attributeNamePattern );\n\tif ( !name ) {\n\t\treturn null;\n\t}\n\n\tattr = {\n\t\tname: name\n\t};\n\n\tvalue = readAttributeValue( parser );\n\tif ( value ) {\n\t\tattr.value = value;\n\t}\n\n\treturn attr;\n}\n\nfunction readAttributeValue ( parser ) {\n\tvar start, valueStart, startDepth, value;\n\n\tstart = parser.pos;\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '=' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\tvalueStart = parser.pos;\n\tstartDepth = parser.sectionDepth;\n\n\tvalue = readQuotedAttributeValue( parser, \"'\" ) ||\n\t\t\treadQuotedAttributeValue( parser, '\"' ) ||\n\t\t\treadUnquotedAttributeValue( parser );\n\n\tif ( parser.sectionDepth !== startDepth ) {\n\t\tparser.pos = valueStart;\n\t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t}\n\n\tif ( value === null ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tif ( !value.length ) {\n\t\treturn null;\n\t}\n\n\tif ( value.length === 1 && typeof value[0] === 'string' ) {\n\t\treturn decodeCharacterReferences( value[0] );\n\t}\n\n\treturn value;\n}\n\nfunction readUnquotedAttributeValueToken ( parser ) {\n\tvar start, text, haystack, needles, index;\n\n\tstart = parser.pos;\n\n\ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\n\tif ( !text ) {\n\t\treturn null;\n\t}\n\n\thaystack = text;\n\tneedles = parser.tags.map( t => t.open ); // TODO refactor... we do this in readText.js as well\n\n\tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t\ttext = text.substr( 0, index );\n\t\tparser.pos = start + text.length;\n\t}\n\n\treturn text;\n}\n\nfunction readUnquotedAttributeValue ( parser ) {\n\tvar tokens, token;\n\n\tparser.inAttribute = true;\n\n\ttokens = [];\n\n\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\twhile ( token !== null ) {\n\t\ttokens.push( token );\n\t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t}\n\n\tif ( !tokens.length ) {\n\t\treturn null;\n\t}\n\n\tparser.inAttribute = false;\n\treturn tokens;\n}\n\nfunction readQuotedAttributeValue ( parser, quoteMark ) {\n\tvar start, tokens, token;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( quoteMark ) ) {\n\t\treturn null;\n\t}\n\n\tparser.inAttribute = quoteMark;\n\n\ttokens = [];\n\n\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\twhile ( token !== null ) {\n\t\ttokens.push( token );\n\t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t}\n\n\tif ( !parser.matchString( quoteMark ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tparser.inAttribute = false;\n\n\treturn tokens;\n}\n\nfunction readQuotedStringToken ( parser, quoteMark ) {\n\tvar start, index, haystack, needles;\n\n\tstart = parser.pos;\n\thaystack = parser.remaining();\n\n\tneedles = parser.tags.map( t => t.open ); // TODO refactor... we do this in readText.js as well\n\tneedles.push( quoteMark );\n\n\tindex = getLowestIndex( haystack, needles );\n\n\tif ( index === -1 ) {\n\t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t}\n\n\tif ( !index ) {\n\t\treturn null;\n\t}\n\n\tparser.pos += index;\n\treturn haystack.substr( 0, index );\n}\n","import Parser from 'parse/Parser';\nimport readStringLiteral from 'parse/converters/expressions/primary/literal/readStringLiteral';\nimport readKey from 'parse/converters/expressions/shared/readKey';\n\n// simple JSON parser, without the restrictions of JSON parse\n// (i.e. having to double-quote keys).\n//\n// If passed a hash of values as the second argument, ${placeholders}\n// will be replaced with those values\n\nvar JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\nspecials = {\n\t'true': true,\n\t'false': false,\n\t'undefined': undefined,\n\t'null': null\n};\n\nspecialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );\nnumberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\nplaceholderPattern = /\\$\\{([^\\}]+)\\}/g;\nplaceholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\nonlyWhitespace = /^\\s*$/;\n\nJsonParser = Parser.extend({\n\tinit: function ( str, options ) {\n\t\tthis.values = options.values;\n\t\tthis.allowWhitespace();\n\t},\n\n\tpostProcess: function ( result ) {\n\t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn { value: result[0].v };\n\t},\n\n\tconverters: [\n\t\tfunction getPlaceholder ( parser ) {\n\t\t\tvar placeholder;\n\n\t\t\tif ( !parser.values ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tplaceholder = parser.matchPattern( placeholderAtStartPattern );\n\n\t\t\tif ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {\n\t\t\t\treturn { v: parser.values[ placeholder ] };\n\t\t\t}\n\t\t},\n\n\t\tfunction getSpecial ( parser ) {\n\t\t\tvar special;\n\n\t\t\tif ( special = parser.matchPattern( specialsPattern ) ) {\n\t\t\t\treturn { v: specials[ special ] };\n\t\t\t}\n\t\t},\n\n\t\tfunction getNumber ( parser ) {\n\t\t\tvar number;\n\n\t\t\tif ( number = parser.matchPattern( numberPattern ) ) {\n\t\t\t\treturn { v: +number };\n\t\t\t}\n\t\t},\n\n\t\tfunction getString ( parser ) {\n\t\t\tvar stringLiteral = readStringLiteral( parser ), values;\n\n\t\t\tif ( stringLiteral && ( values = parser.values ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) {\n\t\t\t\t\t\treturn ( $1 in values ? values[ $1 ] : $1 );\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn stringLiteral;\n\t\t},\n\n\t\tfunction getObject ( parser ) {\n\t\t\tvar result, pair;\n\n\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tresult = {};\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\treturn { v: result };\n\t\t\t}\n\n\t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t\t\t\tresult[ pair.key ] = pair.value;\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\treturn { v: result };\n\t\t\t\t}\n\n\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tfunction getArray ( parser ) {\n\t\t\tvar result, valueToken;\n\n\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tresult = [];\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\treturn { v: result };\n\t\t\t}\n\n\t\t\twhile ( valueToken = parser.read() ) {\n\t\t\t\tresult.push( valueToken.v );\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\treturn { v: result };\n\t\t\t\t}\n\n\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tparser.allowWhitespace();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t]\n});\n\nfunction getKeyValuePair ( parser ) {\n\tvar key, valueToken, pair;\n\n\tparser.allowWhitespace();\n\n\tkey = readKey( parser );\n\n\tif ( !key ) {\n\t\treturn null;\n\t}\n\n\tpair = { key: key };\n\n\tparser.allowWhitespace();\n\tif ( !parser.matchString( ':' ) ) {\n\t\treturn null;\n\t}\n\tparser.allowWhitespace();\n\n\tvalueToken = parser.read();\n\tif ( !valueToken ) {\n\t\treturn null;\n\t}\n\n\tpair.value = valueToken.v;\n\n\treturn pair;\n}\n\nexport default function ( str, values ) {\n\tvar parser = new JsonParser( str, {\n\t\tvalues: values\n\t});\n\n\treturn parser.result;\n}\n","import Parser from 'parse/Parser';\nimport readExpression from 'parse/converters/readExpression';\nimport flattenExpression from 'parse/utils/flattenExpression';\nimport parseJSON from 'utils/parseJSON';\n\nvar methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n\tExpressionParser;\n\nExpressionParser = Parser.extend({\n\tconverters: [ readExpression ]\n});\n\n// TODO clean this up, it's shocking\nexport default function processDirective ( tokens ) {\n\tvar result,\n\t\tmatch,\n\t\tparser,\n\t\targs,\n\t\ttoken,\n\t\tcolonIndex,\n\t\tdirectiveName,\n\t\tdirectiveArgs,\n\t\tparsed;\n\n\tif ( typeof tokens === 'string' ) {\n\t\tif ( match = methodCallPattern.exec( tokens ) ) {\n\t\t\tresult = { m: match[1] };\n\t\t\targs = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';\n\n\t\t\tparser = new ExpressionParser( args );\n\t\t\tresult.a = flattenExpression( parser.result[0] );\n\n\t\t\treturn result;\n\t\t}\n\n\t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t\t\treturn tokens.trim();\n\t\t}\n\n\t\ttokens = [ tokens ];\n\t}\n\n\tresult = {};\n\n\tdirectiveName = [];\n\tdirectiveArgs = [];\n\n\tif ( tokens) {\n\t\twhile ( tokens.length ) {\n\t\t\ttoken = tokens.shift();\n\n\t\t\tif ( typeof token === 'string' ) {\n\t\t\t\tcolonIndex = token.indexOf( ':' );\n\n\t\t\t\tif ( colonIndex === -1 ) {\n\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t} else {\n\n\t\t\t\t\t// is the colon the first character?\n\t\t\t\t\tif ( colonIndex ) {\n\t\t\t\t\t\t// no\n\t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// if there is anything after the colon in this token, treat\n\t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t\t\t\t\t\tdirectiveArgs[0] = token.substring( colonIndex + 1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tdirectiveName.push( token );\n\t\t\t}\n\t\t}\n\n\t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t}\n\n\tif ( !directiveName.length ) {\n\t\tresult = '';\n\t}\n\telse if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t\tresult = {\n\t\t\t// TODO is this really necessary? just use the array\n\t\t\tn: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )\n\t\t};\n\n\t\tif ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {\n\t\t\tparsed = parseJSON( '[' + directiveArgs[0] + ']' );\n\t\t\tresult.a = parsed ? parsed.value : directiveArgs[0].trim();\n\t\t}\n\n\t\telse {\n\t\t\tresult.d = directiveArgs;\n\t\t}\n\t} else {\n\t\tresult = directiveName;\n\t}\n\n\treturn result;\n}\n","import { DOCTYPE, ELEMENT } from 'config/types';\nimport { voidElementNames } from 'utils/html';\nimport readMustache from './readMustache';\nimport readClosing from './mustache/section/readClosing';\nimport readClosingTag from './element/readClosingTag';\nimport readAttribute from './element/readAttribute';\nimport processDirective from './element/processDirective';\n\nvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n\tvalidTagNameFollower = /^[\\s\\n\\/>]/,\n\tonPattern = /^on/,\n\tproxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n\treservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n\tdirectives = { 'intro-outro': 't0', intro: 't1', outro: 't2', decorator: 'o' },\n\texclude = { exclude: true },\n\tdisallowedContents;\n\n// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\ndisallowedContents = {\n\tli: [ 'li' ],\n\tdt: [ 'dt', 'dd' ],\n\tdd: [ 'dt', 'dd' ],\n\tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\trt: [ 'rt', 'rp' ],\n\trp: [ 'rt', 'rp' ],\n\toptgroup: [ 'optgroup' ],\n\toption: [ 'option', 'optgroup' ],\n\tthead: [ 'tbody', 'tfoot' ],\n\ttbody: [ 'tbody', 'tfoot' ],\n\ttfoot: [ 'tbody' ],\n\ttr: [ 'tr', 'tbody' ],\n\ttd: [ 'td', 'th', 'tr' ],\n\tth: [ 'td', 'th', 'tr' ]\n};\n\nexport default readElement;\n\nfunction readElement ( parser ) {\n\tvar start,\n\t\telement,\n\t\tlowerCaseName,\n\t\tdirectiveName,\n\t\tmatch,\n\t\taddProxyEvent,\n\t\tattribute,\n\t\tdirective,\n\t\tselfClosing,\n\t\tchildren,\n\t\tchild,\n\t\tclosed,\n\t\tpos;\n\n\tstart = parser.pos;\n\n\tif ( parser.inside || parser.inAttribute ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( '<' ) ) {\n\t\treturn null;\n\t}\n\n\t// if this is a closing tag, abort straight away\n\tif ( parser.nextChar() === '/' ) {\n\t\treturn null;\n\t}\n\n\telement = {};\n\tif ( parser.includeLinePositions ) {\n\t\telement.p = parser.getLinePos( start );\n\t}\n\n\tif ( parser.matchString( '!' ) ) {\n\t\telement.t = DOCTYPE;\n\t\tif ( !parser.matchPattern( /^doctype/i ) ) {\n\t\t\tparser.error( 'Expected DOCTYPE declaration' );\n\t\t}\n\n\t\telement.a = parser.matchPattern( /^(.+?)>/ );\n\t\treturn element;\n\t}\n\n\telement.t = ELEMENT;\n\n\t// element name\n\telement.e = parser.matchPattern( tagNamePattern );\n\tif ( !element.e ) {\n\t\treturn null;\n\t}\n\n\t// next character must be whitespace, closing solidus or '>'\n\tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t\tparser.error( 'Illegal tag name' );\n\t}\n\n\taddProxyEvent = function ( name, directive ) {\n\t\tvar directiveName = directive.n || directive;\n\n\t\tif ( reservedEventNames.test( directiveName ) ) {\n\t\t\tparser.pos -= directiveName.length;\n\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t\t}\n\n\t\telement.v[ name ] = directive;\n\t};\n\n\tparser.allowWhitespace();\n\n\t// directives and attributes\n\twhile ( attribute = readMustache( parser ) || readAttribute( parser ) ) {\n\t\t// regular attributes\n\t\tif ( attribute.name ) {\n\t\t\t// intro, outro, decorator\n\t\t\tif ( directiveName = directives[ attribute.name ] ) {\n\t\t\t\telement[ directiveName ] = processDirective( attribute.value );\n\t\t\t}\n\n\t\t\t// on-click etc\n\t\t\telse if ( match = proxyEventPattern.exec( attribute.name ) ) {\n\t\t\t\tif ( !element.v ) element.v = {};\n\t\t\t\tdirective = processDirective( attribute.value );\n\t\t\t\taddProxyEvent( match[1], directive );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {\n\t\t\t\t\tif ( !element.a ) element.a = {};\n\t\t\t\t\telement.a[ attribute.name ] = attribute.value || 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// {{#if foo}}class='foo'{{/if}}\n\t\telse {\n\t\t\tif ( !element.m ) element.m = [];\n\t\t\telement.m.push( attribute );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\t}\n\n\t// allow whitespace before closing solidus\n\tparser.allowWhitespace();\n\n\t// self-closing solidus?\n\tif ( parser.matchString( '/' ) ) {\n\t\tselfClosing = true;\n\t}\n\n\t// closing angle bracket\n\tif ( !parser.matchString( '>' ) ) {\n\t\treturn null;\n\t}\n\n\tlowerCaseName = element.e.toLowerCase();\n\n\tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t\t// Special case - if we open a script element, further tags should\n\t\t// be ignored unless they're a closing script element\n\t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {\n\t\t\tparser.inside = lowerCaseName;\n\t\t}\n\n\t\tchildren = [];\n\n\t\tdo {\n\t\t\tpos = parser.pos;\n\n\t\t\tif ( !canContain( lowerCaseName, parser.remaining() ) ) {\n\t\t\t\tclosed = true;\n\t\t\t}\n\n\t\t\telse if ( child = readClosingTag( parser ) ) {\n\t\t\t\t// TODO verify that this tag can close this element (is either the same, or\n\t\t\t\t// a parent that can close child elements implicitly)\n\n\t\t\t\t//parser.error( 'Expected closing </' + element.e + '> tag' );\n\t\t\t\tclosed = true;\n\t\t\t}\n\n\t\t\t// implicit close by closing section tag. TODO clean this up\n\t\t\telse if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {\n\t\t\t\tclosed = true;\n\t\t\t\tparser.pos = pos;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tchild = parser.read();\n\n\t\t\t\tif ( !child ) {\n\t\t\t\t\tclosed = true;\n\t\t\t\t} else {\n\t\t\t\t\tchildren.push( child );\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( !closed );\n\n\t\tif ( children.length ) {\n\t\t\telement.f = children;\n\t\t}\n\t}\n\n\tparser.inside = null;\n\n\tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t\treturn exclude;\n\t}\n\n\treturn element;\n}\n\nfunction canContain ( name, remaining ) {\n\tvar match, disallowed;\n\n\tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\tdisallowed = disallowedContents[ name ];\n\n\tif ( !match || !disallowed ) {\n\t\treturn true;\n\t}\n\n\treturn !~disallowed.indexOf( match[1].toLowerCase() );\n}\n","var pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nexport default function escapeRegExp ( str ) {\n\treturn str.replace( pattern, '\\\\$&' );\n}\n","import { INLINE_PARTIAL } from 'config/types';\nimport escapeRegExp from 'utils/escapeRegExp';\n\nexport default readPartialDefinitionComment;\n\nvar startPattern = /^<!--\\s*/,\n    namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n    finishPattern = /\\s*-->/,\n    closed,\n    child;\n\nfunction readPartialDefinitionComment ( parser ) {\n\tlet firstPos = parser.pos,\n\t    open = parser.standardDelimiters[0],\n\t    close = parser.standardDelimiters[1],\n\t    content;\n\n\tif ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {\n\t\tparser.pos = firstPos;\n\t\treturn null;\n\t}\n\n\tlet name = parser.matchPattern( namePattern );\n\n\t// make sure the rest of the comment is in the correct place\n\tif ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {\n\t\tparser.pos = firstPos;\n\t\treturn null;\n\t}\n\n\tcontent = [];\n\n\tlet endPattern = new RegExp('^<!--\\\\s*' + escapeRegExp( open ) + '\\\\s*\\\\/\\\\s*' + name + '\\\\s*' + escapeRegExp( close ) + '\\\\s*-->');\n\n\tdo {\n\t\tif ( parser.matchPattern( endPattern ) ) {\n\t\t\tclosed = true;\n\t\t}\n\n\t\telse {\n\t\t\tchild = parser.read();\n\t\t\tif ( !child ) {\n\t\t\t\tparser.error( `expected closing comment ('<!-- ${open}/${name}${close} -->')` );\n\t\t\t}\n\n\t\t\tcontent.push( child );\n\t\t}\n\t} while ( !closed );\n\n\treturn {\n\t\tt: INLINE_PARTIAL,\n\t\tf: content,\n\t\tn: name\n\t};\n}\n","import getLowestIndex from './utils/getLowestIndex';\nimport { decodeCharacterReferences } from 'utils/html';\n\nexport default function readText ( parser ) {\n\tvar index, remaining, disallowed, barrier;\n\n\tremaining = parser.remaining();\n\n\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\n\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t\tindex = remaining.indexOf( barrier );\n\t} else {\n\t\tdisallowed = parser.tags.map( t => t.open );\n\n\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t\tif ( parser.inAttribute === true ) {\n\t\t\t// we're inside an unquoted attribute value\n\t\t\tdisallowed.push( '\"', \"'\", '=', '<', '>', '`' );\n\t\t} else if ( parser.inAttribute ) {\n\t\t\t// quoted attribute value\n\t\t\tdisallowed.push( parser.inAttribute );\n\t\t} else {\n\t\t\tdisallowed.push( barrier );\n\t\t}\n\n\t\tindex = getLowestIndex( remaining, disallowed );\n\t}\n\n\tif ( !index ) {\n\t\treturn null;\n\t}\n\n\tif ( index === -1 ) {\n\t\tindex = remaining.length;\n\t}\n\n\tparser.pos += index;\n\n\treturn parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );\n}\n","import { COMMENT, DELIMCHANGE, SECTION, INVERTED } from 'config/types';\nimport { lastItem } from 'utils/array';\n\nvar leadingLinebreak = /^\\s*\\r?\\n/,\n\ttrailingLinebreak = /\\r?\\n\\s*$/;\n\nexport default function ( items ) {\n\tvar i, current, backOne, backTwo, lastSectionItem;\n\n\tfor ( i=1; i<items.length; i+=1 ) {\n\t\tcurrent = items[i];\n\t\tbackOne = items[i-1];\n\t\tbackTwo = items[i-2];\n\n\t\t// if we're at the end of a [text][comment][text] sequence...\n\t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\n\t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\n\t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t\t\t\titems[i-2] = backTwo.replace( trailingLinebreak, '\\n' );\n\n\t\t\t\t// and the leading line break of the second text token\n\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t}\n\t\t}\n\n\t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t\t// its first item is a linebreak...\n\t\tif ( isSection( current ) && isString( backOne ) ) {\n\t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {\n\t\t\t\titems[i-1] = backOne.replace( trailingLinebreak, '\\n' );\n\t\t\t\tcurrent.f[0] = current.f[0].replace( leadingLinebreak, '' );\n\t\t\t}\n\t\t}\n\n\t\t// if the last item was a section, and it is followed by a linebreak, and\n\t\t// its last item is a linebreak...\n\t\tif ( isString( current ) && isSection( backOne ) ) {\n\t\t\tlastSectionItem = lastItem( backOne.f );\n\n\t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn items;\n}\n\nfunction isString ( item ) {\n\treturn typeof item === 'string';\n}\n\nfunction isComment ( item ) {\n\treturn item.t === COMMENT || item.t === DELIMCHANGE;\n}\n\nfunction isSection ( item ) {\n\treturn ( item.t === SECTION || item.t === INVERTED ) && item.f;\n}\n","import { INLINE_PARTIAL } from 'config/types';\nimport { isArray } from 'utils/is';\n\nexport default process;\n\nfunction process( path, target, items ) {\n\tlet i = items.length, item, cmp;\n\n\twhile ( i-- ) {\n\t\titem = items[i];\n\n\t\tif ( isPartial( item ) ) {\n\t\t\ttarget[ item.n ] = item.f;\n\t\t\titems.splice( i, 1 );\n\t\t} else if ( isArray( item.f ) ) {\n\t\t\tif ( cmp = getComponent( path, item ) ) {\n\t\t\t\tpath.push( cmp );\n\t\t\t\tprocess( path, item.p = {}, item.f );\n\t\t\t\tpath.pop();\n\t\t\t} else if ( isArray( item.f ) ) {\n\t\t\t\tprocess( path, target, item.f );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction isPartial( item ) {\n\treturn item.t === INLINE_PARTIAL;\n}\n\nfunction getComponent( path, item ) {\n\tvar i, cmp, name = item.e;\n\n\tif ( item.e ) {\n\t\tfor ( i = 0; i < path.length; i++ ) {\n\t\t\tif ( cmp = ( path[i].components || {} )[name] ) {\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { TEMPLATE_VERSION } from 'config/template';\nimport { COMMENT, ELEMENT } from 'config/types';\nimport Parser from './Parser';\nimport readMustache from './converters/readMustache';\nimport readTriple from './converters/mustache/readTriple';\nimport readUnescaped from './converters/mustache/readUnescaped';\nimport readPartial from './converters/mustache/readPartial';\nimport readMustacheComment from './converters/mustache/readMustacheComment';\nimport readInterpolator from './converters/mustache/readInterpolator';\nimport readYielder from './converters/mustache/readYielder';\nimport readPartialDefinitionSection from './converters/mustache/readPartialDefinitionSection';\nimport readSection from './converters/mustache/readSection';\nimport readHtmlComment from './converters/readHtmlComment';\nimport readElement from './converters/readElement';\nimport readPartialDefinitionComment from './converters/readPartialDefinitionComment';\nimport readText from './converters/readText';\nimport trimWhitespace from './utils/trimWhitespace';\nimport stripStandalones from './utils/stripStandalones';\nimport processPartials from './converters/partial/processPartials';\nimport { isEmptyObject, isArray } from 'utils/is';\n\n// Ractive.parse\n// ===============\n//\n// Takes in a string, and returns an object representing the parsed template.\n// A parsed template is an array of 1 or more 'templates', which in some\n// cases have children.\n//\n// The format is optimised for size, not readability, however for reference the\n// keys for each template are as follows:\n//\n// * r - Reference, e.g. 'mustache' in {{mustache}}\n// * t - Type code (e.g. 1 is text, 2 is interpolator...)\n// * f - Fragment. Contains a template's children\n// * l - eLse fragment. Contains a template's children in the else case\n// * e - Element name\n// * a - map of element Attributes, or proxy event/transition Arguments\n// * m - Mustache attributes (as in <div {{#if selected}}class=\"selected\"{{/if}}>...</div>)\n// * d - Dynamic proxy event/transition arguments\n// * n - indicates section type\n// * i - Index reference, e.g. 'num' in {{#section:num}}content{{/section}}\n// * v - eVent proxies (i.e. when user e.g. clicks on a node, fire proxy event)\n// * x - eXpressions\n// * s - String representation of an expression function\n// * t0 - intro/outro Transition\n// * t1 - intro Transition\n// * t2 - outro Transition\n// * o - decOrator\n// * c - is Content (e.g. of a comment node)\n// * p - line Position information - array with line number and character position of each node\n\n\nvar StandardParser,\n\tparse,\n\tcontiguousWhitespace = /[ \\t\\f\\r\\n]+/g,\n\tpreserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,\n\tleadingWhitespace = /^\\s+/,\n\ttrailingWhitespace = /\\s+$/,\n\n\tSTANDARD_READERS = [ readPartial, readUnescaped, readPartialDefinitionSection, readSection, readYielder, readInterpolator, readMustacheComment ],\n\tTRIPLE_READERS = [ readTriple ],\n\tSTATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?\n\nStandardParser = Parser.extend({\n\tinit ( str, options ) {\n\t\tvar tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],\n\t\t\tstaticDelimiters = options.staticDelimiters || [ '[[', ']]' ],\n\t\t\tstaticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];\n\n\t\tthis.standardDelimiters = options.delimiters || [ '{{', '}}' ];\n\n\t\tthis.tags = [\n\t\t\t{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },\n\t\t\t{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },\n\t\t\t{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },\n\t\t\t{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }\n\t\t];\n\n\t\tthis.sortMustacheTags();\n\n\t\tthis.sectionDepth = 0;\n\n\t\tthis.interpolate = {\n\t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n\t\t};\n\n\t\tif ( options.sanitize === true ) {\n\t\t\toptions.sanitize = {\n\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t\t\t\teventAttributes: true\n\t\t\t};\n\t\t}\n\n\t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t\tthis.includeLinePositions = options.includeLinePositions;\n\t},\n\n\tpostProcess ( items, options ) {\n\t\tif ( this.sectionDepth > 0 ) {\n\t\t\tthis.error( 'A section was left open' );\n\t\t}\n\n\t\tcleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace );\n\n\t\treturn items;\n\t},\n\n\tconverters: [\n\t\treadMustache,\n\t\treadPartialDefinitionComment,\n\t\treadHtmlComment,\n\t\treadElement,\n\t\treadText\n\t],\n\n\tsortMustacheTags () {\n\t\t// Sort in order of descending opening delimiter length (longer first),\n\t\t// to protect against opening delimiters being substrings of each other\n\t\tthis.tags.sort( ( a, b ) => {\n\t\t\treturn b.open.length - a.open.length;\n\t\t});\n\t}\n});\n\nparse = function ( template, options = {} ) {\n\tvar result;\n\n\tresult = {\n\t\tv: TEMPLATE_VERSION, // template spec version, defined in https://github.com/ractivejs/template-spec\n\t\tt: new StandardParser( template, options ).result\n\t};\n\n\t// collect all of the partials and stick them on the appropriate instances\n\tlet partials = {};\n\t// without a ractive instance, no components will be found\n\tprocessPartials( options.ractive ? [options.ractive] : [], partials, result.t );\n\n\tif ( !isEmptyObject( partials ) ) {\n\t\tresult.p = partials;\n\t}\n\n\treturn result;\n};\n\nexport default parse;\n\nfunction cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {\n\tvar i,\n\t\titem,\n\t\tpreviousItem,\n\t\tnextItem,\n\t\tpreserveWhitespaceInsideFragment,\n\t\tremoveLeadingWhitespaceInsideFragment,\n\t\tremoveTrailingWhitespaceInsideFragment,\n\t\tkey;\n\n\t// First pass - remove standalones and comments etc\n\tstripStandalones( items );\n\n\ti = items.length;\n\twhile ( i-- ) {\n\t\titem = items[i];\n\n\t\t// Remove delimiter changes, unsafe elements etc\n\t\tif ( item.exclude ) {\n\t\t\titems.splice( i, 1 );\n\t\t}\n\n\t\t// Remove comments, unless we want to keep them\n\t\telse if ( stripComments && item.t === COMMENT ) {\n\t\t\titems.splice( i, 1 );\n\t\t}\n\t}\n\n\t// If necessary, remove leading and trailing whitespace\n\ttrimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );\n\n\ti = items.length;\n\twhile ( i-- ) {\n\t\titem = items[i];\n\n\t\t// Recurse\n\t\tif ( item.f ) {\n\t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || ( item.t === ELEMENT && preserveWhitespaceElements.test( item.e ) );\n\n\t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t\t\t\tpreviousItem = items[ i - 1 ];\n\t\t\t\tnextItem = items[ i + 1 ];\n\n\t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t\t\t\t// remove leading whitespace inside the fragment\n\t\t\t\tif ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {\n\t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t\t\t\t}\n\n\t\t\t\t// and vice versa\n\t\t\t\tif ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) ) {\n\t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t}\n\n\t\t// Split if-else blocks into two (an if, and an unless)\n\t\tif ( item.l ) {\n\t\t\tcleanup( item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\n\t\t\titems.splice( i + 1, 0, item.l );\n\t\t\tdelete item.l; // TODO would be nice if there was a way around this\n\t\t}\n\n\t\t// Clean up element attributes\n\t\tif ( item.a ) {\n\t\t\tfor ( key in item.a ) {\n\t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up conditional attributes\n\t\tif ( item.m ) {\n\t\t\tcleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t}\n\n\t\t// Clean up event handlers\n\t\tif ( item.v ) {\n\t\t\tfor ( key in item.v ) {\n\t\t\t\tif ( item.v.hasOwnProperty( key ) ) {\n\t\t\t\t\t// clean up names\n\t\t\t\t\tif ( isArray( item.v[ key ].n ) ) {\n\t\t\t\t\t\tcleanup( item.v[ key ].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t\t}\n\n\t\t\t\t\t// clean up params\n\t\t\t\t\tif ( isArray( item.v[ key ].d ) ) {\n\t\t\t\t\t\tcleanup( item.v[ key ].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// final pass - fuse text nodes together\n\ti = items.length;\n\twhile ( i-- ) {\n\t\tif ( typeof items[i] === 'string' ) {\n\t\t\tif ( typeof items[i+1] === 'string' ) {\n\t\t\t\titems[i] = items[i] + items[i+1];\n\t\t\t\titems.splice( i + 1, 1 );\n\t\t\t}\n\n\t\t\tif ( !preserveWhitespace ) {\n\t\t\t\titems[i] = items[i].replace( contiguousWhitespace, ' ' );\n\t\t\t}\n\n\t\t\tif ( items[i] === '' ) {\n\t\t\t\titems.splice( i, 1 );\n\t\t\t}\n\t\t}\n\t}\n}\n","import { isClient } from 'config/environment';\nimport parse from 'parse/_parse';\nimport { create } from 'utils/object';\n\nvar parseOptions = [\n \t'preserveWhitespace',\n\t'sanitize',\n\t'stripComments',\n\t'delimiters',\n\t'tripleDelimiters',\n\t'interpolate'\n];\n\nvar parser = {\n\tparse: doParse,\n\tfromId: fromId,\n\tisHashedId: isHashedId,\n\tisParsed: isParsed,\n\tgetParseOptions: getParseOptions,\n\tcreateHelper: createHelper\n};\n\nfunction createHelper ( parseOptions ) {\n\tvar helper = create( parser );\n\thelper.parse = function ( template, options ){\n\t\treturn doParse( template, options || parseOptions );\n\t};\n\treturn helper;\n}\n\nfunction doParse ( template, parseOptions ) {\n\tif ( !parse ) {\n\t\tthrow new Error( 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser' );\n\t}\n\n\treturn parse( template, parseOptions || this.options );\n}\n\nfunction fromId ( id, options ) {\n\tvar template;\n\n\tif ( !isClient ) {\n\t\tif ( options && options.noThrow ) { return; }\n\t\tthrow new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );\n\t}\n\n\tif ( isHashedId( id ) ) {\n\t\tid = id.substring( 1 );\n\t}\n\n\tif ( !( template = document.getElementById( id ) )) {\n\t\tif ( options && options.noThrow ) { return; }\n\t\tthrow new Error( 'Could not find template element with id #' + id );\n\t}\n\n\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t\tif ( options && options.noThrow ) { return; }\n\t\tthrow new Error( 'Template element with id #' + id + ', must be a <script> element' );\n\t}\n\n\treturn template.innerHTML;\n}\n\nfunction isHashedId ( id ) {\n\treturn ( id && id.charAt( 0 ) === '#' ); // TODO what about `id[0]`, does that work everywhere?\n}\n\nfunction isParsed ( template) {\n\treturn !( typeof template === 'string' );\n}\n\nfunction getParseOptions ( ractive ) {\n\t// Could be Ractive or a Component\n\tif ( ractive.defaults ) { ractive = ractive.defaults; }\n\n\treturn parseOptions.reduce( ( val, key ) => {\n\t\tval[ key ] = ractive[ key ];\n\t\treturn val;\n\t}, { ractive: ractive } );\n}\n\nexport default parser;\n","import { TEMPLATE_VERSION } from 'config/template';\nimport { create } from 'utils/object';\nimport parser from './parser';\nimport parse from 'parse/_parse';\n\nvar templateConfigurator = {\n\tname: 'template',\n\n\textend: function extend ( Parent, proto, options ) {\n\t\tvar template;\n\n\t\t// only assign if exists\n\t\tif ( 'template' in options ) {\n\t\t\ttemplate = options.template;\n\n\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\tproto.template = template;\n\t\t\t} else {\n\t\t\t\tproto.template = parseIfString( template, proto );\n\t\t\t}\n\t\t}\n\t},\n\n\tinit: function init ( Parent, ractive, options ) {\n\t\tvar template, fn;\n\n\t\t// TODO because of prototypal inheritance, we might just be able to use\n\t\t// ractive.template, and not bother passing through the Parent object.\n\t\t// At present that breaks the test mocks' expectations\n\t\ttemplate = 'template' in options ? options.template : Parent.prototype.template;\n\n\t\tif ( typeof template === 'function' ) {\n\t\t\tfn = template;\n\t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\n\t\t\tractive._config.template = {\n\t\t\t\tfn: fn,\n\t\t\t\tresult: template\n\t\t\t};\n\t\t}\n\n\t\ttemplate = parseIfString( template, ractive );\n\n\t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t\t// it's unnecessary, because the developer never needs to access\n\t\t// ractive.template\n\t\tractive.template = template.t;\n\n\t\tif ( template.p ) {\n\t\t\textendPartials( ractive.partials, template.p );\n\t\t}\n\t},\n\n\treset: function ( ractive ) {\n\t\tvar result = resetValue( ractive ), parsed;\n\n\t\tif ( result ) {\n\t\t\tparsed = parseIfString( result, ractive );\n\n\t\t\tractive.template = parsed.t;\n\t\t\textendPartials( ractive.partials, parsed.p, true );\n\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\nfunction resetValue ( ractive ) {\n\tvar initial = ractive._config.template, result;\n\n\t// If this isn't a dynamic template, there's nothing to do\n\tif ( !initial || !initial.fn ) {\n\t\treturn;\n\t}\n\n\tresult = getDynamicTemplate( ractive, initial.fn );\n\n\t// TODO deep equality check to prevent unnecessary re-rendering\n\t// in the case of already-parsed templates\n\tif ( result !== initial.result ) {\n\t\tinitial.result = result;\n\t\tresult = parseIfString( result, ractive );\n\t\treturn result;\n\t}\n}\n\nfunction getDynamicTemplate ( ractive, fn ) {\n\tvar helper = createHelper( parser.getParseOptions( ractive ) );\n\treturn fn.call( ractive, ractive.data, helper );\n}\n\nfunction createHelper ( parseOptions ) {\n\tvar helper = create( parser );\n\thelper.parse = function ( template, options ){\n\t\treturn parser.parse( template, options || parseOptions );\n\t};\n\treturn helper;\n}\n\nfunction parseIfString ( template, ractive ) {\n\tif ( typeof template === 'string' ) {\n\t\t// ID of an element containing the template?\n\t\tif ( template[0] === '#' ) {\n\t\t\ttemplate = parser.fromId( template );\n\t\t}\n\n\t\ttemplate = parse( template, parser.getParseOptions( ractive ) );\n\t}\n\n\t// Check we're using the correct version\n\telse if ( template.v !== TEMPLATE_VERSION ) {\n\t\tthrow new Error( `Mismatched template version (expected ${TEMPLATE_VERSION}, got ${template.v}) Please ensure you are using the latest version of Ractive.js in your build process as well as in your app` );\n\t}\n\n\treturn template;\n}\n\nfunction extendPartials ( existingPartials, newPartials, overwrite ) {\n\tif ( !newPartials ) return;\n\n\t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t// case, but not initially...\n\n\tfor ( let key in newPartials ) {\n\t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t\t\texistingPartials[ key ] = newPartials[ key ];\n\t\t}\n\t}\n}\n\nexport default templateConfigurator;\n","import noop from 'utils/noop';\n\nexport default function wrap ( parent, name, method ) {\n\tif ( !/_super/.test( method ) ) {\n\t\treturn method;\n\t}\n\n\tvar wrapper = function wrapSuper () {\n\t\tvar superMethod = getSuperMethod( wrapper._parent, name ),\n\t\t\thasSuper = ( '_super' in this ),\n\t\t\toldSuper = this._super,\n\t\t\tresult;\n\n\t\tthis._super = superMethod;\n\n\t\tresult = method.apply( this, arguments );\n\n\t\tif ( hasSuper ) {\n\t\t\tthis._super = oldSuper;\n\t\t} else {\n\t\t\tdelete this._super;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\twrapper._parent = parent;\n\twrapper._method = method;\n\n\treturn wrapper;\n}\n\nfunction getSuperMethod ( parent, name ) {\n\tvar value, method;\n\n\tif ( name in parent ) {\n\t\tvalue = parent[name];\n\n\t\tif ( typeof value === 'function' ) {\n\t\t\tmethod = value;\n\t\t} else {\n\t\t\tmethod = function returnValue () {\n\t\t\t\treturn value;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tmethod = noop;\n\t}\n\n\treturn method;\n}\n","import { warn } from 'utils/log';\nimport { isArray } from 'utils/is';\n\nfunction getMessage( deprecated, correct, isError ) {\n\treturn 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.'\n\t\t+ ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );\n}\n\nfunction deprecateOption ( options, deprecatedOption, correct ) {\n\tif ( deprecatedOption in options ) {\n\t\tif( !( correct in options ) ) {\n\t\t\twarn( getMessage( deprecatedOption, correct ) );\n\t\t\toptions[ correct ] = options[ deprecatedOption ];\n\t\t} else {\n\t\t\tthrow new Error( getMessage( deprecatedOption, correct, true ) );\n\t\t}\n\t}\n}\n\nexport default function deprecate ( options ) {\n\tdeprecateOption( options, 'beforeInit', 'onconstruct' );\n\tdeprecateOption( options, 'init', 'onrender' );\n\tdeprecateOption( options, 'complete', 'oncomplete' );\n\tdeprecateOption( options, 'eventDefinitions', 'events' );\n\n\t// Using extend with Component instead of options,\n\t// like Human.extend( Spider ) means adaptors as a registry\n\t// gets copied to options. So we have to check if actually an array\n\tif ( isArray( options.adaptors ) ) {\n\t\tdeprecateOption( options, 'adaptors', 'adapt' );\n\t}\n}\n","import adaptConfigurator from './custom/adapt';\nimport cssConfigurator from './custom/css/css';\nimport dataConfigurator from './custom/data';\nimport templateConfigurator from './custom/template/template';\nimport defaults from './defaults';\nimport registries from './registries';\nimport wrapPrototype from './wrapPrototypeMethod';\nimport deprecate from './deprecate';\n\nvar config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\ncustom = {\n\tadapt: adaptConfigurator,\n\tcss: cssConfigurator,\n\tdata: dataConfigurator,\n\ttemplate: templateConfigurator\n};\n\ndefaultKeys = Object.keys( defaults );\n\nisStandardKey = makeObj( defaultKeys.filter( key => !custom[ key ] ) );\n\n// blacklisted keys that we don't double extend\nisBlacklisted = makeObj( defaultKeys.concat( registries.map( r => r.name ) ) );\n\norder = [].concat(\n\tdefaultKeys.filter( key => !registries[ key ] && !custom[ key ] ),\n\tregistries,\n\tcustom.data,\n\tcustom.template,\n\tcustom.css\n);\n\nconfig = {\n\textend: ( Parent, proto, options ) => configure( 'extend', Parent, proto, options ),\n\n\tinit: ( Parent, ractive, options ) => configure( 'init', Parent, ractive, options ),\n\n\treset: ractive => {\n\t\treturn order.filter( c => {\n\t\t\treturn c.reset && c.reset( ractive );\n\t\t}).map( c => c.name );\n\t},\n\n\t// this defines the order. TODO this isn't used anywhere in the codebase,\n\t// only in the test suite - should get rid of it\n\torder: order,\n\n\t// TODO kill this off\n\tgetConstructTarget: ( ractive, options ) => {\n\t\tif ( options.onconstruct ) {\n\t\t\t// pretend this object literal is the ractive instance\n\t\t\treturn {\n\t\t\t\tonconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind(ractive),\n\t\t\t\tfire: ractive.fire.bind(ractive)\n\t\t\t};\n\t\t} else {\n\t\t\treturn ractive;\n\t\t}\n\t}\n};\n\nfunction configure ( method, Parent, target, options ) {\n\tdeprecate( options );\n\n\tfor ( let key in options ) {\n\t\tif ( isStandardKey[ key ] ) {\n\t\t\tlet value = options[ key ];\n\n\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\tvalue = wrapPrototype( Parent.prototype, key, value );\n\t\t\t}\n\n\t\t\ttarget[ key ] = value;\n\t\t}\n\t}\n\n\tregistries.forEach( registry => {\n\t\tregistry[ method ]( Parent, target, options );\n\t});\n\n\tadaptConfigurator[ method ]( Parent, target, options );\n\tdataConfigurator[ method ]( Parent, target, options );\n\ttemplateConfigurator[ method ]( Parent, target, options );\n\tcssConfigurator[ method ]( Parent, target, options );\n\n\textendOtherMethods( Parent.prototype, target, options );\n}\n\nfunction extendOtherMethods ( parent, target, options ) {\n\tfor ( let key in options ) {\n\t\tif ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {\n\t\t\tlet member = options[ key ];\n\n\t\t\t// if this is a method that overwrites a method, wrap it:\n\t\t\tif ( typeof member === 'function' ) {\n\t\t\t\tmember = wrapPrototype( parent, key, member );\n\t\t\t}\n\n\t\t\ttarget[ key ] = member;\n\t\t}\n\t}\n}\n\nfunction makeObj ( array ) {\n\tvar obj = {};\n\tarray.forEach( x => obj[x] = true );\n\treturn obj;\n}\n\nexport default config;\n","export default function Fragment$bubble () {\n\tthis.dirtyValue = this.dirtyArgs = true;\n\n\tif ( this.bound && typeof this.owner.bubble === 'function' ) {\n\t\tthis.owner.bubble();\n\t}\n}\n","export default function Fragment$detach () {\n\tvar docFrag;\n\n\tif ( this.items.length === 1 ) {\n\t\treturn this.items[0].detach();\n\t}\n\n\tdocFrag = document.createDocumentFragment();\n\n\tthis.items.forEach( item => {\n\t\tvar node = item.detach();\n\n\t\t// TODO The if {...} wasn't previously required - it is now, because we're\n\t\t// forcibly detaching everything to reorder sections after an update. That's\n\t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n\t\t// - as soon as it's replaced with something more elegant, this should\n\t\t// revert to `docFrag.appendChild( item.detach() )`\n\t\tif ( node ) {\n\t\t\tdocFrag.appendChild( node );\n\t\t}\n\t});\n\n\treturn docFrag;\n}\n","export default function Fragment$find ( selector ) {\n\tvar i, len, item, queryResult;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.find && ( queryResult = item.find( selector ) ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","export default function Fragment$findAll ( selector, query ) {\n\tvar i, len, item;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.findAll ) {\n\t\t\t\titem.findAll( selector, query );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn query;\n}\n","export default function Fragment$findAllComponents ( selector, query ) {\n\tvar i, len, item;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.findAllComponents ) {\n\t\t\t\titem.findAllComponents( selector, query );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn query;\n}\n","export default function Fragment$findComponent ( selector ) {\n\tvar len, i, item, queryResult;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","export default function Fragment$findNextNode ( item ) {\n\tvar index = item.index, node;\n\n\tif ( this.items[ index + 1 ] ) {\n\t\tnode = this.items[ index + 1 ].firstNode();\n\t}\n\n\t// if this is the root fragment, and there are no more items,\n\t// it means we're at the end...\n\telse if ( this.owner === this.root ) {\n\t\tif ( !this.owner.component ) {\n\t\t\t// TODO but something else could have been appended to\n\t\t\t// this.root.el, no?\n\t\t\tnode = null;\n\t\t}\n\n\t\t// ...unless this is a component\n\t\telse {\n\t\t\tnode = this.owner.component.findNextNode();\n\t\t}\n\t}\n\n\telse {\n\t\tnode = this.owner.findNextNode( this );\n\t}\n\n\treturn node;\n}\n","export default function Fragment$firstNode () {\n\tif ( this.items && this.items[0] ) {\n\t\treturn this.items[0].firstNode();\n\t}\n\n\treturn null;\n}\n","export default function processItems ( items, values, guid, counter ) {\n\tcounter = counter || 0;\n\n\treturn items.map( function ( item ) {\n\t\tvar placeholderId, wrapped, value;\n\n\t\tif ( item.text ) {\n\t\t\treturn item.text;\n\t\t}\n\n\t\tif ( item.fragments ) {\n\t\t\treturn item.fragments.map( function ( fragment ) {\n\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t\t\t}).join( '' );\n\t\t}\n\n\t\tplaceholderId = guid + '-' + counter++;\n\n\t\tif ( item.keypath && ( wrapped = item.root.viewmodel.wrapped[ item.keypath.str ] ) ) {\n\t\t\tvalue = wrapped.value;\n\t\t} else {\n\t\t\tvalue = item.getValue();\n\t\t}\n\n\t\tvalues[ placeholderId ] = value;\n\n\t\treturn '${' + placeholderId + '}';\n\t}).join( '' );\n}","import parseJSON from 'utils/parseJSON';\nimport processItems from './shared/processItems';\n\nexport default function Fragment$getArgsList () {\n\tvar values, source, parsed, result;\n\n\tif ( this.dirtyArgs ) {\n\t\tsource = processItems( this.items, values = {}, this.root._guid );\n\t\tparsed = parseJSON( '[' + source + ']', values );\n\n\t\tif ( !parsed ) {\n\t\t\tresult = [ this.toString() ];\n\t\t} else {\n\t\t\tresult = parsed.value;\n\t\t}\n\n\t\tthis.argsList = result;\n\t\tthis.dirtyArgs = false;\n\t}\n\n\treturn this.argsList;\n}","export default function Fragment$getNode () {\n\tvar fragment = this;\n\n\tdo  {\n\t\tif ( fragment.pElement ) {\n\t\t\treturn fragment.pElement.node;\n\t\t}\n\t} while ( fragment = fragment.parent );\n\n\treturn this.root.detached || this.root.el;\n}\n","import parseJSON from 'utils/parseJSON';\nimport processItems from './shared/processItems';\n\nexport default function Fragment$getValue () {\n\tvar values, source, parsed, result;\n\n\tif ( this.dirtyValue ) {\n\t\tsource = processItems( this.items, values = {}, this.root._guid );\n\t\tparsed = parseJSON( source, values );\n\n\t\tif ( !parsed ) {\n\t\t\tresult = this.toString();\n\t\t} else {\n\t\t\tresult = parsed.value;\n\t\t}\n\n\t\tthis.value = result;\n\t\tthis.dirtyValue = false;\n\t}\n\n\treturn this.value;\n}","export default function unbind () {\n\tif ( this.registered ) {\n\t\t// this was registered as a dependant\n\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t}\n\n\tif ( this.resolver ) {\n\t\tthis.resolver.unbind();\n\t}\n}\n","export default function Mustache$getValue () {\n\treturn this.value;\n}\n","import { SECTION_EACH } from 'config/types';\nimport { getKeypath } from 'shared/keypaths'; // TODO maybe we don't need the @ construct now that we have Keypath objects?\n\nvar SpecialResolver = function ( owner, ref, callback ) {\n\tthis.parentFragment = owner.parentFragment;\n\tthis.ref = ref;\n\tthis.callback = callback;\n\n\tthis.rebind();\n};\n\nvar props = {\n\t'@keypath': { prefix: 'c', prop: [ 'context' ] },\n\t'@index': { prefix: 'i', prop: [ 'index' ] },\n\t'@key': { prefix: 'k', prop: [ 'key', 'index' ] }\n};\n\nfunction getProp( target, prop ) {\n\tvar value;\n\tfor ( let i = 0; i < prop.prop.length; i++ ) {\n\t\tif ( ( value = target[prop.prop[i]] ) !== undefined ) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nSpecialResolver.prototype = {\n\trebind: function () {\n\t\tvar ref = this.ref, fragment = this.parentFragment, prop = props[ref], value;\n\n\t\tif ( !prop ) {\n\t\t\tthrow new Error( 'Unknown special reference \"' + ref + '\" - valid references are @index, @key and @keypath' );\n\t\t}\n\n\t\t// have we already found the nearest parent?\n\t\tif ( this.cached ) {\n\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + getProp( this.cached, prop ) ) );\n\t\t}\n\n\t\t// special case for indices, which may cross component boundaries\n\t\tif ( prop.prop.indexOf( 'index' ) !== -1 || prop.prop.indexOf( 'key' ) !== -1 ) {\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( fragment.owner.currentSubtype === SECTION_EACH && ( value = getProp( fragment, prop ) ) !== undefined ) {\n\t\t\t\t\tthis.cached = fragment;\n\n\t\t\t\t\tfragment.registerIndexRef( this );\n\n\t\t\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + value ) );\n\t\t\t\t}\n\n\t\t\t\t// watch for component boundaries\n\t\t\t\tif ( !fragment.parent && fragment.owner &&\n\t\t\t\t     fragment.owner.component && fragment.owner.component.parentFragment &&\n\t\t\t\t     !fragment.owner.component.instance.isolated ) {\n\t\t\t\t\tfragment = fragment.owner.component.parentFragment;\n\t\t\t\t} else {\n\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( ( value = getProp( fragment, prop ) ) !== undefined ) {\n\t\t\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + value.str ) );\n\t\t\t\t}\n\n\t\t\t\tfragment = fragment.parent;\n\t\t\t}\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tif ( this.cached ) {\n\t\t\tthis.cached.unregisterIndexRef( this );\n\t\t}\n\t}\n};\n\nexport default SpecialResolver;\n","export default findIndexRefs;\n\nfunction findIndexRefs( fragment, refName ) {\n\tvar result = {}, refs, fragRefs, ref, i, owner, hit = false;\n\n\tif ( !refName ) {\n\t\tresult.refs = refs = {};\n\t}\n\n\twhile ( fragment ) {\n\t\tif ( ( owner = fragment.owner ) && ( fragRefs = owner.indexRefs ) ) {\n\n\t\t\t// we're looking for a particular ref, and it's here\n\t\t\tif ( refName && ( ref = owner.getIndexRef( refName ) ) ) {\n\t\t\t\tresult.ref = {\n\t\t\t\t\tfragment: fragment,\n\t\t\t\t\tref: ref\n\t\t\t\t};\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// we're collecting refs up-tree\n\t\t\telse if ( !refName ) {\n\t\t\t\tfor ( i in fragRefs ) {\n\t\t\t\t\tref = fragRefs[i];\n\n\t\t\t\t\t// don't overwrite existing refs - they should shadow parents\n\t\t\t\t\tif ( !refs[ref.n] ) {\n\t\t\t\t\t\thit = true;\n\t\t\t\t\t\trefs[ref.n] = {\n\t\t\t\t\t\t\tfragment: fragment,\n\t\t\t\t\t\t\tref: ref\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// watch for component boundaries\n\t\tif ( !fragment.parent && fragment.owner &&\n\t\t     fragment.owner.component && fragment.owner.component.parentFragment &&\n\t\t     !fragment.owner.component.instance.isolated ) {\n\t\t\tresult.componentBoundary = true;\n\t\t\tfragment = fragment.owner.component.parentFragment;\n\t\t} else {\n\t\t\tfragment = fragment.parent;\n\t\t}\n\t}\n\n\tif ( !hit ) {\n\t\treturn undefined;\n\t} else {\n\t\treturn result;\n\t}\n}\n\nfindIndexRefs.resolve = function resolve( indices ) {\n\tvar refs = {}, k, ref;\n\n\tfor ( k in indices.refs ) {\n\t\tref = indices.refs[k];\n\t\trefs[ ref.ref.n ] = ref.ref.t === 'k' ? ref.fragment.key : ref.fragment.index;\n\t}\n\n\treturn refs;\n};\n","import ReferenceResolver from './ReferenceResolver';\nimport SpecialResolver from './SpecialResolver';\nimport IndexResolver from './IndexResolver';\nimport findIndexRefs from './findIndexRefs';\n\nexport default function createReferenceResolver ( owner, ref, callback ) {\n\tvar indexRef;\n\n\tif ( ref.charAt( 0 ) === '@' ) {\n\t\treturn new SpecialResolver( owner, ref, callback );\n\t}\n\n\tif ( indexRef = findIndexRefs( owner.parentFragment, ref ) ) {\n\t\treturn new IndexResolver( owner, indexRef, callback );\n\t}\n\n\treturn new ReferenceResolver( owner, ref, callback );\n}\n","var cache = {};\n\nexport default function getFunctionFromString ( str, i ) {\n\tvar fn, args;\n\n\tif ( cache[ str ] ) {\n\t\treturn cache[ str ];\n\t}\n\n\targs = [];\n\twhile ( i-- ) {\n\t\targs[i] = '_' + i;\n\t}\n\n\tfn = new Function( args.join( ',' ), 'return(' + str + ')' );\n\n\tcache[ str ] = fn;\n\treturn fn;\n}\n","import { defineProperty } from 'utils/object';\nimport { getKeypath } from 'shared/keypaths';\nimport getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from './createReferenceResolver';\nimport 'legacy'; // for fn.bind()\n\nvar ExpressionResolver, bind = Function.prototype.bind;\n\nExpressionResolver = function ( owner, parentFragment, expression, callback ) {\n\tvar ractive;\n\n\tractive = owner.root;\n\n\tthis.root = ractive;\n\tthis.parentFragment = parentFragment;\n\tthis.callback = callback;\n\tthis.owner = owner;\n\tthis.str = expression.s;\n\tthis.keypaths = [];\n\n\t// Create resolvers for each reference\n\tthis.pending = expression.r.length;\n\tthis.refResolvers = expression.r.map( ( ref, i ) => {\n\t\treturn createReferenceResolver( this, ref, keypath => {\n\t\t\tthis.resolve( i, keypath );\n\t\t});\n\t});\n\n\tthis.ready = true;\n\tthis.bubble();\n};\n\nExpressionResolver.prototype = {\n\tbubble () {\n\t\tif ( !this.ready ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.uniqueString = getUniqueString( this.str, this.keypaths );\n\t\tthis.keypath = createExpressionKeypath( this.uniqueString );\n\n\t\tthis.createEvaluator();\n\t\tthis.callback( this.keypath );\n\t},\n\n\tunbind () {\n\t\tvar resolver;\n\n\t\twhile ( resolver = this.refResolvers.pop() ) {\n\t\t\tresolver.unbind();\n\t\t}\n\t},\n\n\tresolve ( index, keypath ) {\n\t\tthis.keypaths[ index ] = keypath;\n\t\tthis.bubble();\n\t},\n\n\tcreateEvaluator () {\n\t\tvar computation, valueGetters, signature, keypath, fn;\n\n\t\tkeypath = this.keypath;\n\t\tcomputation = this.root.viewmodel.computations[ keypath.str ];\n\n\t\t// only if it doesn't exist yet!\n\t\tif ( !computation ) {\n\t\t\tfn = getFunctionFromString( this.str, this.refResolvers.length );\n\n\t\t\tvalueGetters = this.keypaths.map( keypath => {\n\t\t\t\tvar value;\n\n\t\t\t\tif ( keypath === 'undefined' ) {\n\t\t\t\t\treturn () => undefined;\n\t\t\t\t}\n\n\t\t\t\t// 'special' keypaths encode a value\n\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\tvalue = keypath.value;\n\t\t\t\t\treturn () => value;\n\t\t\t\t}\n\n\t\t\t\treturn () => {\n\t\t\t\t\tvar value = this.root.viewmodel.get( keypath, { noUnwrap: true });\n\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\tvalue = wrapFunction( value, this.root );\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tsignature = {\n\t\t\t\tdeps: this.keypaths.filter( isValidDependency ),\n\t\t\t\tget () {\n\t\t\t\t\tvar args = valueGetters.map( call );\n\t\t\t\t\treturn fn.apply( null, args );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcomputation = this.root.viewmodel.compute( keypath, signature );\n\t\t} else {\n\t\t\tthis.root.viewmodel.mark( keypath );\n\t\t}\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// TODO only bubble once, no matter how many references are affected by the rebind\n\t\tthis.refResolvers.forEach( r => r.rebind( oldKeypath, newKeypath ) );\n\t}\n};\n\nexport default ExpressionResolver;\n\nfunction call ( value ) {\n\treturn value.call();\n}\n\nfunction getUniqueString ( str, keypaths ) {\n\t// get string that is unique to this expression\n\treturn str.replace( /_([0-9]+)/g, function ( match, $1 ) {\n\t\tvar keypath, value;\n\n\t\tkeypath = keypaths[ $1 ];\n\n\t\tif ( keypath === undefined ) {\n\t\t\treturn 'undefined';\n\t\t}\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\tvalue = keypath.value;\n\t\t\treturn typeof value === 'number' ? value : '\"' + value + '\"';\n\t\t}\n\n\t\treturn keypath.str;\n\t});\n}\n\nfunction createExpressionKeypath ( uniqueString ) {\n\t// Sanitize by removing any periods or square brackets. Otherwise\n\t// we can't split the keypath into keys!\n\t// Remove asterisks too, since they mess with pattern observers\n\treturn getKeypath( '${' + uniqueString.replace( /[\\.\\[\\]]/g, '-' ).replace( /\\*/, '#MUL#' ) + '}' );\n}\n\nfunction isValidDependency ( keypath ) {\n\treturn keypath !== undefined && keypath[0] !== '@';\n}\n\nfunction wrapFunction ( fn, ractive ) {\n\tvar wrapped, prop, key;\n\n\tif ( fn.__ractive_nowrap ) {\n\t\treturn fn;\n\t}\n\n\tprop = '__ractive_' + ractive._guid;\n\twrapped = fn[ prop ];\n\n\tif ( wrapped ) {\n\t\treturn wrapped;\n\t}\n\n\telse if ( /this/.test( fn.toString() ) ) {\n\t\tdefineProperty( fn, prop, {\n\t\t\tvalue: bind.call( fn, ractive ),\n\t\t\tconfigurable: true\n\t\t});\n\n\t\t// Add properties/methods to wrapped function\n\t\tfor ( key in fn ) {\n\t\t\tif ( fn.hasOwnProperty( key ) ) {\n\t\t\t\tfn[ prop ][ key ] = fn[ key ];\n\t\t\t}\n\t\t}\n\n\t\tractive._boundFunctions.push({\n\t\t\tfn: fn,\n\t\t\tprop: prop\n\t\t});\n\n\t\treturn fn[ prop ];\n\t}\n\n\tdefineProperty( fn, '__ractive_nowrap', {\n\t\tvalue: fn\n\t});\n\n\treturn fn.__ractive_nowrap;\n}\n","import resolveRef from 'shared/resolveRef';\nimport { unbind } from 'shared/methodCallers';\nimport { getKeypath } from 'shared/keypaths';\nimport ReferenceResolver from '../ReferenceResolver';\nimport MemberResolver from './MemberResolver';\n\nvar ReferenceExpressionResolver = function ( mustache, template, callback ) {\n\tvar ractive, ref, keypath, parentFragment;\n\n\tthis.parentFragment = parentFragment = mustache.parentFragment;\n\tthis.root = ractive = mustache.root;\n\tthis.mustache = mustache;\n\n\tthis.ref = ref = template.r;\n\tthis.callback = callback;\n\n\tthis.unresolved = [];\n\n\t// Find base keypath\n\tif ( keypath = resolveRef( ractive, ref, parentFragment ) ) {\n\t\tthis.base = keypath;\n\t} else {\n\t\tthis.baseResolver = new ReferenceResolver( this, ref, keypath => {\n\t\t\tthis.base = keypath;\n\t\t\tthis.baseResolver = null;\n\t\t\tthis.bubble();\n\t\t});\n\t}\n\n\t// Find values for members, or mark them as unresolved\n\tthis.members = template.m.map( template => new MemberResolver( template, this, parentFragment ) );\n\n\tthis.ready = true;\n\tthis.bubble(); // trigger initial resolution if possible\n};\n\nReferenceExpressionResolver.prototype = {\n\tgetKeypath: function () {\n\t\tvar values = this.members.map( getValue );\n\n\t\tif ( !values.every( isDefined ) || this.baseResolver ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.base.join( values.join( '.' ) );\n\t},\n\n\tbubble: function () {\n\t\tif ( !this.ready || this.baseResolver ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.callback( this.getKeypath() );\n\t},\n\n\tunbind: function () {\n\t\tthis.members.forEach( unbind );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tvar changed;\n\n\t\tthis.members.forEach( members => {\n\t\t\tif ( members.rebind( oldKeypath, newKeypath ) ) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t});\n\n\t\tif ( changed ) {\n\t\t\tthis.bubble();\n\t\t}\n\t},\n\n\tforceResolution: function () {\n\t\tif ( this.baseResolver ) {\n\t\t\tthis.base = getKeypath( this.ref );\n\n\t\t\tthis.baseResolver.unbind();\n\t\t\tthis.baseResolver = null;\n\t\t}\n\n\t\tthis.members.forEach( forceResolution );\n\t\tthis.bubble();\n\t}\n};\n\nfunction getValue ( member ) {\n\treturn member.value;\n}\n\nfunction isDefined ( value ) {\n\treturn value != undefined;\n}\n\nfunction forceResolution ( member ) {\n\tmember.forceResolution();\n}\n\nexport default ReferenceExpressionResolver;\n","import { SECTION_UNLESS } from 'config/types';\nimport createReferenceResolver from '../Resolvers/createReferenceResolver';\nimport ReferenceExpressionResolver from '../Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport ExpressionResolver from '../Resolvers/ExpressionResolver';\n\nexport default function Mustache$init ( mustache, options ) {\n\n\tvar ref, parentFragment, template;\n\n\tparentFragment = options.parentFragment;\n\ttemplate = options.template;\n\n\tmustache.root           = parentFragment.root;\n\tmustache.parentFragment = parentFragment;\n\tmustache.pElement       = parentFragment.pElement;\n\n\tmustache.template       = options.template;\n\tmustache.index          = options.index || 0;\n\tmustache.isStatic       = options.template.s;\n\n\tmustache.type = options.template.t;\n\n\tmustache.registered = false;\n\n\t// if this is a simple mustache, with a reference, we just need to resolve\n\t// the reference to a keypath\n\tif ( ref = template.r ) {\n\t\tmustache.resolver = createReferenceResolver( mustache, ref, resolve );\n\t}\n\n\t// if it's an expression, we have a bit more work to do\n\tif ( options.template.x ) {\n\t\tmustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );\n\t}\n\n\tif ( options.template.rx ) {\n\t\tmustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );\n\t}\n\n\t// Special case - inverted sections\n\tif ( mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {\n\t\tmustache.setValue( undefined );\n\t}\n\n\tfunction resolve ( keypath ) {\n\t\tmustache.resolve( keypath );\n\t}\n\n\tfunction resolveAndRebindChildren ( newKeypath ) {\n\t\tvar oldKeypath = mustache.keypath;\n\n\t\tif ( newKeypath != oldKeypath ) {\n\t\t\tmustache.resolve( newKeypath );\n\n\t\t\tif ( oldKeypath !== undefined ) {\n\t\t\t\tmustache.fragments && mustache.fragments.forEach( f => {\n\t\t\t\t\tf.rebind( oldKeypath, newKeypath );\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n","export default function Mustache$resolve ( keypath ) {\n\tvar wasResolved, value, twowayBinding;\n\n\t// 'Special' keypaths, e.g. @foo or @7, encode a value\n\tif ( keypath && keypath.isSpecial ) {\n\t\tthis.keypath = keypath;\n\t\tthis.setValue( keypath.value );\n\t\treturn;\n\t}\n\n\t// If we resolved previously, we need to unregister\n\tif ( this.registered ) { // undefined or null\n\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\tthis.registered = false;\n\n\t\twasResolved = true;\n\t}\n\n\tthis.keypath = keypath;\n\n\t// If the new keypath exists, we need to register\n\t// with the viewmodel\n\tif ( keypath != undefined ) { // undefined or null\n\t\tvalue = this.root.viewmodel.get( keypath );\n\t\tthis.root.viewmodel.register( keypath, this );\n\n\t\tthis.registered = true;\n\t}\n\n\t// Either way we need to queue up a render (`value`\n\t// will be `undefined` if there's no keypath)\n\tthis.setValue( value );\n\n\t// Two-way bindings need to point to their new target keypath\n\tif ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {\n\t\ttwowayBinding.rebound();\n\t}\n}\n","export default function Mustache$rebind ( oldKeypath, newKeypath ) {\n\t// Children first\n\tif ( this.fragments ) {\n\t\tthis.fragments.forEach( f => f.rebind( oldKeypath, newKeypath ) );\n\t}\n\n\t// Expression mustache?\n\tif ( this.resolver ) {\n\t\tthis.resolver.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function Section$bubble () {\n\tthis.parentFragment.bubble();\n}\n","export default function Section$detach () {\n\tvar docFrag;\n\n\tif ( this.fragments.length === 1 ) {\n\t\treturn this.fragments[0].detach();\n\t}\n\n\tdocFrag = document.createDocumentFragment();\n\n\tthis.fragments.forEach( item => {\n\t\tdocFrag.appendChild( item.detach() );\n\t});\n\n\treturn docFrag;\n}\n","export default function Section$find ( selector ) {\n\tvar i, len, queryResult;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( queryResult = this.fragments[i].find( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Section$findAll ( selector, query ) {\n\tvar i, len;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tthis.fragments[i].findAll( selector, query );\n\t}\n}\n","export default function Section$findAllComponents ( selector, query ) {\n\tvar i, len;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tthis.fragments[i].findAllComponents( selector, query );\n\t}\n}\n","export default function Section$findComponent ( selector ) {\n\tvar i, len, queryResult;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( queryResult = this.fragments[i].findComponent( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Section$findNextNode ( fragment ) {\n\tif ( this.fragments[ fragment.index + 1 ] ) {\n\t\treturn this.fragments[ fragment.index + 1 ].firstNode();\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Section$firstNode () {\n\tvar len, i, node;\n\n\tif ( len = this.fragments.length ) {\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tif ( node = this.fragments[i].firstNode() ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","import { SECTION_EACH } from 'config/types';\nimport runloop from 'global/runloop';\n\nexport default function Section$shuffle ( newIndices ) {\n\tvar parentFragment,\n\t\tfirstChange,\n\t\ti,\n\t\tnewLength,\n\t\treboundFragments,\n\t\tfragmentOptions,\n\t\tfragment;\n\n\t// short circuit any double-updates, and ensure that this isn't applied to\n\t// non-list sections\n\tif ( this.shuffling || this.unbound || ( this.currentSubtype !== SECTION_EACH ) ) {\n\t\treturn;\n\t}\n\n\tthis.shuffling = true;\n\trunloop.scheduleTask( () => this.shuffling = false );\n\n\tparentFragment = this.parentFragment;\n\n\treboundFragments = [];\n\n\t// TODO: need to update this\n\t// first, rebind existing fragments\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tvar fragment, by, oldKeypath, newKeypath, deps;\n\n\t\tif ( newIndex === oldIndex ) {\n\t\t\treboundFragments[ newIndex ] = this.fragments[ oldIndex ];\n\t\t\treturn;\n\t\t}\n\n\t\tfragment = this.fragments[ oldIndex ];\n\n\t\tif ( firstChange === undefined ) {\n\t\t\tfirstChange = oldIndex;\n\t\t}\n\n\t\t// does this fragment need to be torn down?\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.fragmentsToUnrender.push( fragment );\n\t\t\tfragment.unbind();\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, it needs to be rebound to a new index\n\t\tby = newIndex - oldIndex;\n\t\toldKeypath = this.keypath.join( oldIndex );\n\t\tnewKeypath = this.keypath.join( newIndex );\n\n\t\tfragment.index = newIndex;\n\n\t\t// notify any registered index refs directly\n\t\tif ( deps = fragment.registeredIndexRefs ) {\n\t\t\tdeps.forEach( blindRebind );\n\t\t}\n\n\t\tfragment.rebind( oldKeypath, newKeypath );\n\t\treboundFragments[ newIndex ] = fragment;\n\t});\n\n\tnewLength = this.root.viewmodel.get( this.keypath ).length;\n\n\t// If nothing changed with the existing fragments, then we start adding\n\t// new fragments at the end...\n\tif ( firstChange === undefined ) {\n\t\t// ...unless there are no new fragments to add\n\t\tif ( this.length === newLength ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfirstChange = this.length;\n\t}\n\n\tthis.length = this.fragments.length = newLength;\n\n\tif ( this.rendered ) {\n\t\trunloop.addView( this );\n\t}\n\n\t// Prepare new fragment options\n\tfragmentOptions = {\n\t\ttemplate: this.template.f,\n\t\troot:       this.root,\n\t\towner:      this\n\t};\n\n\t// Add as many new fragments as we need to, or add back existing\n\t// (detached) fragments\n\tfor ( i = firstChange; i < newLength; i += 1 ) {\n\t\tfragment = reboundFragments[i];\n\n\t\tif ( !fragment ) {\n\t\t\tthis.fragmentsToCreate.push( i );\n\t\t}\n\n\t\tthis.fragments[i] = fragment;\n\t}\n}\n\nfunction blindRebind ( dep ) {\n\t// the keypath doesn't actually matter here as it won't have changed\n\tdep.rebind( '', '' );\n}\n","export default function Section$render () {\n\tthis.docFrag = document.createDocumentFragment();\n\n\tthis.fragments.forEach( f => this.docFrag.appendChild( f.render() ) );\n\n\tthis.renderedFragments = this.fragments.slice();\n\tthis.fragmentsToRender = [];\n\n\tthis.rendered = true;\n\treturn this.docFrag;\n}\n","import { SECTION_EACH, SECTION_IF, SECTION_UNLESS, SECTION_WITH, SECTION_IF_WITH } from 'config/types';\nimport { isArrayLike, isObject } from 'utils/is';\nimport { unbind } from 'shared/methodCallers';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Section$setValue ( value ) {\n\tvar wrapper, fragmentOptions;\n\n\tif ( this.updating ) {\n\t\t// If a child of this section causes a re-evaluation - for example, an\n\t\t// expression refers to a function that mutates the array that this\n\t\t// section depends on - we'll end up with a double rendering bug (see\n\t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n\t\treturn;\n\t}\n\n\tthis.updating = true;\n\n\t// with sections, we need to get the fake value if we have a wrapped object\n\tif ( this.keypath && ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) ) {\n\t\tvalue = wrapper.get();\n\t}\n\n\t// If any fragments are awaiting creation after a splice,\n\t// this is the place to do it\n\tif ( this.fragmentsToCreate.length ) {\n\t\tfragmentOptions = {\n\t\t\ttemplate: this.template.f,\n\t\t\troot:     this.root,\n\t\t\tpElement: this.pElement,\n\t\t\towner:    this\n\t\t};\n\n\t\tthis.fragmentsToCreate.forEach( index => {\n\t\t\tvar fragment;\n\n\t\t\tfragmentOptions.context = this.keypath.join( index );\n\t\t\tfragmentOptions.index = index;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\tthis.fragmentsToRender.push( this.fragments[ index ] = fragment );\n\t\t});\n\n\t\tthis.fragmentsToCreate.length = 0;\n\t}\n\n\telse if ( reevaluateSection( this, value ) ) {\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n\n\tthis.value = value;\n\tthis.updating = false;\n}\n\nfunction changeCurrentSubtype ( section, value, obj ) {\n\tif ( value === SECTION_EACH ) {\n\t\t// make sure ref type is up to date for key or value indices\n\t\tif ( section.indexRefs && section.indexRefs[0] ) {\n\t\t\tlet ref = section.indexRefs[0];\n\n\t\t\t// when switching flavors, make sure the section gets updated\n\t\t\tif ( ( obj && ref.t === 'i' ) || ( !obj && ref.t === 'k' ) ) {\n\t\t\t\t// if switching from object to list, unbind all of the old fragments\n\t\t\t\tif ( !obj ) {\n\t\t\t\t\tsection.length = 0;\n\t\t\t\t  section.fragmentsToUnrender = section.fragments.slice( 0 );\n\t\t\t\t\tsection.fragmentsToUnrender.forEach( f => f.unbind() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tref.t = obj ? 'k' : 'i';\n\t\t}\n\t}\n\n\tsection.currentSubtype = value;\n}\n\nfunction reevaluateSection ( section, value ) {\n\tvar fragmentOptions = {\n\t\ttemplate: section.template.f,\n\t\troot:       section.root,\n\t\tpElement:   section.parentFragment.pElement,\n\t\towner:      section\n\t};\n\n\t// If we already know the section type, great\n\t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n\t// and avoid doing this each time?\n\tif ( section.subtype ) {\n\t\tswitch ( section.subtype ) {\n\t\t\tcase SECTION_IF:\n\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\n\t\t\tcase SECTION_UNLESS:\n\t\t\treturn reevaluateConditionalSection( section, value, true, fragmentOptions );\n\n\t\t\tcase SECTION_WITH:\n\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\n\t\t\tcase SECTION_IF_WITH:\n\t\t\treturn reevaluateConditionalContextSection( section, value, fragmentOptions );\n\n\t\t\tcase SECTION_EACH:\n\t\t\tif ( isObject( value ) ) {\n\t\t\t\tchangeCurrentSubtype( section, section.subtype, true );\n\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t}\n\n\t\t\t// Fallthrough - if it's a conditional or an array we need to continue\n\t\t}\n\t}\n\n\t// Otherwise we need to work out what sort of section we're dealing with\n\tsection.ordered = !!isArrayLike( value );\n\n\t// Ordered list section\n\tif ( section.ordered ) {\n\t\tchangeCurrentSubtype( section, SECTION_EACH, false );\n\t\treturn reevaluateListSection( section, value, fragmentOptions );\n\t}\n\n\t// Unordered list, or context\n\tif ( isObject( value ) || typeof value === 'function' ) {\n\t\t// Index reference indicates section should be treated as a list\n\t\tif ( section.template.i ) {\n\t\t\tchangeCurrentSubtype( section, SECTION_EACH, true );\n\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t}\n\n\t\t// Otherwise, object provides context for contents\n\t\tchangeCurrentSubtype( section, SECTION_WITH, false );\n\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t}\n\n\t// Conditional section\n\tchangeCurrentSubtype( section, SECTION_IF, false );\n\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n}\n\nfunction reevaluateListSection ( section, value, fragmentOptions ) {\n\tvar i, length, fragment;\n\n\tlength = value.length;\n\n\tif ( length === section.length ) {\n\t\t// Nothing to do\n\t\treturn false;\n\t}\n\n\t// if the array is shorter than it was previously, remove items\n\tif ( length < section.length ) {\n\t\tsection.fragmentsToUnrender = section.fragments.splice( length, section.length - length );\n\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t}\n\n\t// otherwise...\n\telse {\n\t\tif ( length > section.length ) {\n\t\t\t// add any new ones\n\t\t\tfor ( i = section.length; i < length; i += 1 ) {\n\t\t\t\t// append list item to context stack\n\t\t\t\tfragmentOptions.context = section.keypath.join( i );\n\t\t\t\tfragmentOptions.index = i;\n\n\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\tsection.fragmentsToRender.push( section.fragments[i] = fragment );\n\t\t\t}\n\t\t}\n\t}\n\n\tsection.length = length;\n\treturn true;\n}\n\nfunction reevaluateListObjectSection ( section, value, fragmentOptions ) {\n\tvar id, i, hasKey, fragment, changed, deps;\n\n\thasKey = section.hasKey || ( section.hasKey = {} );\n\n\t// remove any fragments that should no longer exist\n\ti = section.fragments.length;\n\twhile ( i-- ) {\n\t\tfragment = section.fragments[i];\n\n\t\tif ( !( fragment.key in value ) ) {\n\t\t\tchanged = true;\n\n\t\t\tfragment.unbind();\n\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\tsection.fragments.splice( i, 1 );\n\n\t\t\thasKey[ fragment.key ] = false;\n\t\t}\n\t}\n\n\t// notify any dependents about changed indices\n\ti = section.fragments.length;\n\twhile ( i-- ) {\n\t\tfragment = section.fragments[i];\n\n\t\tif ( fragment.index !== i ){\n\t\t\tfragment.index = i;\n\t\t\tif ( deps = fragment.registeredIndexRefs ) {\n\t\t\t\tdeps.forEach( blindRebind );\n\t\t\t}\n\t\t}\n\t}\n\n\t// add any that haven't been created yet\n\ti = section.fragments.length;\n\tfor ( id in value ) {\n\t\tif ( !hasKey[ id ] ) {\n\t\t\tchanged = true;\n\n\t\t\tfragmentOptions.context = section.keypath.join( id );\n\t\t\tfragmentOptions.key = id;\n\t\t\tfragmentOptions.index = i++;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\n\t\t\tsection.fragmentsToRender.push( fragment );\n\t\t\tsection.fragments.push( fragment );\n\t\t\thasKey[ id ] = true;\n\t\t}\n\t}\n\n\tsection.length = section.fragments.length;\n\treturn changed;\n}\n\nfunction reevaluateConditionalContextSection ( section, value, fragmentOptions ) {\n\tif ( value ) {\n\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t} else {\n\t\treturn removeSectionFragments( section );\n\t}\n}\n\nfunction reevaluateContextSection ( section, fragmentOptions ) {\n\tvar fragment;\n\n\t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n\t// (if it is already rendered, then any children dependent on the context stack\n\t// will update themselves without any prompting)\n\tif ( !section.length ) {\n\t\t// append this section to the context stack\n\t\tfragmentOptions.context = section.keypath;\n\t\tfragmentOptions.index = 0;\n\n\t\tfragment = new Fragment( fragmentOptions );\n\n\t\tsection.fragmentsToRender.push( section.fragments[0] = fragment );\n\t\tsection.length = 1;\n\n\t\treturn true;\n\t}\n}\n\nfunction reevaluateConditionalSection ( section, value, inverted, fragmentOptions ) {\n\tvar doRender, emptyArray, emptyObject, fragment, name;\n\n\temptyArray = ( isArrayLike( value ) && value.length === 0 );\n\temptyObject = false;\n\tif( !isArrayLike( value ) && isObject( value ) ) {\n\t\temptyObject = true;\n\t\tfor( name in value ) {\n\t\t\temptyObject = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( inverted ) {\n\t\tdoRender = emptyArray || emptyObject || !value;\n\t} else {\n\t\tdoRender = value && !emptyArray && !emptyObject;\n\t}\n\n\tif ( doRender ) {\n\t\tif ( !section.length ) {\n\t\t\t// no change to context stack\n\t\t\tfragmentOptions.index = 0;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\tsection.fragmentsToRender.push( section.fragments[0] = fragment );\n\t\t\tsection.length = 1;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( section.length > 1 ) {\n\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 1 );\n\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\telse {\n\t\treturn removeSectionFragments( section );\n\t}\n}\n\nfunction removeSectionFragments ( section ) {\n\tif ( section.length ) {\n\t\tsection.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );\n\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\tsection.length = section.fragmentsToRender.length = 0;\n\t\treturn true;\n\t}\n}\n\nfunction isRendered ( fragment ) {\n\treturn fragment.rendered;\n}\n\nfunction blindRebind ( dep ) {\n\t// the keypath doesn't actually matter here as it won't have changed\n\tdep.rebind( '', '' );\n}\n","export default function Section$toString ( escape ) {\n\tvar str, i, len;\n\n\tstr = '';\n\n\ti = 0;\n\tlen = this.length;\n\n\tfor ( i=0; i<len; i+=1 ) {\n\t\tstr += this.fragments[i].toString( escape );\n\t}\n\n\treturn str;\n}\n","import { removeFromArray } from 'utils/array';\nimport { unbind as unbindFragment } from 'shared/methodCallers';\nimport unbind from '../../shared/unbind';\n\nexport default function Section$unbind () {\n\tthis.fragments.forEach( unbindFragment );\n\tthis.fragmentsToRender.forEach( f => removeFromArray( this.fragments, f ) );\n\tthis.fragmentsToRender = [];\n\tunbind.call( this );\n\n\tthis.length = 0;\n\tthis.unbound = true;\n}\n","export default function Section$unrender ( shouldDestroy ) {\n\tthis.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\tthis.renderedFragments = [];\n\tthis.rendered = false;\n}\n\nfunction unrenderAndDestroy ( fragment ) {\n\tfragment.unrender( true );\n}\n\nfunction unrender ( fragment ) {\n\tfragment.unrender( false );\n}\n","export default function Section$update () {\n\tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n\t// `this.renderedFragments` is in the order of the previous render.\n\t// If fragments have shuffled about, this allows us to quickly\n\t// reinsert them in the correct place\n\trenderedFragments = this.renderedFragments;\n\n\t// Remove fragments that have been marked for destruction\n\twhile ( fragment = this.fragmentsToUnrender.pop() ) {\n\t\tfragment.unrender( true );\n\t\trenderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );\n\t}\n\n\t// Render new fragments (but don't insert them yet)\n\twhile ( fragment = this.fragmentsToRender.shift() ) {\n\t\tfragment.render();\n\t}\n\n\tif ( this.rendered ) {\n\t\ttarget = this.parentFragment.getNode();\n\t}\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tfragment = this.fragments[i];\n\t\trenderIndex = renderedFragments.indexOf( fragment, i ); // search from current index - it's guaranteed to be the same or higher\n\n\t\tif ( renderIndex === i ) {\n\t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n\t\t\tif ( this.docFrag.childNodes.length ) {\n\t\t\t\tanchor = fragment.firstNode();\n\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis.docFrag.appendChild( fragment.detach() );\n\n\t\t// update renderedFragments\n\t\tif ( renderIndex !== -1 ) {\n\t\t\trenderedFragments.splice( renderIndex, 1 );\n\t\t}\n\t\trenderedFragments.splice( i, 0, fragment );\n\t}\n\n\tif ( this.rendered && this.docFrag.childNodes.length ) {\n\t\tanchor = this.parentFragment.findNextNode( this );\n\t\ttarget.insertBefore( this.docFrag, anchor );\n\t}\n\n\t// Save the rendering order for next time\n\tthis.renderedFragments = this.fragments.slice();\n}\n","export default function Triple$detach () {\n\tvar len, i;\n\n\tif ( this.docFrag ) {\n\t\tlen = this.nodes.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.docFrag.appendChild( this.nodes[i] );\n\t\t}\n\n\t\treturn this.docFrag;\n\t}\n}\n","import { matches } from 'utils/dom';\n\nexport default function Triple$find ( selector ) {\n\tvar i, len, node, queryResult;\n\n\tlen = this.nodes.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tnode = this.nodes[i];\n\n\t\tif ( node.nodeType !== 1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( matches( node, selector ) ) {\n\t\t\treturn node;\n\t\t}\n\n\t\tif ( queryResult = node.querySelector( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","import { matches } from 'utils/dom';\n\nexport default function Triple$findAll ( selector, queryResult ) {\n\tvar i, len, node, queryAllResult, numNodes, j;\n\n\tlen = this.nodes.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tnode = this.nodes[i];\n\n\t\tif ( node.nodeType !== 1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( matches( node, selector ) ) {\n\t\t\tqueryResult.push( node );\n\t\t}\n\n\t\tif ( queryAllResult = node.querySelectorAll( selector ) ) {\n\t\t\tnumNodes = queryAllResult.length;\n\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\tqueryResult.push( queryAllResult[j] );\n\t\t\t}\n\t\t}\n\t}\n}\n","export default function Triple$firstNode () {\n\tif ( this.rendered && this.nodes[0] ) {\n\t\treturn this.nodes[0];\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\n\nvar elementCache = {}, ieBug, ieBlacklist;\n\ntry {\n\tcreateElement( 'table' ).innerHTML = 'foo';\n} catch ( err ) {\n\tieBug = true;\n\n\tieBlacklist = {\n\t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n\t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n\t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n\t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n\t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n\t};\n}\n\nexport default function ( html, node, docFrag ) {\n\tvar container, nodes = [], wrapper, selectedOption, child, i;\n\n\t// render 0 and false\n\tif ( html != null && html !== '' ) {\n\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n\t\t\tcontainer = container.querySelector( '.x' );\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\telse if ( node.namespaceURI === namespaces.svg ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\tcontainer = container.querySelector( '.x' );\n\t\t}\n\n\t\telse {\n\t\t\tcontainer = element( node.tagName );\n\t\t\tcontainer.innerHTML = html;\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\twhile ( child = container.firstChild ) {\n\t\t\tnodes.push( child );\n\t\t\tdocFrag.appendChild( child );\n\t\t}\n\n\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t// temporary container <select> causes the remaining ones to\n\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t// amaze me. You really do\n\t\t// ...and now Chrome too\n\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\ti = nodes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( nodes[i] !== selectedOption ) {\n\t\t\t\t\tnodes[i].selected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nodes;\n}\n\nfunction element ( tagName ) {\n\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n}\n","import { toArray } from 'utils/array';\n\nexport default function updateSelect ( parentElement ) {\n\tvar selectedOptions, option, value;\n\n\tif ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {\n\t\treturn;\n\t}\n\n\tselectedOptions = toArray( parentElement.node.options ).filter( isSelected );\n\n\t// If one of them had a `selected` attribute, we need to sync\n\t// the model to the view\n\tif ( parentElement.getAttribute( 'multiple' ) ) {\n\t\tvalue = selectedOptions.map( o => o.value );\n\t} else if ( option = selectedOptions[0] ) {\n\t\tvalue = option.value;\n\t}\n\n\tif ( value !== undefined ) {\n\t\tparentElement.binding.setValue( value );\n\t}\n\n\tparentElement.bubble();\n}\n\nfunction isSelected ( option ) {\n\treturn option.selected;\n}\n","import insertHtml from 'virtualdom/items/Triple/helpers/insertHtml';\nimport updateSelect from 'virtualdom/items/Triple/helpers/updateSelect';\n\nexport default function Triple$render () {\n\tif ( this.rendered ) {\n\t\tthrow new Error( 'Attempted to render an item that was already rendered' );\n\t}\n\n\tthis.docFrag = document.createDocumentFragment();\n\tthis.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );\n\n\t// Special case - we're inserting the contents of a <select>\n\tupdateSelect( this.pElement );\n\n\tthis.rendered = true;\n\treturn this.docFrag;\n}\n","import runloop from 'global/runloop';\n\nexport default function Triple$setValue ( value ) {\n\tvar wrapper;\n\n\t// TODO is there a better way to approach this?\n\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) {\n\t\tvalue = wrapper.get();\n\t}\n\n\tif ( value !== this.value ) {\n\t\tthis.value = value;\n\t\tthis.parentFragment.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n}\n","import { decodeCharacterReferences } from 'utils/html';\n\nexport default function Triple$toString () {\n\treturn ( this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '' );\n}\n","import { detachNode } from 'utils/dom';\n\nexport default function Triple$unrender ( shouldDestroy ) {\n\tif ( this.rendered && shouldDestroy ) {\n\t\tthis.nodes.forEach( detachNode );\n\t\tthis.rendered = false;\n\t}\n\n\t// TODO update live queries\n}\n","import insertHtml from 'virtualdom/items/Triple/helpers/insertHtml';\nimport updateSelect from 'virtualdom/items/Triple/helpers/updateSelect';\n\nexport default function Triple$update () {\n\tvar node, parentNode;\n\n\tif ( !this.rendered ) {\n\t\treturn;\n\t}\n\n\t// Remove existing nodes\n\twhile ( this.nodes && this.nodes.length ) {\n\t\tnode = this.nodes.pop();\n\t\tnode.parentNode.removeChild( node );\n\t}\n\n\t// Insert new nodes\n\tparentNode = this.parentFragment.getNode();\n\n\tthis.nodes = insertHtml( this.value, parentNode, this.docFrag );\n\tparentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\n\n\t// Special case - we're inserting the contents of a <select>\n\tupdateSelect( this.pElement );\n}\n","export default function Element$detach () {\n\tvar node = this.node, parentNode;\n\n\tif ( node ) {\n\t\t// need to check for parent node - DOM may have been altered\n\t\t// by something other than Ractive! e.g. jQuery UI...\n\t\tif ( parentNode = node.parentNode ) {\n\t\t\tparentNode.removeChild( node );\n\t\t}\n\n\t\treturn node;\n\t}\n}\n","export default function Element$findNextNode () {\n\treturn null;\n}\n","export default function Element$firstNode () {\n\treturn this.node;\n}\n","export default function Element$getAttribute ( name ) {\n\tif ( !this.attributes || !this.attributes[ name ] ) {\n\t\treturn;\n\t}\n\n\treturn this.attributes[ name ].value;\n}\n","import runloop from 'global/runloop';\nimport { isEqual } from 'utils/is';\n\nexport default function Attribute$bubble () {\n\tvar value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n\t// TODO this can register the attribute multiple times (see render test\n\t// 'Attribute with nested mustaches')\n\tif ( !isEqual( value, this.value ) ) {\n\n\t\t// Need to clear old id from ractive.nodes\n\t\tif ( this.name === 'id' && this.value ) {\n\t\t\tdelete this.root.nodes[ this.value ];\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tif ( this.name === 'value' && this.node ) {\n\t\t\t// We need to store the value on the DOM like this so we\n\t\t\t// can retrieve it later without it being coerced to a string\n\t\t\tthis.node._ractive.value = value;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n}\n","import { INTERPOLATOR } from 'config/types';\n\nexport default function getInterpolator ( attribute ) {\n\tvar items = attribute.fragment.items;\n\n\tif ( items.length !== 1 ) {\n\t\treturn;\n\t}\n\n\tif ( items[0].type === INTERPOLATOR ) {\n\t\treturn items[0];\n\t}\n}\n","import { ATTRIBUTE } from 'config/types';\nimport { booleanAttributes } from 'utils/html';\nimport determineNameAndNamespace from '../helpers/determineNameAndNamespace';\nimport getInterpolator from '../helpers/getInterpolator';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Attribute$init ( options ) {\n\tthis.type = ATTRIBUTE;\n\tthis.element = options.element;\n\tthis.root = options.root;\n\n\tdetermineNameAndNamespace( this, options.name );\n\tthis.isBoolean = booleanAttributes.test( this.name );\n\n\t// if it's an empty attribute, or just a straight key-value pair, with no\n\t// mustache shenanigans, set the attribute accordingly and go home\n\tif ( !options.value || typeof options.value === 'string' ) {\n\t\tthis.value = this.isBoolean ? true : options.value || '';\n\t\treturn;\n\t}\n\n\t// otherwise we need to do some work\n\n\t// share parentFragment with parent element\n\tthis.parentFragment = this.element.parentFragment;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: options.value,\n\t\troot:     this.root,\n\t\towner:    this\n\t});\n\n\t// TODO can we use this.fragment.toString() in some cases? It's quicker\n\tthis.value = this.fragment.getValue();\n\n\t// Store a reference to this attribute's interpolator, if its fragment\n\t// takes the form `{{foo}}`. This is necessary for two-way binding and\n\t// for correctly rendering HTML later\n\tthis.interpolator = getInterpolator( this );\n\tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n\t// mark as ready\n\tthis.ready = true;\n}\n","export default function Attribute$rebind ( oldKeypath, newKeypath ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { namespaces } from 'config/environment';\n\n// the property name equivalents for element attributes, where they differ\n// from the lowercased attribute name\nvar propertyNames = {\n\t'accept-charset': 'acceptCharset',\n\t'accesskey': 'accessKey',\n\t'bgcolor': 'bgColor',\n\t'class': 'className',\n\t'codebase': 'codeBase',\n\t'colspan': 'colSpan',\n\t'contenteditable': 'contentEditable',\n\t'datetime': 'dateTime',\n\t'dirname': 'dirName',\n\t'for': 'htmlFor',\n\t'http-equiv': 'httpEquiv',\n\t'ismap': 'isMap',\n\t'maxlength': 'maxLength',\n\t'novalidate': 'noValidate',\n\t'pubdate': 'pubDate',\n\t'readonly': 'readOnly',\n\t'rowspan': 'rowSpan',\n\t'tabindex': 'tabIndex',\n\t'usemap': 'useMap'\n};\n\nexport default function Attribute$render ( node ) {\n\tvar propertyName;\n\n\tthis.node = node;\n\n\t// should we use direct property access, or setAttribute?\n\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\n\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\tthis.propertyName = propertyName;\n\t\t}\n\n\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\tif ( this.isBoolean || this.isTwoway ) {\n\t\t\tthis.useProperty = true;\n\t\t}\n\n\t\tif ( propertyName === 'value' ) {\n\t\t\tnode._ractive.value = this.value;\n\t\t}\n\t}\n\n\tthis.rendered = true;\n\tthis.update();\n}\n","export default function Attribute$toString () {\n\tvar { name, namespacePrefix, value, interpolator, fragment } = this;\n\n\t// Special case - select and textarea values (should not be stringified)\n\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\treturn;\n\t}\n\n\t// Special case - content editable\n\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\treturn;\n\t}\n\n\t// Special case - radio names\n\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\treturn 'name={{' + ( interpolator.keypath.str || interpolator.ref ) + '}}';\n\t}\n\n\t// Boolean attributes\n\tif ( this.isBoolean ) {\n\t\treturn value ? name : '';\n\t}\n\n\tif ( fragment ) {\n\t\tvalue = fragment.toString();\n\t}\n\n\tif ( namespacePrefix ) {\n\t\tname = namespacePrefix + ':' + name;\n\t}\n\n\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n}\n\nfunction escape ( value ) {\n\treturn value\n\t\t.replace( /&/g, '&amp;' )\n\t\t.replace( /\"/g, '&quot;' )\n\t\t.replace( /'/g, '&#39;' );\n}\n","export default function Attribute$unbind () {\n\t// ignore non-dynamic attributes\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.name === 'id' ) {\n\t\tdelete this.root.nodes[ this.value ];\n\t}\n}\n","export default function Attribute$updateSelect () {\n\tvar value = this.value, options, option, optionValue, i;\n\n\tif ( !this.locked ) {\n\t\tthis.node._ractive.value = value;\n\n\t\toptions = this.node.options;\n\t\ti = options.length;\n\n\t\twhile ( i-- ) {\n\t\t\toption = options[i];\n\t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t\t\t\toption.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if we're still here, it means the new value didn't match any of the options...\n\t// TODO figure out what to do in this situation\n}\n","import { arrayContains } from 'utils/array';\nimport { isArray } from 'utils/is';\n\nexport default function Attribute$updateMultipleSelect () {\n\tvar value = this.value, options, i, option, optionValue;\n\n\tif ( !isArray( value ) ) {\n\t\tvalue = [ value ];\n\t}\n\n\toptions = this.node.options;\n\ti = options.length;\n\n\twhile ( i-- ) {\n\t\toption = options[i];\n\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\t\toption.selected = arrayContains( value, optionValue );\n\t}\n}\n","export default function Attribute$updateRadioName () {\n\tvar { node, value } = this;\n\tnode.checked = ( value == node._ractive.value );\n}\n","import runloop from 'global/runloop';\n\nexport default function Attribute$updateRadioValue () {\n\tvar wasChecked, node = this.node, binding, bindings, i;\n\n\twasChecked = node.checked;\n\n\tnode.value = this.element.getAttribute( 'value' );\n\tnode.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );\n\n\t// This is a special case - if the input was checked, and the value\n\t// changed so that it's no longer checked, the twoway binding is\n\t// most likely out of date. To fix it we have to jump through some\n\t// hoops... this is a little kludgy but it works\n\tif ( wasChecked && !node.checked && this.element.binding ) {\n\t\tbindings = this.element.binding.siblings;\n\n\t\tif ( i = bindings.length ) {\n\t\t\twhile ( i-- ) {\n\t\t\t\tbinding = bindings[i];\n\n\t\t\t\tif ( !binding.element.node ) {\n\t\t\t\t\t// this is the initial render, siblings are still rendering!\n\t\t\t\t\t// we'll come back later...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( binding.element.node.checked ) {\n\t\t\t\t\trunloop.addViewmodel( binding.root.viewmodel );\n\t\t\t\t\treturn binding.handleChange();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.root.viewmodel.set( binding.keypath, undefined );\n\t\t}\n\t}\n}\n","import { isArray } from 'utils/is';\n\nexport default function Attribute$updateCheckboxName () {\n\tvar { element, node, value } = this, { binding } = element, valueAttribute, i;\n\n\tvalueAttribute = element.getAttribute( 'value' );\n\n\tif ( !isArray( value ) ) {\n\t\tbinding.isChecked = node.checked = ( value == valueAttribute );\n\t} else {\n\t\ti = value.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( valueAttribute == value[i] ) {\n\t\t\t\tbinding.isChecked = node.checked = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbinding.isChecked = node.checked = false;\n\t}\n}\n","export default function Attribute$updateClassName () {\n\tvar node, value;\n\n\tnode = this.node;\n\tvalue = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tnode.className = value;\n}\n","export default function Attribute$updateIdAttribute () {\n\tvar { node, value } = this;\n\n\tthis.root.nodes[ value ] = node;\n\tnode.id = value;\n}\n","export default function Attribute$updateIEStyleAttribute () {\n\tvar node, value;\n\n\tnode = this.node;\n\tvalue = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tnode.style.setAttribute( 'cssText', value );\n}\n","export default function Attribute$updateContentEditableValue () {\n\tvar value = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tif ( !this.locked ) {\n\t\tthis.node.innerHTML = value;\n\t}\n}\n","export default function Attribute$updateValue () {\n\tvar { node, value } = this;\n\n\t// store actual value, so it doesn't get coerced to a string\n\tnode._ractive.value = value;\n\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tnode.value = ( value == undefined ? '' : value );\n\t}\n}\n","export default function Attribute$updateBooleanAttribute () {\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tthis.node[ this.propertyName ] = this.value;\n\t}\n}\n","export default function Attribute$updateEverythingElse () {\n\tvar { node, namespace, name, value, fragment } = this;\n\n\tif ( namespace ) {\n\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t}\n\n\telse if ( !this.isBoolean ) {\n\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t}\n\n\t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n\telse {\n\t\tif ( value ) {\n\t\t\tnode.setAttribute( name, '' );\n\t\t} else {\n\t\t\tnode.removeAttribute( name );\n\t\t}\n\t}\n}\n","import { namespaces } from 'config/environment';\nimport noop from 'utils/noop';\n\nimport updateSelectValue from './update/updateSelectValue';\nimport updateMultipleSelectValue from './update/updateMultipleSelectValue';\nimport updateRadioName from './update/updateRadioName';\nimport updateRadioValue from './update/updateRadioValue';\nimport updateCheckboxName from './update/updateCheckboxName';\nimport updateClassName from './update/updateClassName';\nimport updateIdAttribute from './update/updateIdAttribute';\nimport updateIEStyleAttribute from './update/updateIEStyleAttribute';\nimport updateContentEditableValue from './update/updateContentEditableValue';\nimport updateValue from './update/updateValue';\nimport updateBoolean from './update/updateBoolean';\nimport updateEverythingElse from './update/updateEverythingElse';\n\n// There are a few special cases when it comes to updating attributes. For this reason,\n// the prototype .update() method points to this method, which waits until the\n// attribute has finished initialising, then replaces the prototype method with a more\n// suitable one. That way, we save ourselves doing a bunch of tests on each call\nexport default function Attribute$update () {\n\tvar { name, element, node } = this, type, updateMethod;\n\n\tif ( name === 'id' ) {\n\t\tupdateMethod = updateIdAttribute;\n\t}\n\n\telse if ( name === 'value' ) {\n\t\t// special case - selects\n\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\tupdateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t}\n\n\t\telse if ( element.name === 'textarea' ) {\n\t\t\tupdateMethod = updateValue;\n\t\t}\n\n\t\t// special case - contenteditable\n\t\telse if ( element.getAttribute( 'contenteditable' ) != null ) {\n\t\t\tupdateMethod = updateContentEditableValue;\n\t\t}\n\n\t\t// special case - <input>\n\t\telse if ( element.name === 'input' ) {\n\t\t\ttype = element.getAttribute( 'type' );\n\n\t\t\t// type='file' value='{{fileList}}'>\n\t\t\tif ( type === 'file' ) {\n\t\t\t\tupdateMethod = noop; // read-only\n\t\t\t}\n\n\t\t\t// type='radio' name='{{twoway}}'\n\t\t\telse if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {\n\t\t\t\tupdateMethod = updateRadioValue;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tupdateMethod = updateValue;\n\t\t\t}\n\t\t}\n\t}\n\n\t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n\telse if ( this.isTwoway && name === 'name' ) {\n\t\tif ( node.type === 'radio' ) {\n\t\t\tupdateMethod = updateRadioName;\n\t\t}\n\n\t\telse if ( node.type === 'checkbox' ) {\n\t\t\tupdateMethod = updateCheckboxName;\n\t\t}\n\t}\n\n\t// special case - style attributes in Internet Exploder\n\telse if ( name === 'style' && node.style.setAttribute ) {\n\t\tupdateMethod = updateIEStyleAttribute;\n\t}\n\n\t// special case - class names. IE fucks things up, again\n\telse if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {\n\t\tupdateMethod = updateClassName;\n\t}\n\n\telse if ( this.useProperty ) {\n\t\tupdateMethod = updateBoolean;\n\t}\n\n\tif ( !updateMethod ) {\n\t\tupdateMethod = updateEverythingElse;\n\t}\n\n\tthis.update = updateMethod;\n\tthis.update();\n}\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport { toArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\n\nvar div;\n\nif ( typeof document !== 'undefined' ) {\n\tdiv = createElement( 'div' );\n}\n\nvar ConditionalAttribute = function ( element, template ) {\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\n\tthis.attributes = [];\n\n\tthis.fragment = new Fragment({\n\t\troot: element.root,\n\t\towner: this,\n\t\ttemplate: [ template ]\n\t});\n};\n\nConditionalAttribute.prototype = {\n\tbubble: function () {\n\t\tif ( this.node ) {\n\t\t\tthis.update();\n\t\t}\n\n\t\tthis.element.bubble();\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\trender: function ( node ) {\n\t\tthis.node = node;\n\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n\t\tthis.update();\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tupdate: function () {\n\t\tvar str, attrs;\n\n\t\tstr = this.fragment.toString();\n\t\tattrs = parseAttributes( str, this.isSvg );\n\n\t\t// any attributes that previously existed but no longer do\n\t\t// must be removed\n\t\tthis.attributes.filter( a => notIn( attrs, a ) ).forEach( a => {\n\t\t\tthis.node.removeAttribute( a.name );\n\t\t});\n\n\t\tattrs.forEach( a => {\n\t\t\tthis.node.setAttribute( a.name, a.value );\n\t\t});\n\n\t\tthis.attributes = attrs;\n\t},\n\n\ttoString: function () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default ConditionalAttribute;\n\n\nfunction parseAttributes ( str, isSvg ) {\n\tvar tag = isSvg ? 'svg' : 'div';\n\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\n\treturn toArray( div.childNodes[0].attributes );\n}\n\nfunction notIn ( haystack, needle ) {\n\tvar i = haystack.length;\n\n\twhile ( i-- ) {\n\t\tif ( haystack[i].name === needle.name ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","import runloop from 'global/runloop';\nimport { warn } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { removeFromArray } from 'utils/array';\n\nvar Binding = function ( element ) {\n\tvar interpolator, keypath, value, parentForm;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.attribute = element.attributes[ this.name || 'value' ];\n\n\tinterpolator = this.attribute.interpolator;\n\tinterpolator.twowayBinding = this;\n\n\tif ( keypath = interpolator.keypath ) {\n\t\tif ( keypath.str.slice( -1 ) === '}' ) {\n\t\t\twarn( 'Two-way binding does not work with expressions (`%s` on <%s>)', interpolator.resolver.uniqueString, element.name );\n\t\t\treturn false;\n\t\t}\n\t}\n\n\telse {\n\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t//\n\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t// assumption. That assumption is that the input in question should\n\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t// and not `foo.bar`.\n\t\t//\n\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\tinterpolator.resolver.forceResolution();\n\t\tkeypath = interpolator.keypath;\n\t}\n\n\tthis.attribute.isTwoway = true;\n\tthis.keypath = keypath;\n\n\t// initialise value, if it's undefined\n\tvalue = this.root.viewmodel.get( keypath );\n\n\tif ( value === undefined && this.getInitialValue ) {\n\t\tvalue = this.getInitialValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t}\n\t}\n\n\tif ( parentForm = findParentForm( element ) ) {\n\t\tthis.resetValue = value;\n\t\tparentForm.formBindings.push( this );\n\t}\n};\n\nBinding.prototype = {\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\t\tthis.attribute.locked = true;\n\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\trunloop.end();\n\t},\n\n\trebound: function () {\n\t\tvar bindings, oldKeypath, newKeypath;\n\n\t\toldKeypath = this.keypath;\n\t\tnewKeypath = this.attribute.interpolator.keypath;\n\n\t\t// The attribute this binding is linked to has already done the work\n\t\tif ( oldKeypath === newKeypath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath.str ], this );\n\n\t\tthis.keypath = newKeypath;\n\n\t\tbindings = this.root._twowayBindings[ newKeypath.str ] || ( this.root._twowayBindings[ newKeypath.str ] = [] );\n\t\tbindings.push( this );\n\t},\n\n\tunbind: function () {\n\t\t// this is called when the element is unbound.\n\t\t// Specialised bindings can override it\n\t}\n};\n\nBinding.extend = function ( properties ) {\n\tvar Parent = this, SpecialisedBinding;\n\n\tSpecialisedBinding = function ( element ) {\n\t\tBinding.call( this, element );\n\n\t\tif ( this.init ) {\n\t\t\tthis.init();\n\t\t}\n\t};\n\n\tSpecialisedBinding.prototype = create( Parent.prototype );\n\textend( SpecialisedBinding.prototype, properties );\n\n\tSpecialisedBinding.extend = Binding.extend;\n\n\treturn SpecialisedBinding;\n};\n\nexport default Binding;\n\nfunction findParentForm ( element ) {\n\twhile ( element = element.parent ) {\n\t\tif ( element.name === 'form' ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n","// This is the handler for DOM events that would lead to a change in the model\n// (i.e. change, sometimes, input, and occasionally click and keyup)\nexport default function handleChange () {\n\tthis._ractive.binding.handleChange();\n}\n","var sets = {};\n\nexport default function getSiblings ( id, group, keypath ) {\n\tvar hash = id + group + keypath;\n\treturn sets[ hash ] || ( sets[ hash ] = [] );\n}\n","import { isArray } from 'utils/is';\nimport { arrayContains, removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxNameBinding = Binding.extend({\n\tname: 'name',\n\n\tgetInitialValue: function () {\n\t\t// This only gets called once per group (of inputs that\n\t\t// share a name), because it only gets called if there\n\t\t// isn't an initial value. By the same token, we can make\n\t\t// a note of that fact that there was no initial value,\n\t\t// and populate it using any `checked` attributes that\n\t\t// exist (which users should avoid, but which we should\n\t\t// support anyway to avoid breaking expectations)\n\t\tthis.noInitialValue = true;\n\t\treturn [];\n\t},\n\n\tinit: function () {\n\t\tvar existingValue, bindingValue;\n\n\t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n\t\t// Each input has a reference to an array containing it and its\n\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t// the status of all inputs within the group\n\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tif ( this.noInitialValue ) {\n\t\t\tthis.siblings.noInitialValue = true;\n\t\t}\n\n\t\t// If no initial value was set, and this input is checked, we\n\t\t// update the model\n\t\tif ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\t\texistingValue.push( bindingValue );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, existingValue, bindingValue;\n\n\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\tif ( isArray( existingValue ) ) {\n\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t} else {\n\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t}\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.isChecked;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t// in case of IE emergency, bind to click event as well\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tchanged: function () {\n\t\tvar wasChecked = !!this.isChecked;\n\t\tthis.isChecked = this.element.node.checked;\n\t\treturn this.isChecked === wasChecked;\n\t},\n\n\thandleChange: function () {\n\t\tthis.isChecked = this.element.node.checked;\n\t\tBinding.prototype.handleChange.call( this );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t}\n});\n\nfunction isChecked ( binding ) {\n\treturn binding.isChecked;\n}\n\nfunction getValue ( binding ) {\n\treturn binding.element.getAttribute( 'value' );\n}\n\nexport default CheckboxNameBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport { isNumeric } from 'utils/is';\n\nvar GenericBinding;\n\nGenericBinding = Binding.extend({\n\tgetInitialValue: () => '',\n\n\tgetValue: function () {\n\t\treturn this.element.node.value;\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, lazy, timeout = false;\n\t\tthis.rendered = true;\n\n\t\t// any lazy setting for this element overrides the root\n\t\t// if the value is a number, it's a timeout\n\t\tlazy = this.root.lazy;\n\t\tif ( this.element.lazy === true ) {\n\t\t\tlazy = true;\n\t\t} else if ( this.element.lazy === false ) {\n\t\t\tlazy = false;\n\t\t} else if ( isNumeric( this.element.lazy ) ) {\n\t\t\tlazy = false;\n\t\t\ttimeout = +this.element.lazy;\n\t\t} else if ( isNumeric( ( lazy || '' ) ) ) {\n\t\t\ttimeout = +lazy;\n\t\t\tlazy = false;\n\n\t\t\t// make sure the timeout is available to the handler\n\t\t\tthis.element.lazy = timeout;\n\t\t}\n\n\t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( !lazy ) {\n\t\t\tnode.addEventListener( 'input', this.handler, false );\n\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t\t\t}\n\t\t}\n\n\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\t\tthis.rendered = false;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'input', this.handler, false );\n\t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t}\n});\n\nexport default GenericBinding;\n\n\nfunction handleBlur () {\n\tvar value;\n\n\thandleDomEvent.call( this );\n\n\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath );\n\tthis.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay () {\n\tvar binding = this._ractive.binding, el = this;\n\n\tif ( !!binding._timeout ) clearTimeout( binding._timeout );\n\n\tbinding._timeout = setTimeout( () => {\n\t\tif ( binding.rendered ) handleDomEvent.call( el );\n\t\tbinding._timeout = undefined;\n\t}, binding.element.lazy );\n}\n","import { warn } from 'utils/log';\nimport ContentEditableBinding from '../../Binding/ContentEditableBinding';\nimport RadioBinding from '../../Binding/RadioBinding';\nimport RadioNameBinding from '../../Binding/RadioNameBinding';\nimport CheckboxNameBinding from '../../Binding/CheckboxNameBinding';\nimport CheckboxBinding from '../../Binding/CheckboxBinding';\nimport SelectBinding from '../../Binding/SelectBinding';\nimport MultipleSelectBinding from '../../Binding/MultipleSelectBinding';\nimport FileListBinding from '../../Binding/FileListBinding';\nimport NumericBinding from '../../Binding/NumericBinding';\nimport GenericBinding from '../../Binding/GenericBinding';\n\nexport default function createTwowayBinding ( element ) {\n\tvar attributes = element.attributes, type, Binding, bindName, bindChecked, binding;\n\n\t// if this is a late binding, and there's already one, it\n\t// needs to be torn down\n\tif ( element.binding ) {\n\t\telement.binding.teardown();\n\t\telement.binding = null;\n\t}\n\n\t// contenteditable\n\tif (\n\t\t// if the contenteditable attribute is true or is bindable and may thus become true\n\t\t( element.getAttribute( 'contenteditable' ) || ( !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) )\n\t\t// and this element also has a value attribute to bind\n\t\t&& isBindable( attributes.value )\n\t) {\n\t\tBinding = ContentEditableBinding;\n\t}\n\n\t// <input>\n\telse if ( element.name === 'input' ) {\n\t\ttype = element.getAttribute( 'type' );\n\n\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\tbindName = isBindable( attributes.name );\n\t\t\tbindChecked = isBindable( attributes.checked );\n\n\t\t\t// we can either bind the name attribute, or the checked attribute - not both\n\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\twarn( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both' );\n\t\t\t}\n\n\t\t\tif ( bindName ) {\n\t\t\t\tBinding = ( type === 'radio' ? RadioNameBinding : CheckboxNameBinding );\n\t\t\t}\n\n\t\t\telse if ( bindChecked ) {\n\t\t\t\tBinding = ( type === 'radio' ? RadioBinding : CheckboxBinding );\n\t\t\t}\n\t\t}\n\n\t\telse if ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\tBinding = FileListBinding;\n\t\t}\n\n\t\telse if ( isBindable( attributes.value ) ) {\n\t\t\tBinding = ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;\n\t\t}\n\t}\n\n\t// <select>\n\telse if ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\tBinding = ( element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding );\n\t}\n\n\t// <textarea>\n\telse if ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\tBinding = GenericBinding;\n\t}\n\n\tif ( Binding && ( binding = new Binding( element ) ) && binding.keypath ) {\n\t\treturn binding;\n\t}\n}\n\nfunction isBindable ( attribute ) {\n\treturn attribute && attribute.isBindable;\n}\n","export default function EventHandler$bubble () {\n\tvar hasAction = this.getAction();\n\n\tif( hasAction && !this.hasListener ) {\n\t\tthis.listen();\n\t}\n\telse if ( !hasAction && this.hasListener ) {\n\t\tthis.unrender();\n\t}\n}\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\n\n// This function may be overwritten, if the event directive\n// includes parameters\nexport default function EventHandler$fire ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event } );\n}\n","export default function EventHandler$getAction () {\n\treturn this.action.toString().trim();\n}\n","import getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport Fragment from 'virtualdom/Fragment';\nimport eventStack from 'Ractive/prototype/shared/eventStack';\nimport fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { fatal, warn } from 'utils/log';\n\nvar eventPattern = /^event(?:\\.(.+))?/;\n\nexport default function EventHandler$init ( element, name, template ) {\n\tvar action, refs, ractive;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\tthis.name = name;\n\n\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\t( this.root.debug ? fatal : warn )( 'Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid', element.name, name );\n\t\tthis.invalid = true;\n\t}\n\n\tif ( template.m ) {\n\t\trefs = template.a.r;\n\n\t\t// This is a method call\n\t\tthis.method = template.m;\n\t\tthis.keypaths = [];\n\t\tthis.fn = getFunctionFromString( template.a.s, refs.length );\n\n\t\tthis.parentFragment = element.parentFragment;\n\t\tractive = this.root;\n\n\t\t// Create resolvers for each reference\n\t\tthis.refResolvers = [];\n\t\trefs.forEach(( ref, i ) => {\n\t\t\tlet match;\n\n\t\t\t// special case - the `event` object\n\t\t\tif ( match = eventPattern.exec( ref ) ) {\n\t\t\t\tthis.keypaths[i] = {\n\t\t\t\t\teventObject: true,\n\t\t\t\t\trefinements: match[1] ? match[1].split( '.' ) : []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.refResolvers.push( createReferenceResolver( this, ref, keypath => this.resolve( i, keypath ) ) );\n\t\t\t}\n\t\t});\n\n\t\tthis.fire = fireMethodCall;\n\t}\n\n\telse {\n\t\t// Get action ('foo' in 'on-click='foo')\n\t\taction = template.n || template;\n\t\tif ( typeof action !== 'string' ) {\n\t\t\taction = new Fragment({\n\t\t\t\ttemplate: action,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tthis.action = action;\n\n\t\t// Get parameters\n\t\tif ( template.d ) {\n\t\t\tthis.dynamicParams = new Fragment({\n\t\t\t\ttemplate: template.d,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this.element\n\t\t\t});\n\n\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t} else if ( template.a ) {\n\t\t\tthis.params = template.a;\n\t\t\tthis.fire = fireEventWithParams;\n\t\t}\n\t}\n}\n\n\nfunction fireMethodCall ( event ) {\n\tvar ractive, values, args;\n\n\tractive = this.root;\n\n\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t}\n\n\tvalues = this.keypaths.map( function ( keypath ) {\n\t\tvar value, len, i;\n\n\t\tif ( keypath === undefined ) {\n\t\t\t// not yet resolved\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// TODO the refinements stuff would be better handled at parse time\n\t\tif ( keypath.eventObject ) {\n\t\t\tvalue = event;\n\n\t\t\tif ( len = keypath.refinements.length ) {\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvalue = value[ keypath.refinements[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t}\n\n\t\treturn value;\n\t});\n\n\teventStack.enqueue( ractive, event );\n\n\targs = this.fn.apply( null, values );\n\tractive[ this.method ].apply( ractive, args );\n\n\teventStack.dequeue( ractive );\n}\n\nfunction fireEventWithParams ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event, args: this.params } );\n}\n\nfunction fireEventWithDynamicParams ( event ) {\n\tvar args = this.dynamicParams.getArgsList();\n\n\t// need to strip [] from ends if a string!\n\tif ( typeof args === 'string' ) {\n\t\targs = args.substr( 1, args.length - 2 );\n\t}\n\n\tfireEvent( this.root, this.getAction(), { event: event, args: args } );\n}\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function genericHandler ( event ) {\n\tvar storage, handler, indices, index = {};\n\n\tstorage = this._ractive;\n\thandler = storage.events[ event.type ];\n\n\tif ( indices = findIndexRefs( handler.element.parentFragment ) ) {\n\t\tindex = findIndexRefs.resolve( indices );\n\t}\n\n\thandler.fire({\n\t\tnode: this,\n\t\toriginal: event,\n\t\tindex: index,\n\t\tkeypath: storage.keypath.str,\n\t\tcontext: storage.root.viewmodel.get( storage.keypath )\n\t});\n}\n","import { warnOnce } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport genericHandler from '../shared/genericHandler';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar customHandlers = {},\n\ttouchEvents = {\n\t\ttouchstart: true,\n\t\ttouchmove: true,\n\t\ttouchend: true,\n\t\ttouchcancel: true,\n\t\t//not w3c, but supported in some browsers\n\t\ttouchleave: true\n\t};\n\nexport default function EventHandler$listen () {\n\n\tvar definition, name = this.name;\n\n\tif ( this.invalid ) { return; }\n\n\tif ( definition = findInViewHierarchy( 'events', this.root, name ) ) {\n\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t} else {\n\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {\n\n\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\twarnOnce( missingPlugin( name, 'event' ) );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.node.addEventListener( name, genericHandler, false );\n\t}\n\n\tthis.hasListener = true;\n\n}\n\nfunction getCustomHandler ( name ) {\n\tif ( !customHandlers[ name ] ) {\n\t\tcustomHandlers[ name ] = function ( event ) {\n\t\t\tvar storage = event.node._ractive;\n\n\t\t\tevent.index = storage.index;\n\t\t\tevent.keypath = storage.keypath.str;\n\t\t\tevent.context = storage.root.viewmodel.get( storage.keypath );\n\n\t\t\tstorage.events[ name ].fire( event );\n\t\t};\n\t}\n\n\treturn customHandlers[ name ];\n}\n","export default function EventHandler$rebind ( oldKeypath, newKeypath ) {\n\tvar fragment;\n\tif ( this.method ) {\n\t\tfragment = this.element.parentFragment;\n\t\tthis.refResolvers.forEach( rebind );\n\n\t\treturn;\n\t}\n\n\tif ( typeof this.action !== 'string' ) {\n\t\trebind( this.action );\n\t}\n\n\tif ( this.dynamicParams ) {\n\t\trebind( this.dynamicParams );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing && thing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function EventHandler$render () {\n\tthis.node = this.element.node;\n\t// store this on the node itself, so it can be retrieved by a\n\t// universal handler\n\tthis.node._ractive.events[ this.name ] = this;\n\n\tif ( this.method || this.getAction() ) {\n\t\tthis.listen();\n\t}\n}\n","export default function EventHandler$resolve ( index, keypath ) {\n\tthis.keypaths[ index ] = keypath;\n}\n","import { unbind } from 'shared/methodCallers';\n\nexport default function EventHandler$unbind () {\n\tif ( this.method ) {\n\t\tthis.refResolvers.forEach( unbind );\n\t\treturn;\n\t}\n\n\t// Tear down dynamic name\n\tif ( typeof this.action !== 'string' ) {\n\t\tthis.action.unbind();\n\t}\n\n\t// Tear down dynamic parameters\n\tif ( this.dynamicParams ) {\n\t\tthis.dynamicParams.unbind();\n\t}\n}\n","import genericHandler from '../shared/genericHandler';\n\nexport default function EventHandler$unrender () {\n\n\tif ( this.custom ) {\n\t\tthis.custom.teardown();\n\t}\n\n\telse {\n\t\tthis.node.removeEventListener( this.name, genericHandler, false );\n\t}\n\n\tthis.hasListener = false;\n\n}\n","import { toArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nexport function bubble () {\n\tif ( !this.dirty ) {\n\t\tthis.dirty = true;\n\n\t\trunloop.scheduleTask( () => {\n\t\t\tsync( this );\n\t\t\tthis.dirty = false;\n\t\t});\n\t}\n\n\tthis.parentFragment.bubble(); // default behaviour\n}\n\nfunction sync ( selectElement ) {\n\tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n\tselectNode = selectElement.node;\n\n\tif ( !selectNode ) {\n\t\treturn;\n\t}\n\n\toptions = toArray( selectNode.options );\n\n\tselectValue = selectElement.getAttribute( 'value' );\n\tisMultiple = selectElement.getAttribute( 'multiple' );\n\n\t// If the <select> has a specified value, that should override\n\t// these options\n\tif ( selectValue !== undefined ) {\n\t\toptions.forEach( o => {\n\t\t\tvar optionValue, shouldSelect;\n\n\t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\tshouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\n\t\t\tif ( shouldSelect ) {\n\t\t\t\toptionWasSelected = true;\n\t\t\t}\n\n\t\t\to.selected = shouldSelect;\n\t\t});\n\n\t\tif ( !optionWasSelected ) {\n\t\t\tif ( options[0] ) {\n\t\t\t\toptions[0].selected = true;\n\t\t\t}\n\n\t\t\tif ( selectElement.binding ) {\n\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Otherwise the value should be initialised according to which\n\t// <option> element is selected, if twoway binding is in effect\n\telse if ( selectElement.binding ) {\n\t\tselectElement.binding.forceUpdate();\n\t}\n}\n\nfunction valueContains ( selectValue, optionValue ) {\n\tvar i = selectValue.length;\n\twhile ( i-- ) {\n\t\tif ( selectValue[i] == optionValue ) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","import { removeFromArray } from 'utils/array';\n\nexport function init ( option, template ) {\n\toption.select = findParentSelect( option.parent );\n\n\t// we might be inside a <datalist> element\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\toption.select.options.push( option );\n\n\t// If the value attribute is missing, use the element's content\n\tif ( !template.a ) {\n\t\ttemplate.a = {};\n\t}\n\n\t// ...as long as it isn't disabled\n\tif ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {\n\t\ttemplate.a.value = template.f;\n\t}\n\n\t// If there is a `selected` attribute, but the <select>\n\t// already has a value, delete it\n\tif ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {\n\t\tdelete template.a.selected;\n\t}\n}\n\nexport function unbind ( option ) {\n\tif ( option.select ) {\n\t\tremoveFromArray( option.select.options, option );\n\t}\n}\n\nfunction findParentSelect ( element ) {\n\tif ( !element ) { return; }\n\n\tdo {\n\t\tif ( element.name === 'select' ) {\n\t\t\treturn element;\n\t\t}\n\t} while ( element = element.parent );\n}\n","import { ELEMENT } from 'config/types';\nimport processBindingAttributes from './init/processBindingAttributes';\nimport createAttributes from './init/createAttributes';\nimport createConditionalAttributes from './init/createConditionalAttributes';\nimport createTwowayBinding from './init/createTwowayBinding';\nimport createEventHandlers from './init/createEventHandlers';\nimport enforceCase from '../shared/enforceCase';\nimport Decorator from '../Decorator/_Decorator';\nimport { bubble as bubbleSelect } from '../special/select';\nimport { init as initOption } from '../special/option';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Element$init ( options ) {\n\tvar parentFragment,\n\t\ttemplate,\n\t\tractive,\n\t\tbinding,\n\t\tbindings,\n\t\ttwoway,\n\t\tbindingAttrs;\n\n\tthis.type = ELEMENT;\n\n\t// stuff we'll need later\n\tparentFragment = this.parentFragment = options.parentFragment;\n\ttemplate = this.template = options.template;\n\n\tthis.parent = options.pElement || parentFragment.pElement;\n\n\tthis.root = ractive = parentFragment.root;\n\tthis.index = options.index;\n\tthis.key = options.key;\n\n\tthis.name = enforceCase( template.e );\n\n\t// Special case - <option> elements\n\tif ( this.name === 'option' ) {\n\t\tinitOption( this, template );\n\t}\n\n\t// Special case - <select> elements\n\tif ( this.name === 'select' ) {\n\t\tthis.options = [];\n\t\tthis.bubble = bubbleSelect; // TODO this is a kludge\n\t}\n\n\t// Special case - <form> elements\n\tif ( this.name === 'form' ) {\n\t\tthis.formBindings = [];\n\t}\n\n\t// handle binding attributes first (twoway, lazy)\n\tbindingAttrs = processBindingAttributes( this, template );\n\n\t// create attributes\n\tthis.attributes = createAttributes( this, template.a );\n\tthis.conditionalAttributes = createConditionalAttributes( this, template.m );\n\n\t// append children, if there are any\n\tif ( template.f ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.f,\n\t\t\troot:     ractive,\n\t\t\towner:    this,\n\t\t\tpElement: this,\n\t\t});\n\t}\n\n\t// the element setting should override the ractive setting\n\ttwoway = ractive.twoway;\n\tif ( bindingAttrs.twoway === false ) twoway = false;\n\telse if ( bindingAttrs.twoway === true ) twoway = true;\n\n\tthis.twoway = twoway;\n\tthis.lazy = bindingAttrs.lazy;\n\n\t// create twoway binding\n\tif ( twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {\n\t\tthis.binding = binding;\n\n\t\t// register this with the root, so that we can do ractive.updateModel()\n\t\tbindings = this.root._twowayBindings[ binding.keypath.str ] || ( this.root._twowayBindings[ binding.keypath.str ] = [] );\n\t\tbindings.push( binding );\n\t}\n\n\t// create event proxies\n\tif ( template.v ) {\n\t\tthis.eventHandlers = createEventHandlers( this, template.v );\n\t}\n\n\t// create decorator\n\tif ( template.o ) {\n\t\tthis.decorator = new Decorator( this, template.o );\n\t}\n\n\t// create transitions\n\tthis.intro = template.t0 || template.t1;\n\tthis.outro = template.t0 || template.t2;\n}\n","import { assignNewKeypath } from 'shared/keypaths';\n\nexport default function Element$rebind ( oldKeypath, newKeypath ) {\n\tvar i, storage, liveQueries, ractive;\n\n\tif ( this.attributes ) {\n\t\tthis.attributes.forEach( rebind );\n\t}\n\n\tif ( this.conditionalAttributes ) {\n\t\tthis.conditionalAttributes.forEach( rebind );\n\t}\n\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( rebind );\n\t}\n\n\tif ( this.decorator ) {\n\t\trebind( this.decorator );\n\t}\n\n\t// rebind children\n\tif ( this.fragment ) {\n\t\trebind( this.fragment );\n\t}\n\n\t// Update live queries, if necessary\n\tif ( liveQueries = this.liveQueries ) {\n\t\tractive = this.root;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tliveQueries[i]._makeDirty();\n\t\t}\n\t}\n\n\tif ( this.node && ( storage = this.node._ractive ) ) {\n\n\t\t// adjust keypath if needed\n\t\tassignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export function render ( img ) {\n\tvar loadHandler;\n\n\t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n\t// from overriding width and height when it loads the src\n\tif ( img.attributes.width || img.attributes.height ) {\n\t\timg.node.addEventListener( 'load', loadHandler = function () {\n\t\t\tvar width = img.getAttribute( 'width' ),\n\t\t\t\theight = img.getAttribute( 'height' );\n\n\t\t\tif ( width !== undefined ) {\n\t\t\t\timg.node.setAttribute('width', width);\n\t\t\t}\n\n\t\t\tif ( height !== undefined ) {\n\t\t\t\timg.node.setAttribute('height', height);\n\t\t\t}\n\n\t\t\timg.node.removeEventListener( 'load', loadHandler, false );\n\t\t}, false );\n\t}\n}\n","import runloop from 'global/runloop';\n\nexport function render ( element ) {\n\telement.node.addEventListener( 'reset', handleReset, false);\n}\n\nexport function unrender ( element ) {\n\telement.node.removeEventListener( 'reset', handleReset, false);\n}\n\nfunction handleReset () {\n\tvar element = this._ractive.proxy;\n\n\trunloop.start();\n\telement.formBindings.forEach( updateModel );\n\trunloop.end();\n}\n\nfunction updateModel ( binding ) {\n\tbinding.root.viewmodel.set( binding.keypath, binding.resetValue );\n}","import { warnOnce } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nexport default function Transition$init ( element, template, isIntro ) {\n\tvar ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\tthis.isIntro = isIntro;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no transition\n\t\t\treturn;\n\t\t}\n\t}\n\n\tthis.name = name;\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t// 'dependency thrashing'?\n\t\tfragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = fragment.getArgsList();\n\t\tfragment.unbind();\n\t}\n\n\tthis._fn = findInViewHierarchy( 'transitions', ractive, name );\n\n\tif ( !this._fn ) {\n\t\twarnOnce( missingPlugin( name, 'transition' ) );\n\t}\n}\n","import { warnOnce } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport getTime from 'utils/getTime';\nimport animations from 'shared/animations';\n\n// TODO what happens if a transition is aborted?\n// TODO use this with Animation to dedupe some code?\n\nvar Ticker = function ( options ) {\n\tvar easing;\n\n\tthis.duration = options.duration;\n\tthis.step = options.step;\n\tthis.complete = options.complete;\n\n\t// easing\n\tif ( typeof options.easing === 'string' ) {\n\t\teasing = options.root.easing[ options.easing ];\n\n\t\tif ( !easing ) {\n\t\t\twarnOnce( missingPlugin( options.easing, 'easing' ) );\n\t\t\teasing = linear;\n\t\t}\n\t} else if ( typeof options.easing === 'function' ) {\n\t\teasing = options.easing;\n\t} else {\n\t\teasing = linear;\n\t}\n\n\tthis.easing = easing;\n\n\tthis.start = getTime();\n\tthis.end = this.start + this.duration;\n\n\tthis.running = true;\n\tanimations.add( this );\n};\n\nTicker.prototype = {\n\ttick: function ( now ) {\n\t\tvar elapsed, eased;\n\n\t\tif ( !this.running ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( now > this.end ) {\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( 1 );\n\t\t\t}\n\n\t\t\tif ( this.complete ) {\n\t\t\t\tthis.complete( 1 );\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\telapsed = now - this.start;\n\t\teased = this.easing( elapsed / this.duration );\n\n\t\tif ( this.step ) {\n\t\t\tthis.step( eased );\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tstop: function () {\n\t\tif ( this.abort ) {\n\t\t\tthis.abort();\n\t\t}\n\n\t\tthis.running = false;\n\t}\n};\n\nexport default Ticker;\nfunction linear ( t ) { return t; }\n","import { vendors } from 'config/environment';\n\nvar hidden, vendor, prefix, i, visibility;\n\nif ( typeof document !== 'undefined' ) {\n\thidden = 'hidden';\n\n\tvisibility = {};\n\n\tif ( hidden in document ) {\n\t\tprefix = '';\n\t} else {\n\t\ti = vendors.length;\n\t\twhile ( i-- ) {\n\t\t\tvendor = vendors[i];\n\t\t\thidden = vendor + 'Hidden';\n\n\t\t\tif ( hidden in document ) {\n\t\t\t\tprefix = vendor;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( prefix !== undefined ) {\n\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\n\t\t// initialise\n\t\tonChange();\n\t}\n\n\telse {\n        // gah, we're in an old browser\n        if ( 'onfocusout' in document ) {\n        \tdocument.addEventListener( 'focusout', onHide );\n        \tdocument.addEventListener( 'focusin', onShow );\n        }\n\n        else {\n        \twindow.addEventListener( 'pagehide', onHide );\n        \twindow.addEventListener( 'blur', onHide );\n\n        \twindow.addEventListener( 'pageshow', onShow );\n        \twindow.addEventListener( 'focus', onShow );\n        }\n\n        visibility.hidden = false; // until proven otherwise. Not ideal but hey\n    }\n}\n\nfunction onChange () {\n\tvisibility.hidden = document[ hidden ];\n}\n\nfunction onHide () {\n\tvisibility.hidden = true;\n}\n\nfunction onShow () {\n\tvisibility.hidden = false;\n}\n\nexport default visibility;\n","export default function Transition$start () {\n\tvar node, originalStyle, completed;\n\n\tnode = this.node = this.element.node;\n\toriginalStyle = node.getAttribute( 'style' );\n\n\t// create t.complete() - we don't want this on the prototype,\n\t// because we don't want `this` silliness when passing it as\n\t// an argument\n\tthis.complete = noReset => {\n\t\tif ( completed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !noReset && this.isIntro ) {\n\t\t\tresetStyle( node, originalStyle);\n\t\t}\n\n\t\tnode._ractive.transition = null;\n\t\tthis._manager.remove( this );\n\n\t\tcompleted = true;\n\t};\n\n\t// If the transition function doesn't exist, abort\n\tif ( !this._fn ) {\n\t\tthis.complete();\n\t\treturn;\n\t}\n\n\tthis._fn.apply( this.root, [ this ].concat( this.params ) );\n}\n\nfunction resetStyle ( node, style ) {\n\tif ( style ) {\n\t\tnode.setAttribute( 'style', style );\n\t} else {\n\n\t\t// Next line is necessary, to remove empty style attribute!\n\t\t// See http://stackoverflow.com/a/7167553\n\t\tnode.getAttribute( 'style' );\n\t\tnode.removeAttribute( 'style' );\n\t}\n}\n","import { namespaces } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport { warn } from 'utils/log';\nimport { create, defineProperty } from 'utils/object';\nimport { createElement } from 'utils/dom';\nimport noop from 'utils/noop';\nimport runloop from 'global/runloop';\nimport getInnerContext from 'shared/getInnerContext';\nimport { render as renderImage } from '../special/img';\nimport { render as renderForm } from '../special/form';\nimport Transition from '../Transition/_Transition';\n\nvar updateCss, updateScript;\n\nupdateCss = function () {\n\tvar node = this.node, content = this.fragment.toString( false );\n\n\t// IE8 has no styleSheet unless there's a type text/css\n\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\tnode.type = 'text/css';\n\t}\n\n\tif ( node.styleSheet ) {\n\t\tnode.styleSheet.cssText = content;\n\t} else {\n\n\t\twhile ( node.hasChildNodes() ) {\n\t\t\tnode.removeChild( node.firstChild );\n\t\t}\n\n\t\tnode.appendChild( document.createTextNode(content) );\n\t}\n};\n\nupdateScript = function () {\n\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\twarn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );\n\t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n\t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n\t\t// But this would be a terrible idea with unpredictable results, so let's not.\n\t}\n\n\tthis.node.text = this.fragment.toString( false );\n};\n\nexport default function Element$render () {\n\tvar root = this.root, namespace, node, transition;\n\n\tnamespace = getNamespace( this );\n\tnode = this.node = createElement( this.name, namespace );\n\n\t// Is this a top-level node of a component? If so, we may need to add\n\t// a data-ractive-css attribute, for CSS encapsulation\n\t// NOTE: css no longer copied to instance, so we check constructor.css -\n\t// we can enhance to handle instance, but this is more \"correct\" with current\n\t// functionality\n\tif ( root.constructor.css && this.parentFragment.getNode() === root.el ) {\n\t\tthis.node.setAttribute( 'data-ractive-css', root.constructor._guid /*|| root._guid*/ );\n\t}\n\n\t// Add _ractive property to the node - we use this object to store stuff\n\t// related to proxy events, two-way bindings etc\n\tdefineProperty( this.node, '_ractive', {\n\t\tvalue: {\n\t\t\tproxy: this,\n\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\tevents: create( null ),\n\t\t\troot: root\n\t\t}\n\t});\n\n\t// Render attributes\n\tthis.attributes.forEach( a => a.render( node ) );\n\tthis.conditionalAttributes.forEach( a => a.render( node ) );\n\n\t// Render children\n\tif ( this.fragment ) {\n\t\t// Special case - <script> element\n\t\tif ( this.name === 'script' ) {\n\t\t\tthis.bubble = updateScript;\n\t\t\tthis.node.text = this.fragment.toString( false ); // bypass warning initially\n\t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n\t\t}\n\n\t\t// Special case - <style> element\n\t\telse if ( this.name === 'style' ) {\n\t\t\tthis.bubble = updateCss;\n\t\t\tthis.bubble();\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\t// Special case - contenteditable\n\t\telse if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\telse {\n\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t}\n\t}\n\n\t// Add proxy event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( h => h.render() );\n\t}\n\n\t// deal with two-way bindings\n\tif ( this.binding ) {\n\t\tthis.binding.render();\n\t\tthis.node._ractive.binding = this.binding;\n\t}\n\n\tif ( this.name === 'option' ) {\n\t\tprocessOption( this );\n\t}\n\n\t// Special cases\n\tif ( this.name === 'img' ) {\n\t\t// if this is an <img>, and we're in a crap browser, we may\n\t\t// need to prevent it from overriding width and height when\n\t\t// it loads the src\n\t\trenderImage( this );\n\t} else if ( this.name === 'form' ) {\n\t\t// forms need to keep track of their bindings, in case of reset\n\t\trenderForm( this );\n\t} else if ( this.name === 'input' || this.name === 'textarea' ) {\n\t\t// inputs and textareas should store their initial value as\n\t\t// `defaultValue` in case of reset\n\t\tthis.node.defaultValue = this.node.value;\n\t} else if ( this.name === 'option' ) {\n\t\t// similarly for option nodes\n\t\tthis.node.defaultSelected = this.node.selected;\n\t}\n\n\t// apply decorator(s)\n\tif ( this.decorator && this.decorator.fn ) {\n\t\trunloop.scheduleTask( () => {\n\t\t\tif ( !this.decorator.torndown ) {\n\t\t\t\tthis.decorator.init();\n\t\t\t}\n\t\t}, true );\n\t}\n\n\t// trigger intro transition\n\tif ( root.transitionsEnabled && this.intro ) {\n\t\ttransition = new Transition ( this, this.intro, true );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start(), true );\n\n\t\tthis.transition = transition;\n\t}\n\n\tif ( this.node.autofocus ) {\n\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\trunloop.scheduleTask( () => this.node.focus(), true );\n\t}\n\n\tupdateLiveQueries( this );\n\treturn this.node;\n}\n\nfunction getNamespace ( element ) {\n\tvar namespace, xmlns, parent;\n\n\t// Use specified namespace...\n\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\tnamespace = xmlns;\n\t}\n\n\t// ...or SVG namespace, if this is an <svg> element\n\telse if ( element.name === 'svg' ) {\n\t\tnamespace = namespaces.svg;\n\t}\n\n\telse if ( parent = element.parent ) {\n\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\tnamespace = namespaces.html;\n\t\t}\n\n\t\t// ...or inherit from the parent node\n\t\telse {\n\t\t\tnamespace = parent.node.namespaceURI;\n\t\t}\n\t}\n\n\telse {\n\t\tnamespace = element.root.el.namespaceURI;\n\t}\n\n\treturn namespace;\n}\n\nfunction processOption ( option ) {\n\tvar optionValue, selectValue, i;\n\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\tselectValue = option.select.getAttribute( 'value' );\n\tif ( selectValue === undefined ) {\n\t\treturn;\n\t}\n\n\toptionValue = option.getAttribute( 'value' );\n\n\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( optionValue == selectValue[i] ) {\n\t\t\t\toption.node.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toption.node.selected = ( optionValue == selectValue );\n\t}\n}\n\nfunction updateLiveQueries ( element ) {\n\tvar instance, liveQueries, i, selector, query;\n\n\t// Does this need to be added to any live queries?\n\tinstance = element.root;\n\n\tdo {\n\t\tliveQueries = instance._liveQueries;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tselector = liveQueries[i];\n\t\t\tquery = liveQueries[ '_' + selector ];\n\n\t\t\tif ( query._test( element ) ) {\n\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t}\n\t\t}\n\t} while ( instance = instance.parent );\n}\n","import { escapeHtml, voidElementNames } from 'utils/html';\nimport { isArray } from 'utils/is';\n\nexport default function () {\n\tvar str, escape;\n\n\tif ( this.template.y ) {\n\t\t// DOCTYPE declaration\n\t\treturn '<!DOCTYPE' + this.template.dd + '>';\n\t}\n\n\tstr = '<' + this.template.e;\n\n\tstr += this.attributes.map( stringifyAttribute ).join( '' )\n\t     + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\n\t// Special case - selected options\n\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\tstr += ' selected';\n\t}\n\n\t// Special case - two-way radio name bindings\n\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\tstr += ' checked';\n\t}\n\n\tstr += '>';\n\n\t// Special case - textarea\n\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t}\n\n\t// Special case - contenteditable\n\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\tstr += this.getAttribute( 'value' );\n\t}\n\n\tif ( this.fragment ) {\n\t\tescape = ( this.name !== 'script' && this.name !== 'style' );\n\t\tstr += this.fragment.toString( escape );\n\t}\n\n\t// add a closing tag if this isn't a void element\n\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\tstr += '</' + this.template.e + '>';\n\t}\n\n\treturn str;\n}\n\nfunction optionIsSelected ( element ) {\n\tvar optionValue, selectValue, i;\n\n\toptionValue = element.getAttribute( 'value' );\n\n\tif ( optionValue === undefined || !element.select ) {\n\t\treturn false;\n\t}\n\n\tselectValue = element.select.getAttribute( 'value' );\n\n\tif ( selectValue == optionValue ) {\n\t\treturn true;\n\t}\n\n\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction inputIsCheckedRadio ( element ) {\n\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n\tattributes = element.attributes;\n\n\ttypeAttribute  = attributes.type;\n\tvalueAttribute = attributes.value;\n\tnameAttribute  = attributes.name;\n\n\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\treturn;\n\t}\n\n\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\treturn true;\n\t}\n}\n\nfunction stringifyAttribute ( attribute ) {\n\tvar str = attribute.toString();\n\treturn str ? ' ' + str : '';\n}\n","import { unbind as unbindOption } from 'virtualdom/items/Element/special/option';\nimport { unbind } from 'shared/methodCallers';\n\nexport default function Element$unbind () {\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.binding ) {\n\t\tthis.binding.unbind();\n\t}\n\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( unbind );\n\t}\n\n\t// Special case - <option>\n\tif ( this.name === 'option' ) {\n\t\tunbindOption( this );\n\t}\n\n\tthis.attributes.forEach( unbind );\n\tthis.conditionalAttributes.forEach( unbind );\n}\n","import runloop from 'global/runloop';\nimport Transition from '../Transition/_Transition';\nimport { unrender as unrenderForm } from '../special/form';\nimport { unrender } from 'shared/methodCallers';\n\nexport default function Element$unrender ( shouldDestroy ) {\n\tvar binding, bindings, transition;\n\n\tif ( transition = this.transition ) {\n\t\ttransition.complete();\n\t}\n\n\t// Detach as soon as we can\n\tif ( this.name === 'option' ) {\n\t\t// <option> elements detach immediately, so that\n\t\t// their parent <select> element syncs correctly, and\n\t\t// since option elements can't have transitions anyway\n\t\tthis.detach();\n\t} else if ( shouldDestroy ) {\n\t\trunloop.detachWhenReady( this );\n\t}\n\n\t// Children first. that way, any transitions on child elements will be\n\t// handled by the current transitionManager\n\tif ( this.fragment ) {\n\t\tthis.fragment.unrender( false );\n\t}\n\n\tif ( binding = this.binding ) {\n\t\tthis.binding.unrender();\n\n\t\tthis.node._ractive.binding = null;\n\t\tbindings = this.root._twowayBindings[ binding.keypath.str ];\n\t\tbindings.splice( bindings.indexOf( binding ), 1 );\n\t}\n\n\t// Remove event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( unrender );\n\t}\n\n\tif ( this.decorator ) {\n\t\trunloop.registerDecorator( this.decorator );\n\t}\n\n\t// trigger outro transition if necessary\n\tif ( this.root.transitionsEnabled && this.outro ) {\n\t\ttransition = new Transition( this, this.outro, false );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start() );\n\t}\n\n\t// Remove this node from any live queries\n\tif ( this.liveQueries ) {\n\t\tremoveFromLiveQueries( this );\n\t}\n\n\tif ( this.name === 'form' ) {\n\t\tunrenderForm( this );\n\t}\n}\n\nfunction removeFromLiveQueries ( element ) {\n\tvar query, selector, i;\n\n\ti = element.liveQueries.length;\n\twhile ( i-- ) {\n\t\tquery = element.liveQueries[i];\n\t\tselector = query.selector;\n\n\t\tquery._remove( element.node );\n\t}\n}\n","import { lastItem } from 'utils/array';\n\nvar empty = /^\\s*$/, leadingWhitespace = /^\\s*/;\n\nexport default function ( str ) {\n\tvar lines, firstLine, lastLine, minIndent;\n\n\tlines = str.split( '\\n' );\n\n\t// remove first and last line, if they only contain whitespace\n\tfirstLine = lines[0];\n\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\tlines.shift();\n\t}\n\n\tlastLine = lastItem( lines );\n\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\tlines.pop();\n\t}\n\n\tminIndent = lines.reduce( reducer, null );\n\n\tif ( minIndent ) {\n\t\tstr = lines.map( function ( line ) {\n\t\t\treturn line.replace( minIndent, '' );\n\t\t}).join( '\\n' );\n\t}\n\n\treturn str;\n}\n\nfunction reducer ( previous, line ) {\n\tvar lineIndent = leadingWhitespace.exec( line )[0];\n\n\tif ( previous === null || ( lineIndent.length < previous.length ) ) {\n\t\treturn lineIndent;\n\t}\n\n\treturn previous;\n}\n","import { noRegistryFunctionReturn } from 'config/errors';\nimport { warn } from 'utils/log';\nimport parser from 'Ractive/config/custom/template/parser';\nimport { findInstance } from 'shared/registry';\nimport deIndent from './deIndent';\n\nexport default function getPartialTemplate ( ractive, name ) {\n\tvar partial;\n\n\t// If the partial in instance or view heirarchy instances, great\n\tif ( partial = getPartialFromRegistry( ractive, name ) ) {\n\t\treturn partial;\n\t}\n\n\t// Does it exist on the page as a script tag?\n\tpartial = parser.fromId( name, { noThrow: true } );\n\n\tif ( partial ) {\n\t\t// is this necessary?\n\t\tpartial = deIndent( partial );\n\n\t\t// parse and register to this ractive instance\n\t\tlet parsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\n\t\t// register (and return main partial if there are others in the template)\n\t\treturn ractive.partials[ name ] = parsed.t;\n\t}\n}\n\nfunction getPartialFromRegistry ( ractive, name ) {\n\t// find first instance in the ractive or view hierarchy that has this partial\n\tvar instance = findInstance( 'partials', ractive, name );\n\n\tif ( !instance ) { return; }\n\n\tlet partial = instance.partials[ name ], fn;\n\n\t// partial is a function?\n\tif ( typeof partial === 'function' ) {\n\t\tfn = partial.bind( instance );\n\t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n\t\tpartial = fn( instance.data, parser );\n\t}\n\n\tif ( !partial && partial !== '' ) {\n\t\twarn( noRegistryFunctionReturn, name, 'partial', 'partial' );\n\t\treturn;\n\t}\n\n\t// If this was added manually to the registry,\n\t// but hasn't been parsed, parse it now\n\tif ( !parser.isParsed( partial ) ) {\n\n\t\t// use the parseOptions of the ractive instance on which it was found\n\t\tlet parsed = parser.parse( partial, parser.getParseOptions( instance ) );\n\n\t\t// Partials cannot contain nested partials!\n\t\t// TODO add a test for this\n\t\tif ( parsed.p ) {\n\t\t\twarn( 'Partials ({{>%s}}) cannot contain nested inline partials', name );\n\t\t}\n\n\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t// in the correct point in prototype chain on instance or constructor\n\t\tlet target = fn ? instance : findOwner( instance, name );\n\n\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\ttarget.partials[ name ] = partial = parsed.t;\n\t}\n\n\t// store for reset\n\tif ( fn ) {\n\t\tpartial._fn = fn;\n\t}\n\n\treturn partial.v ? partial.t : partial;\n}\n\nfunction findOwner ( ractive, key ) {\n\treturn ractive.partials.hasOwnProperty( key )\n\t\t? ractive\n\t\t: findConstructor( ractive.constructor, key);\n}\n\nfunction findConstructor ( constructor, key ) {\n\tif ( !constructor ) { return; }\n\treturn constructor.partials.hasOwnProperty( key )\n\t\t? constructor\n\t\t: findConstructor( constructor._Parent, key );\n}\n","import { noRegistryFunctionReturn } from 'config/errors';\nimport { warn } from 'utils/log';\nimport { findInstance } from 'shared/registry';\n\n// finds the component constructor in the registry or view hierarchy registries\n\nexport default function getComponent ( ractive, name ) {\n\n\tvar Component, instance = findInstance( 'components', ractive, name );\n\n\tif ( instance ) {\n\t\tComponent = instance.components[ name ];\n\n\t\t// best test we have for not Ractive.extend\n\t\tif ( !Component._Parent ) {\n\t\t\t// function option, execute and store for reset\n\t\t\tlet fn = Component.bind( instance );\n\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\tComponent = fn( instance.data );\n\n\t\t\tif ( !Component ) {\n\t\t\t\tif ( ractive.debug ) {\n\t\t\t\t\twarn( noRegistryFunctionReturn, name, 'component', 'component' );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( typeof Component === 'string' ) {\n\t\t\t\t// allow string lookup\n\t\t\t\tComponent = getComponent ( ractive, Component );\n\t\t\t}\n\n\t\t\tComponent._fn = fn;\n\t\t\tinstance.components[ name ] = Component;\n\t\t}\n\t}\n\n\treturn Component;\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Component$detach () {\n\tvar detached = this.instance.fragment.detach();\n\tdetachHook.fire( this.instance );\n\treturn detached;\n}\n","export default function Component$find ( selector ) {\n\treturn this.instance.fragment.find( selector );\n}\n","export default function Component$findAll ( selector, query ) {\n\treturn this.instance.fragment.findAll( selector, query );\n}\n","export default function Component$findAllComponents ( selector, query ) {\n\tquery._test( this, true );\n\n\tif ( this.instance.fragment ) {\n\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function Component$findComponent ( selector ) {\n\tif ( !selector || ( selector === this.name ) ) {\n\t\treturn this.instance;\n\t}\n\n\tif ( this.instance.fragment ) {\n\t\treturn this.instance.fragment.findComponent( selector );\n\t}\n\n\treturn null;\n}\n","export default function Component$findNextNode () {\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Component$firstNode () {\n\tif ( this.rendered ) {\n\t\treturn this.instance.fragment.firstNode();\n\t}\n\n\treturn null;\n}\n","var prefixers = {};\n\nexport default function Viewmodel$adapt ( keypath, value ) {\n\tvar ractive = this.ractive, len, i, adaptor, wrapped;\n\n\t// Do we have an adaptor for this value?\n\tlen = ractive.adapt.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tadaptor = ractive.adapt[i];\n\n\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\twrapped.value = value;\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nfunction prefixKeypath ( obj, prefix ) {\n\tvar prefixed = {}, key;\n\n\tif ( !prefix ) {\n\t\treturn obj;\n\t}\n\n\tprefix += '.';\n\n\tfor ( key in obj ) {\n\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn prefixed;\n}\n\nfunction getPrefixer ( rootKeypath ) {\n\tvar rootDot;\n\n\tif ( !prefixers[ rootKeypath ] ) {\n\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\tvar obj;\n\n\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\tobj = {};\n\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t}\n\t\t};\n\t}\n\n\treturn prefixers[ rootKeypath ];\n}\n","import { addToArray } from 'utils/array';\nimport { rootKeypath } from 'shared/keypaths'; // TEMP\n\nexport default function getUpstreamChanges ( changes ) {\n\tvar upstreamChanges = [ rootKeypath ], i, keypath;\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tkeypath = changes[i].parent;\n\n\t\twhile ( keypath && !keypath.isRoot ) {\n\t\t\taddToArray( upstreamChanges, keypath );\n\t\t\tkeypath = keypath.parent;\n\t\t}\n\t}\n\n\treturn upstreamChanges;\n}\n","export default notifyPatternObservers;\n\nfunction notifyPatternObservers ( viewmodel, keypath, onlyDirect ) {\n\tvar potentialWildcardMatches;\n\n\tupdateMatchingPatternObservers( viewmodel, keypath );\n\n\tif ( onlyDirect ) {\n\t\treturn;\n\t}\n\n\tpotentialWildcardMatches = keypath.wildcardMatches();\n\tpotentialWildcardMatches.forEach( upstreamPattern => {\n\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t});\n}\n\n\nfunction cascade ( viewmodel, upstreamPattern, keypath ) {\n\tvar group, map, actualChildKeypath;\n\n\t// TODO should be one or the other\n\tupstreamPattern = ( upstreamPattern.str || upstreamPattern );\n\n\tgroup = viewmodel.depsMap.patternObservers;\n\tmap = group && group[ upstreamPattern ];\n\n\tif ( !map ) {\n\t\treturn;\n\t}\n\n\tmap.forEach( childKeypath => {\n\t\tactualChildKeypath = keypath.join( childKeypath.lastKey ); // 'foo.bar.baz'\n\n\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t});\n}\n\nfunction updateMatchingPatternObservers ( viewmodel, keypath ) {\n\tviewmodel.patternObservers.forEach( observer => {\n\t\tif ( observer.regex.test( keypath.str ) ) {\n\t\t\tobserver.update( keypath );\n\t\t}\n\t});\n}\n","import getUpstreamChanges from '../helpers/getUpstreamChanges';\nimport notifyPatternObservers from './applyChanges/notifyPatternObservers';\n\nexport default function Viewmodel$applyChanges () {\n\tvar self = this,\n\t\tchanges,\n\t\tupstreamChanges,\n\t\thash = {},\n\t\tbindings;\n\n\tchanges = this.changes;\n\n\tif ( !changes.length ) {\n\t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n\t\treturn;\n\t}\n\n\tfunction cascade ( keypath ) {\n\t\tvar map, computations;\n\n\t\tif ( self.noCascade.hasOwnProperty( keypath.str ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( computations = self.deps.computed[ keypath.str ] ) {\n\t\t\tcomputations.forEach( c => {\n\t\t\t\tvar key = c.key;\n\n\t\t\t\tif ( c.viewmodel === self ) {\n\t\t\t\t\tself.clearCache( key.str );\n\t\t\t\t\tc.invalidate();\n\n\t\t\t\t\tchanges.push( key );\n\t\t\t\t\tcascade( key );\n\t\t\t\t} else {\n\t\t\t\t\tc.viewmodel.mark( key );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif ( map = self.depsMap.computed[ keypath.str ] ) {\n\t\t\tmap.forEach( cascade );\n\t\t}\n\t}\n\n\tchanges.slice().forEach( cascade );\n\n\tupstreamChanges = getUpstreamChanges( changes );\n\tupstreamChanges.forEach( keypath => {\n\t\tvar computations;\n\n\t\t// make sure we haven't already been down this particular keypath in this turn\n\t\tif ( changes.indexOf( keypath ) === -1 && ( computations = self.deps.computed[ keypath.str ] ) ) {\n\t\t\tthis.changes.push( keypath );\n\n\t\t\tcomputations.forEach( c => {\n\t\t\t\tc.viewmodel.mark( c.key );\n\t\t\t});\n\t\t}\n\t});\n\n\tthis.changes = [];\n\n\t// Pattern observers are a weird special case\n\tif ( this.patternObservers.length ) {\n\t\tupstreamChanges.forEach( keypath => notifyPatternObservers( this, keypath, true ) );\n\t\tchanges.forEach( keypath => notifyPatternObservers( this, keypath ) );\n\t}\n\n\tif ( this.deps.observers ) {\n\t\tupstreamChanges.forEach( keypath => notifyUpstreamDependants( this, null, keypath, 'observers' ) );\n\t\tnotifyAllDependants( this, changes, 'observers' );\n\t}\n\n\tif ( this.deps['default'] ) {\n\t\tbindings = [];\n\t\tupstreamChanges.forEach( keypath => notifyUpstreamDependants( this, bindings, keypath, 'default' ) );\n\n\t\tif( bindings.length ) {\n\t\t\tnotifyBindings( this, bindings, changes );\n\t\t}\n\n\t\tnotifyAllDependants( this, changes, 'default' );\n\t}\n\n\t// Return a hash of keypaths to updated values\n\tchanges.forEach( keypath => {\n\t\thash[ keypath.str ] = this.get( keypath );\n\t});\n\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\treturn hash;\n}\n\nfunction notifyUpstreamDependants ( viewmodel, bindings, keypath, groupName ) {\n\tvar dependants, value;\n\n\tif ( dependants = findDependants( viewmodel, keypath, groupName ) ) {\n\t\tvalue = viewmodel.get( keypath );\n\n\t\tdependants.forEach( d => {\n\t\t\t// don't \"set\" the parent value, refine it\n\t\t\t// i.e. not data = value, but data[foo] = fooValue\n\t\t\tif( bindings && d.refineValue ) {\n\t\t\t\tbindings.push( d );\n\t\t\t}\n\t\t\telse {\n\t\t\t\td.setValue( value );\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction notifyBindings ( viewmodel, bindings, changes ) {\n\n\tbindings.forEach( binding => {\n\t\tlet useSet = false, i = 0, length = changes.length, refinements = [];\n\n\t\twhile( i < length ) {\n\t\t\tlet keypath = changes[i];\n\n\t\t\tif ( keypath === binding.keypath ) {\n\t\t\t\tuseSet = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( keypath.slice(0, binding.keypath.length) === binding.keypath ) {\n\t\t\t\trefinements.push( keypath );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tif ( useSet ) {\n\t\t\tbinding.setValue( viewmodel.get( binding.keypath ) );\n\t\t}\n\n\t\tif( refinements.length ) {\n\t\t\tbinding.refineValue( refinements );\n\t\t}\n\t});\n}\n\n\nfunction notifyAllDependants ( viewmodel, keypaths, groupName ) {\n\tvar queue = [];\n\n\taddKeypaths( keypaths );\n\tqueue.forEach( dispatch );\n\n\tfunction addKeypaths ( keypaths ) {\n\t\tkeypaths.forEach( addKeypath );\n\t\tkeypaths.forEach( cascade );\n\t}\n\n\tfunction addKeypath ( keypath ) {\n\t\tvar deps = findDependants( viewmodel, keypath, groupName );\n\n\t\tif ( deps ) {\n\t\t\tqueue.push({\n\t\t\t\tkeypath: keypath,\n\t\t\t\tdeps: deps\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction cascade ( keypath ) {\n\t\tvar childDeps;\n\n\t\tif ( childDeps = viewmodel.depsMap[ groupName ][ keypath.str ] ) {\n\t\t\taddKeypaths( childDeps );\n\t\t}\n\t}\n\n\tfunction dispatch ( set ) {\n\t\tvar value = viewmodel.get( set.keypath );\n\t\tset.deps.forEach( d => d.setValue( value ) );\n\t}\n}\n\nfunction findDependants ( viewmodel, keypath, groupName ) {\n\tvar group = viewmodel.deps[ groupName ];\n\treturn group ? group[ keypath.str ] : null;\n}\n","export default function Viewmodel$capture () {\n\tthis.captureGroups.push([]);\n}\n","export default function Viewmodel$clearCache ( keypath, keepExistingWrapper ) {\n\tvar cacheMap, wrapper;\n\n\tif ( !keepExistingWrapper ) {\n\t\t// Is there a wrapped property at this keypath?\n\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t// Did we unwrap it?\n\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t// Is this right?\n\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cache[ keypath ] = undefined;\n\n\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\twhile ( cacheMap.length ) {\n\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t}\n\t}\n}\n","var pattern = /\\$\\{([^\\}]+)\\}/g;\n\nexport default function ( signature ) {\n\tif ( typeof signature === 'function' ) {\n\t\treturn { get: signature };\n\t}\n\n\tif ( typeof signature === 'string' ) {\n\t\treturn {\n\t\t\tget: createFunctionFromString( signature )\n\t\t};\n\t}\n\n\tif ( typeof signature === 'object' && typeof signature.get === 'string' ) {\n\t\tsignature = {\n\t\t\tget: createFunctionFromString( signature.get ),\n\t\t\tset: signature.set\n\t\t};\n\t}\n\n\treturn signature;\n}\n\nfunction createFunctionFromString ( signature ) {\n\tvar functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function ( match, keypath ) {\n\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t}) + ')';\n\n\treturn new Function ( functionBody );\n}\n","import runloop from 'global/runloop';\nimport { log, warn } from 'utils/log';\nimport { isEqual } from 'utils/is';\nimport UnresolvedDependency from './UnresolvedDependency';\n\nvar Computation = function ( ractive, key, signature ) {\n\tthis.ractive = ractive;\n\tthis.viewmodel = ractive.viewmodel;\n\tthis.key = key;\n\n\tthis.getter = signature.get;\n\tthis.setter = signature.set;\n\n\tthis.hardDeps = signature.deps || [];\n\tthis.softDeps = [];\n\tthis.unresolvedDeps = {};\n\n\tthis.depValues = {};\n\n\tif ( this.hardDeps ) {\n\t\tthis.hardDeps.forEach( d => ractive.viewmodel.register( d, this, 'computed' ) );\n\t}\n\n\tthis._dirty = this._firstRun = true;\n};\n\nComputation.prototype = {\n\tconstructor: Computation,\n\n\tinit: function () {\n\t\tvar initial;\n\n\t\tthis.bypass = true;\n\n\t\tinitial = this.ractive.viewmodel.get( this.key );\n\t\tthis.ractive.viewmodel.clearCache( this.key.str );\n\n\t\tthis.bypass = false;\n\n\t\tif ( this.setter && initial !== undefined ) {\n\t\t\tthis.set( initial );\n\t\t}\n\t},\n\n\tinvalidate: function () {\n\t\tthis._dirty = true;\n\t},\n\n\tget: function () {\n\t\tvar ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\n\t\tif ( this.getting ) {\n\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\treturn;\n\t\t}\n\n\t\tthis.getting = true;\n\n\t\tif ( this._dirty ) {\n\t\t\tractive = this.ractive;\n\n\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t// other computed values\n\t\t\tif ( this._firstRun || ( !this.hardDeps.length && !this.softDeps.length ) ) {\n\t\t\t\tdependencyValuesChanged = true;\n\t\t\t} else {\n\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\tvar keypath, value, i;\n\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ti = deps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = deps[i];\n\t\t\t\t\t\tvalue = ractive.viewmodel.get( keypath );\n\n\t\t\t\t\t\tif ( !isEqual( value, this.depValues[ keypath.str ] ) ) {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = value;\n\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\tractive.viewmodel.capture();\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.value = this.getter.call( ractive );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\tif ( ractive.debug ) {\n\t\t\t\t\t\twarn( 'Failed to compute \"%s\"', this.key.str );\n\t\t\t\t\t\tlog( err.stack || err );\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.value = void 0;\n\t\t\t\t}\n\n\t\t\t\tnewDeps = ractive.viewmodel.release();\n\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\t\tdeps.forEach( keypath => {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = ractive.viewmodel.get( keypath );\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tthis.getting = this._firstRun = false;\n\t\treturn this.value;\n\t},\n\n\tset: function ( value ) {\n\t\tif ( this.setting ) {\n\t\t\tthis.value = value;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this.setter ) {\n\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t}\n\n\t\tthis.setter.call( this.ractive, value );\n\t},\n\n\tupdateDependencies: function ( newDeps ) {\n\t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n\t\toldDeps = this.softDeps;\n\n\t\t// remove dependencies that are no longer used\n\t\ti = oldDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = oldDeps[i];\n\n\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\tdependenciesChanged = true;\n\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t}\n\t\t}\n\n\t\t// create references for any new dependencies\n\t\ti = newDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = newDeps[i];\n\n\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\tdependenciesChanged = true;\n\n\t\t\t\t// if this keypath is currently unresolved, we need to mark\n\t\t\t\t// it as such. TODO this is a bit muddy...\n\t\t\t\tif ( isUnresolved( this.viewmodel, keypath ) && ( !this.unresolvedDeps[ keypath.str ] ) ) {\n\t\t\t\t\tunresolved = new UnresolvedDependency( this, keypath.str );\n\t\t\t\t\tnewDeps.splice( i, 1 );\n\n\t\t\t\t\tthis.unresolvedDeps[ keypath.str ] = unresolved;\n\t\t\t\t\trunloop.addUnresolved( unresolved );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dependenciesChanged ) {\n\t\t\tthis.softDeps = newDeps.slice();\n\t\t}\n\n\t\treturn dependenciesChanged;\n\t}\n};\n\nfunction isUnresolved( viewmodel, keypath ) {\n\tvar key = keypath.firstKey;\n\n\treturn !( key in viewmodel.ractive.data ) &&\n\t       !( key in viewmodel.computations ) &&\n\t       !( key in viewmodel.mappings );\n}\n\nexport default Computation;\n","import getComputationSignature from '../Computation/getComputationSignature';\nimport Computation from '../Computation/Computation';\n\nexport default function Viewmodel$compute ( key, signature ) {\n\tsignature = getComputationSignature( signature );\n\treturn ( this.computations[ key.str ] = new Computation( this.ractive, key, signature ) );\n}\n","import { lastItem } from 'utils/array';\nimport FAILED_LOOKUP from './get/FAILED_LOOKUP';\n\nvar empty = {};\n\nexport default function Viewmodel$get ( keypath, options ) {\n\tvar ractive = this.ractive,\n\t\tcache = this.cache,\n\t\tmapping,\n\t\tvalue,\n\t\tcomputation,\n\t\twrapped,\n\t\tcaptureGroup,\n\t\tkeypathStr = keypath.str;\n\n\toptions = options || empty;\n\n\t// capture the keypath, if we're inside a computation\n\tif ( options.capture && ( captureGroup = lastItem( this.captureGroups ) ) ) {\n\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\tcaptureGroup.push( keypath );\n\t\t}\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\treturn mapping.get( keypath, options );\n\t}\n\n\tif ( keypath.isSpecial ) {\n\t\treturn keypath.value;\n\t}\n\n\tif ( cache[ keypathStr ] === undefined ) {\n\n\t\t// Is this a computed property?\n\t\tif ( ( computation = this.computations[ keypathStr ] ) && !computation.bypass ) {\n\t\t\tvalue = computation.get();\n\t\t\tthis.adapt( keypathStr, value );\n\t\t}\n\n\t\t// Is this a wrapped property?\n\t\telse if ( wrapped = this.wrapped[ keypathStr ] ) {\n\t\t\tvalue = wrapped.value;\n\t\t}\n\n\t\t// Is it the root?\n\t\telse if ( keypath.isRoot ) {\n\t\t\tthis.adapt( '', ractive.data );\n\t\t\tvalue = ractive.data;\n\t\t}\n\n\t\t// No? Then we need to retrieve the value one key at a time\n\t\telse {\n\t\t\tvalue = retrieve( this, keypath );\n\t\t}\n\n\t\tcache[ keypathStr ] = value;\n\t} else {\n\t\tvalue = cache[ keypathStr ];\n\t}\n\n\tif ( !options.noUnwrap && ( wrapped = this.wrapped[ keypathStr ] ) ) {\n\t\tvalue = wrapped.get();\n\t}\n\n\treturn value === FAILED_LOOKUP ? void 0 : value;\n}\n\nfunction retrieve ( viewmodel, keypath ) {\n\n\tvar parentValue, cacheMap, value, wrapped;\n\n\tparentValue = viewmodel.get( keypath.parent );\n\n\tif ( wrapped = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\tparentValue = wrapped.get();\n\t}\n\n\tif ( parentValue === null || parentValue === undefined ) {\n\t\treturn;\n\t}\n\n\t// update cache map\n\tif ( !( cacheMap = viewmodel.cacheMap[ keypath.parent.str ] ) ) {\n\t\tviewmodel.cacheMap[ keypath.parent.str ] = [ keypath.str ];\n\t} else {\n\t\tif ( cacheMap.indexOf( keypath.str ) === -1 ) {\n\t\t\tcacheMap.push( keypath.str );\n\t\t}\n\t}\n\n\t// If this property doesn't exist, we return a sentinel value\n\t// so that we know to query parent scope (if such there be)\n\tif ( typeof parentValue === 'object' && !( keypath.lastKey in parentValue ) ) {\n\t\treturn viewmodel.cache[ keypath.str ] = FAILED_LOOKUP;\n\t}\n\n\tvalue = parentValue[ keypath.lastKey ];\n\n\t// Do we have an adaptor for this value?\n\tviewmodel.adapt( keypath.str, value, false );\n\n\t// Update cache\n\tviewmodel.cache[ keypath.str ] = value;\n\treturn value;\n}\n","import { fatal } from 'utils/log';\nimport { getKeypath } from 'shared/keypaths';\n\nexport default function Viewmodel$init () {\n\tvar key, computation, computations = [];\n\n\tfor ( key in this.ractive.computed ) {\n\t\tcomputation = this.compute( getKeypath( key ), this.ractive.computed[ key ] );\n\t\tcomputations.push( computation );\n\n\t\tif ( key in this.mappings ) {\n\t\t\tfatal( 'Cannot map to a computed property (\\'%s\\')', key );\n\t\t}\n\t}\n\n\tcomputations.forEach( init );\n}\n\nfunction init ( computation ) {\n\tcomputation.init();\n}\n","function DataTracker ( key, viewmodel ) {\n\tthis.keypath = key;\n\tthis.viewmodel = viewmodel;\n}\n\nexport default DataTracker;\n\nDataTracker.prototype.setValue = function ( value ) {\n\tthis.viewmodel.set( this.keypath, value, { noMapping: true } );\n};\n\n","import DataTracker from './DataTracker';\nimport { isFunction } from 'utils/is';\n\nfunction Mapping ( localKey, options ) {\n\tthis.localKey = localKey;\n\tthis.keypath = options.keypath;\n\tthis.origin = options.origin;\n\n\tif ( options.force ) {\n\t\tthis.force = options.force;\n\t}\n\n\tthis.deps = [];\n\tthis.unresolved = [];\n\n\tthis.trackData = options.trackData;\n\tthis.resolved = false;\n}\n\nexport default Mapping;\n\nMapping.prototype = {\n\tensureKeypath () {\n\t\tif ( !this.keypath ) {\n\t\t\tif ( isFunction( this.force ) ) {\n\t\t\t\tthis.force();\n\t\t\t}\n\n\t\t\tif ( !this.keypath ) {\n\t\t\t\tthrow new Error( 'Mapping \"' + this.localKey.str + '\" on component \"' + this.local.ractive.component.name + '\" does not have a keypath. This is usually caused by an ambiguous complex reference, which can usually be fixed by scoping your references.' );\n\t\t\t}\n\t\t}\n\t},\n\n\tget ( keypath, options ) {\n\t\tif ( !this.resolved ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.map( keypath ), options );\n\t},\n\n\tgetValue () {\n\t\tif ( !this.keypath ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.keypath );\n\t},\n\n\tinitViewmodel ( viewmodel ) {\n\t\tthis.local = viewmodel;\n\t\tthis.setup();\n\t},\n\n\tmap ( keypath ) {\n\t\treturn keypath.replace( this.localKey, this.keypath );\n\t},\n\n\tregister ( keypath, dependant, group ) {\n\t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n\t\tif ( this.resolved ) {\n\t\t\tthis.origin.register( this.map( keypath ), dependant, group );\n\t\t}\n\t},\n\n\tresolve ( keypath ) {\n\t\tif ( this.keypath !== undefined ) {\n\t\t\tthis.unbind( true );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.setup();\n\t},\n\n\tset ( keypath, value ) {\n\t\tthis.ensureKeypath();\n\t\tthis.origin.set( this.map( keypath ), value );\n\t},\n\n\tsetup () {\n\t\tif ( this.keypath === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\t// keep local data in sync, for browsers w/ no defineProperty\n\t\tif ( this.trackData ) {\n\t\t\tthis.tracker = new DataTracker( this.localKey, this.local );\n\t\t\tthis.origin.register( this.keypath, this.tracker );\n\t\t}\n\n\t\t// accumulated dependants can now be registered\n\t\tif ( this.deps.length ) {\n\t\t\tthis.deps.forEach( d => {\n\t\t\t\tvar keypath = this.map( d.keypath );\n\t\t\t\tthis.origin.register( keypath, d.dep, d.group );\n\n\t\t\t\t// if the dep has a setter, it's a reference, otherwise, a computation\n\t\t\t\tif ( isFunction( d.dep.setValue ) ) {\n\t\t\t\t\td.dep.setValue( this.origin.get( keypath ) );\n\t\t\t\t} else {\n\t\t\t\t\t// computations have no setter, get it to recompute via viewmodel\n\t\t\t\t\tthis.local.mark( d.dep.key );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.origin.mark( this.keypath );\n\t\t}\n\t},\n\n\tsetValue ( value ) {\n\t\tthis.ensureKeypath();\n\t\tthis.origin.set( this.keypath, value );\n\t},\n\n\tunbind ( keepLocal ) {\n\t\tif ( !keepLocal ) {\n\t\t\tdelete this.local.mappings[ this.localKey ];\n\t\t}\n\n\t\tthis.deps.forEach( d => {\n\t\t\tthis.origin.unregister( this.map( d.keypath ), d.dep, d.group );\n\t\t});\n\n\t\tif ( this.tracker ) {\n\t\t\tthis.origin.unregister( this.keypath, this.tracker );\n\t\t}\n\t},\n\n\tunregister ( keypath, dependant, group ) {\n\t\tvar deps = this.deps, i = deps.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( deps[i].dep === dependant ) {\n\t\t\t\tdeps.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.origin.unregister( this.map( keypath ), dependant, group );\n\t}\n};\n","import Mapping from 'shared/parameters/Mapping';\n\nexport default function Viewmodel$map ( key, options ) {\n\tvar mapping = this.mappings[ key.str ] = new Mapping( key, options );\n\tmapping.initViewmodel( this );\n\treturn mapping;\n}\n","import runloop from 'global/runloop';\n\nexport default function Viewmodel$mark ( keypath, options ) {\n\tvar computation, keypathStr = keypath.str;\n\n\trunloop.addViewmodel( this ); // TODO remove other instances of this call\n\n\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t// should not be picked up by pattern observers\n\tif ( options ) {\n\t\tif ( options.implicit ) {\n\t\t\tthis.implicitChanges[ keypathStr ] = true;\n\t\t}\n\t\tif ( options.noCascade ) {\n\t\t\tthis.noCascade[ keypathStr ] = true;\n\t\t}\n\t}\n\n\tif ( computation = this.computations[ keypathStr ] ) {\n\t\tcomputation.invalidate();\n\t}\n\n\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\tthis.changes.push( keypath );\n\t}\n\n\t// pass on keepExistingWrapper, if we can\n\tlet keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n\tthis.clearCache( keypathStr, keepExistingWrapper );\n}\n","import { warn } from 'utils/log';\nimport mapOldToNewIndex from './merge/mapOldToNewIndex';\n\nvar comparators = {};\n\nexport default function Viewmodel$merge ( keypath, currentArray, array, options ) {\n\tvar oldArray,\n\t\tnewArray,\n\t\tcomparator,\n\t\tnewIndices;\n\n\tthis.mark( keypath );\n\n\tif ( options && options.compare ) {\n\n\t\tcomparator = getComparatorFunction( options.compare );\n\n\t\ttry {\n\t\t\toldArray = currentArray.map( comparator );\n\t\t\tnewArray = array.map( comparator );\n\t\t} catch ( err ) {\n\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t// to do more DOM manipulation than we thought...\n\n\t\t\t// ...unless we're in debug mode of course\n\t\t\tif ( this.debug ) {\n\t\t\t\tthrow err;\n\t\t\t} else {\n\t\t\t\twarn( 'Merge operation: comparison failed. Falling back to identity checking' );\n\t\t\t}\n\n\t\t\toldArray = currentArray;\n\t\t\tnewArray = array;\n\t\t}\n\n\t} else {\n\t\toldArray = currentArray;\n\t\tnewArray = array;\n\t}\n\n\t// find new indices for members of oldArray\n\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\n\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n}\n\nfunction stringify ( item ) {\n\treturn JSON.stringify( item );\n}\n\nfunction getComparatorFunction ( comparator ) {\n\t// If `compare` is `true`, we use JSON.stringify to compare\n\t// objects that are the same shape, but non-identical - i.e.\n\t// { foo: 'bar' } !== { foo: 'bar' }\n\tif ( comparator === true ) {\n\t\treturn stringify;\n\t}\n\n\tif ( typeof comparator === 'string' ) {\n\t\tif ( !comparators[ comparator ] ) {\n\t\t\tcomparators[ comparator ] = function ( item ) {\n\t\t\t\treturn item[ comparator ];\n\t\t\t};\n\t\t}\n\n\t\treturn comparators[ comparator ];\n\t}\n\n\tif ( typeof comparator === 'function' ) {\n\t\treturn comparator;\n\t}\n\n\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n}\n","export default function Viewmodel$register ( keypath, dependant, group = 'default' ) {\n\tvar mapping, depsByKeypath, deps;\n\n\tif ( dependant.isStatic ) {\n\t\treturn; // TODO we should never get here if a dependant is static...\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\tmapping.register( keypath, dependant, group );\n\t}\n\n\telse {\n\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\tdeps = depsByKeypath[ keypath.str ] || ( depsByKeypath[ keypath.str ] = [] );\n\n\t\tdeps.push( dependant );\n\n\t\tif ( !keypath.isRoot ) {\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t}\n\t}\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent, keypathStr;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );\n\t\tparent = map[ keypath.parent.str ] || ( map[ keypath.parent.str ] = [] );\n\n\t\tkeypathStr = keypath.str;\n\n\t\t// TODO find an alternative to this nasty approach\n\t\tif ( parent[ '_' + keypathStr ] === undefined ) {\n\t\t\tparent[ '_' + keypathStr ] = 0;\n\t\t\tparent.push( keypath );\n\t\t}\n\n\t\tparent[ '_' + keypathStr ] += 1;\n\t\tkeypath = keypath.parent;\n\t}\n}\n","export default function Viewmodel$release () {\n\treturn this.captureGroups.pop();\n}\n","import { isEqual } from 'utils/is';\nimport createBranch from 'utils/createBranch';\n\nexport default function Viewmodel$set ( keypath, value, options = {} ) {\n\tvar mapping, computation, wrapper, keepExistingWrapper;\n\n\t// unless data is being set for data tracking purposes\n\tif ( !options.noMapping ) {\n\t\t// If this data belongs to a different viewmodel,\n\t\t// pass the change along\n\t\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\t\treturn mapping.set( keypath, value );\n\t\t}\n\t}\n\n\tcomputation = this.computations[ keypath.str ];\n\tif ( computation ) {\n\t\tif ( computation.setting ) {\n\t\t\t// let the other computation set() handle things...\n\t\t\treturn;\n\t\t}\n\t\tcomputation.set( value );\n\t\tvalue = computation.get();\n\t}\n\n\tif ( isEqual( this.cache[ keypath.str ], value ) ) {\n\t\treturn;\n\t}\n\n\twrapper = this.wrapped[ keypath.str ];\n\n\t// If we have a wrapper with a `reset()` method, we try and use it. If the\n\t// `reset()` method returns false, the wrapper should be torn down, and\n\t// (most likely) a new one should be created later\n\tif ( wrapper && wrapper.reset ) {\n\t\tkeepExistingWrapper = ( wrapper.reset( value ) !== false );\n\n\t\tif ( keepExistingWrapper ) {\n\t\t\tvalue = wrapper.get();\n\t\t}\n\t}\n\n\tif ( !computation && !keepExistingWrapper ) {\n\t\tresolveSet( this, keypath, value );\n\t}\n\n\tif ( !options.silent ) {\n\t\tthis.mark( keypath );\n\t} else {\n\t\t// We're setting a parent of the original target keypath (i.e.\n\t\t// creating a fresh branch) - we need to clear the cache, but\n\t\t// not mark it as a change\n\t\tthis.clearCache( keypath.str );\n\t}\n}\n\nfunction resolveSet ( viewmodel, keypath, value ) {\n\tvar wrapper, parentValue, wrapperSet, valueSet;\n\n\twrapperSet = function() {\n\t\tif ( wrapper.set ) {\n\t\t\twrapper.set( keypath.lastKey, value );\n\t\t} else {\n\t\t\tparentValue = wrapper.get();\n\t\t\tvalueSet();\n\t\t}\n\t};\n\n\tvalueSet = function(){\n\t\tif ( !parentValue ) {\n\t\t\tparentValue = createBranch( keypath.lastKey );\n\t\t\tviewmodel.set( keypath.parent, parentValue, { silent: true } );\n\t\t}\n\t\tparentValue[ keypath.lastKey ] = value;\n\t};\n\n\twrapper = viewmodel.wrapped[ keypath.parent.str ];\n\n\tif ( wrapper ) {\n\t\twrapperSet();\n\t} else {\n\t\tparentValue = viewmodel.get( keypath.parent );\n\n\t\t// may have been wrapped via the above .get()\n\t\t// call on viewmodel if this is first access via .set()!\n\t\tif( wrapper = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\t\twrapperSet();\n\t\t} else {\n\t\t\tvalueSet();\n\t\t}\n\t}\n}\n","var implicitOption = { implicit: true }, noCascadeOption = { noCascade: true };\n\nexport default function Viewmodel$smartUpdate ( keypath, array, newIndices ) {\n\tvar dependants, oldLength, i;\n\n\toldLength = newIndices.length;\n\n\t// Indices that are being removed should be marked as dirty\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.mark( keypath.join( oldIndex ), noCascadeOption );\n\t\t}\n\t});\n\n\t// Update the model\n\t// TODO allow existing array to be updated in place, rather than replaced?\n\tthis.set( keypath, array, { silent: true } );\n\n\tif ( dependants = this.deps[ 'default' ][ keypath.str ] ) {\n\t\tdependants.filter( canShuffle ).forEach( d => d.shuffle( newIndices, array ) );\n\t}\n\n\tif ( oldLength !== array.length ) {\n\t\tthis.mark( keypath.join( 'length' ), implicitOption );\n\n\t\tfor ( i = oldLength; i < array.length; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ) );\n\t\t}\n\n\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t// TODO is this still necessary, now that computations are lazy?\n\t\tfor ( i = array.length; i < oldLength; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ), noCascadeOption );\n\t\t}\n\t}\n}\n\nfunction canShuffle ( dependant ) {\n\treturn typeof dependant.shuffle === 'function';\n}\n","export default function Viewmodel$teardown () {\n\tvar unresolvedImplicitDependency;\n\n\t// Clear entire cache - this has the desired side-effect\n\t// of unwrapping adapted values (e.g. arrays)\n\tObject.keys( this.cache ).forEach( keypath => this.clearCache( keypath ) );\n\n\t// Teardown any failed lookups - we don't need them to resolve any more\n\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\tunresolvedImplicitDependency.teardown();\n\t}\n}\n","import { removeFromArray } from 'utils/array';\n\nexport default function Viewmodel$unregister ( keypath, dependant, group = 'default' ) {\n\tvar mapping, deps, index;\n\n\tif ( dependant.isStatic ) {\n\t\treturn;\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\treturn mapping.unregister( keypath, dependant, group );\n\t}\n\n\tdeps = this.deps[ group ][ keypath.str ];\n\tindex = deps.indexOf( dependant );\n\n\tif ( index === -1 ) {\n\t\tthrow new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );\n\t}\n\n\tdeps.splice( index, 1 );\n\n\tif ( keypath.isRoot ) {\n\t\treturn;\n\t}\n\n\tupdateDependantsMap( this, keypath, group );\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ];\n\n\t\tparent[ '_' + keypath.str ] -= 1;\n\n\t\tif ( !parent[ '_' + keypath.str ] ) {\n\t\t\t// remove from parent deps map\n\t\t\tremoveFromArray( parent, keypath );\n\t\t\tparent[ '_' + keypath.str ] = undefined;\n\t\t}\n\n\t\tkeypath = keypath.parent;\n\t}\n}\n","import Hook from './Hook';\n\nfunction HookQueue ( event ) {\n\tthis.hook = new Hook( event );\n\tthis.inProcess = {};\n\tthis.queue = {};\n}\n\nHookQueue.prototype = {\n\n\tconstructor: HookQueue,\n\n\tbegin: function ( ractive ) {\n\t\tthis.inProcess[ ractive._guid ] = true;\n\t},\n\n\tend: function ( ractive ) {\n\n\t\tvar parent = ractive.parent;\n\n\t\t// If this is *isn't* a child of a component that's in process,\n\t\t// it should call methods or fire at this point\n\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\tfire( this, ractive );\n\t\t}\n\t\t// elsewise, handoff to parent to fire when ready\n\t\telse {\n\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t}\n\n\t\tdelete this.inProcess[ ractive._guid ];\n\t}\n};\n\nfunction getChildQueue ( queue, ractive ) {\n\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n}\n\nfunction fire ( hookQueue, ractive ) {\n\n\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n\thookQueue.hook.fire( ractive );\n\n\t// queue is \"live\" because components can end up being\n\t// added while hooks fire on parents that modify data values.\n\twhile ( childQueue.length ) {\n\t\tfire( hookQueue, childQueue.shift() );\n\t}\n\n\tdelete hookQueue.queue[ ractive._guid ];\n}\n\n\nexport default HookQueue;\n","import { getElement } from 'utils/dom';\nimport { create } from 'utils/object';\nimport { magic } from 'config/environment';\nimport config from 'Ractive/config/config';\nimport Fragment from 'virtualdom/Fragment';\nimport Viewmodel from 'viewmodel/Viewmodel';\nimport Hook from './prototype/shared/hooks/Hook';\nimport HookQueue from './prototype/shared/hooks/HookQueue';\n\nvar constructHook = new Hook( 'construct' ),\n\tconfigHook = new Hook( 'config' ),\n\tinitHook = new HookQueue( 'init' ),\n\tuid = 0;\n\nexport default initialiseRactiveInstance;\n\nfunction initialiseRactiveInstance ( ractive, userOptions = {}, options = {} ) {\n\tvar el;\n\n\tinitialiseProperties( ractive, options );\n\n\t// make this option do what would be expected if someone\n\t// did include it on a new Ractive() or new Component() call.\n\t// Silly to do so (put a hook on the very options being used),\n\t// but handle it correctly, consistent with the intent.\n\tconstructHook.fire( config.getConstructTarget( ractive, userOptions ), userOptions );\n\n\t// init config from Parent and options\n\tconfig.init( ractive.constructor, ractive, userOptions );\n\n\t// TODO this was moved from Viewmodel.extend - should be\n\t// rolled in with other config stuff\n\tif ( ractive.magic && !magic ) {\n\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t}\n\n\tconfigHook.fire( ractive );\n\tinitHook.begin( ractive );\n\n\t// TEMPORARY. This is so we can implement Viewmodel gradually\n\tractive.viewmodel = new Viewmodel( ractive, options.mappings );\n\n\t// hacky circular problem until we get this sorted out\n\t// if viewmodel immediately processes computed properties,\n\t// they may call ractive.get, which calls ractive.viewmodel,\n\t// which hasn't been set till line above finishes.\n\tractive.viewmodel.init();\n\n\t// Render our *root fragment*\n\tif ( ractive.template ) {\n\t\tractive.fragment = new Fragment({\n\t\t\ttemplate: ractive.template,\n\t\t\troot: ractive,\n\t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n\t\t});\n\t}\n\n\tinitHook.end( ractive );\n\n\t// render automatically ( if `el` is specified )\n\tif ( el = getElement( ractive.el ) ) {\n\t\tractive.render( el, ractive.append );\n\t}\n}\n\nfunction initialiseProperties ( ractive, options ) {\n\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t// existed\n\tractive._guid = 'r-' + uid++;\n\n\t// events\n\tractive._subs = create( null );\n\n\t// storage for item configuration from instantiation to reset,\n\t// like dynamic functions or original values\n\tractive._config = {};\n\n\t// two-way bindings\n\tractive._twowayBindings = create( null );\n\n\t// animations (so we can stop any in progress at teardown)\n\tractive._animations = [];\n\n\t// nodes registry\n\tractive.nodes = {};\n\n\t// live queries\n\tractive._liveQueries = [];\n\tractive._liveComponentQueries = [];\n\n\t// bound data functions\n\tractive._boundFunctions = [];\n\n\n\t// properties specific to inline components\n\tif ( options.component ) {\n\t\tractive.parent = options.parent;\n\t\tractive.container = options.container || null;\n\t\tractive.root = ractive.parent.root;\n\n\t\tractive.component = options.component;\n\t\toptions.component.instance = ractive;\n\n\t\t// for hackability, this could be an open option\n\t\t// for any ractive instance, but for now, just\n\t\t// for components and just for ractive...\n\t\tractive._inlinePartials = options.inlinePartials;\n\t} else {\n\t\tractive.root = ractive;\n\t\tractive.parent = ractive.container = null;\n\t}\n}\n","import runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nfunction ComplexParameter ( parameters, key, value ) {\n\tthis.parameters = parameters;\n\tthis.parentFragment = parameters.component.parentFragment;\n\tthis.key = key;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: value,\n\t\troot:     parameters.component.root,\n\t\towner:    this\n\t});\n\n\tthis.parameters.addData( this.key.str, this.fragment.getValue() );\n}\n\nexport default ComplexParameter;\n\nComplexParameter.prototype = {\n\tbubble: function () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\tvar viewmodel = this.parameters.component.instance.viewmodel;\n\n\t\tthis.parameters.addData( this.key.str, this.fragment.getValue() );\n\t\tviewmodel.mark( this.key );\n\n\t\tthis.dirty = false;\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t}\n};\n\n","import { defineProperties } from 'utils/object';\nimport { magic } from 'config/environment';\nimport runloop from 'global/runloop';\n\nexport default function createComponentData ( parameters, proto ) {\n\t// Don't do anything with data at all..\n\tif ( !proto.parameters ) {\n\t\treturn parameters.data;\n\t}\n\t// No magic or legacy requested\n\telse if ( !magic || proto.parameters === 'legacy' ) {\n\t\treturn createLegacyData( parameters );\n\t}\n\t// ES5 ftw!\n\treturn createDataFromPrototype( parameters, proto );\n}\n\nfunction createLegacyData( parameters ) {\n\tvar mappings = parameters.mappings, key;\n\n\tfor ( key in mappings ) {\n\t\tlet mapping = mappings[ key ];\n\t\tmapping.trackData = true;\n\n\t\tif( !mapping.updatable ) {\n\t\t\tparameters.addData( key, mapping.getValue() );\n\t\t}\n\t}\n\n\treturn parameters.data;\n}\n\nfunction createDataFromPrototype( parameters, proto ) {\n\tvar ComponentData = getConstructor( parameters, proto );\n\treturn new ComponentData( parameters );\n}\n\nfunction getConstructor ( parameters, proto ) {\n\tvar protoparams = proto._parameters;\n\n\tif ( !protoparams.Constructor || parameters.newKeys.length ) {\n\t\tprotoparams.Constructor = makeConstructor( parameters, protoparams.defined );\n\t}\n\n\treturn protoparams.Constructor;\n}\n\nfunction makeConstructor ( parameters, defined ) {\n\tvar properties, proto;\n\n\tproperties = parameters.keys.reduce( ( definition, key ) => {\n\t\tdefinition[ key ] = {\n\t\t\tget: function () {\n\t\t\t\tlet mapping = this._mappings[ key ];\n\n\t\t\t\tif ( mapping ) {\n\t\t\t\t\treturn mapping.getValue();\n\t\t\t\t} else {\n\t\t\t\t\treturn this._data[ key ];\n\t\t\t\t}\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tlet mapping = this._mappings[ key ];\n\n\t\t\t\tif ( mapping ) {\n\t\t\t\t\trunloop.start();\n\t\t\t\t\tmapping.setValue( value );\n\t\t\t\t\trunloop.end();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._data[ key ] = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tenumerable: true\n\t\t};\n\n\t\treturn definition;\n\n\t}, defined);\n\n\tfunction ComponentData ( options ) {\n\t\tthis._mappings = options.mappings;\n\t\tthis._data = options.data || {};\n\t}\n\n\tdefineProperties( proto = { toJSON: toJSON }, properties );\n\tproto.constructor = ComponentData;\n\tComponentData.prototype = proto;\n\n\treturn ComponentData;\n}\n\nvar reservedKeys = [ '_data', '_mappings' ];\n\nfunction toJSON() {\n\tvar json = {}, k;\n\n\tfor ( k in this ) {\n\t\tif ( reservedKeys.indexOf( k ) === -1 ) {\n\t\t\tjson[k] = this[k];\n\t\t}\n\t}\n\n\treturn json;\n}\n","import createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\nimport ReferenceExpressionResolver from 'virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport { isFunction } from 'utils/is';\n\nfunction ParameterResolver ( parameters, key, template ) {\n\tvar component, resolve, force;\n\n\tthis.parameters = parameters;\n\tthis.key = key;\n\tthis.resolved = this.ready = false;\n\n\tcomponent = parameters.component;\n\tresolve = this.resolve.bind( this );\n\n\tif ( template.r ) {\n\t\tthis.resolver = createReferenceResolver( component, template.r, resolve );\n\t} else if ( template.x ) {\n\t\tthis.resolver = new ExpressionResolver( component, component.parentFragment, template.x, resolve );\n\t} else if ( template.rx ) {\n\t\tthis.resolver = new ReferenceExpressionResolver( component, template.rx, resolve );\n\t}\n\n\tif ( !this.resolved ) {\n\t\t// if the resolver can force resolution, so can the mapping\n\t\tif ( this.resolver && isFunction( this.resolver.forceResolution ) ) {\n\t\t\tforce = this.resolver.forceResolution.bind( this.resolver );\n\t\t}\n\n\t\t// note the mapping anyway, for the benefit of child components\n\t\tparameters.addMapping( key, undefined, force );\n\t}\n\n\tthis.ready = true;\n}\n\nexport default ParameterResolver;\n\nParameterResolver.prototype = {\n\tresolve: function ( keypath ) {\n\t\tthis.resolved = true;\n\n\t\tif ( this.ready ) {\n\t\t\tthis.readyResolve( keypath );\n\t\t}\n\t\telse {\n\t\t\tthis.notReadyResolve( keypath );\n\t\t}\n\t},\n\n\tnotReadyResolve: function ( keypath ) {\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\tthis.parameters.addData( this.key.str, keypath.value );\n\t\t}\n\t\telse {\n\t\t\tlet mapping = this.parameters.addMapping( this.key, keypath );\n\n\t\t\tif( mapping.getValue() === undefined ){\n\t\t\t\tmapping.updatable = true;\n\t\t\t}\n\t\t}\n\t},\n\n\treadyResolve: function ( keypath ) {\n\t\tvar viewmodel = this.parameters.component.instance.viewmodel;\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\tthis.parameters.addData( this.key.str, keypath.value );\n\t\t\tviewmodel.mark( this.key );\n\t\t}\n\t\telse if ( viewmodel.reversedMappings && viewmodel.reversedMappings[ this.key.str ] ) {\n\t\t\tviewmodel.reversedMappings[ this.key.str ].rebind( keypath );\n\t\t}\n\t\telse {\n\t\t\tviewmodel.mappings[ this.key.str ].resolve( keypath );\n\t\t}\n\n\t}\n};\n","import { INTERPOLATOR } from 'config/types';\nimport { create } from 'utils/object';\nimport { getKeypath } from 'shared/keypaths';\nimport parseJSON from 'utils/parseJSON';\nimport ComplexParameter from './ComplexParameter';\nimport createComponentData from './createComponentData';\nimport Mapping from './Mapping';\nimport ParameterResolver from './ParameterResolver';\n\nexport default function createParameters ( component, proto, attributes ) {\n\tvar parameters, data, defined;\n\n\tif ( !attributes ) {\n\t\treturn { data: {} };\n\t}\n\n\tif ( proto.parameters ) {\n\t\tdefined = getParamsDefinition( proto );\n\t}\n\n\tparameters = new ComponentParameters( component, attributes, defined );\n\tdata = createComponentData( parameters, proto );\n\n\treturn { data: data, mappings: parameters.mappings };\n}\n\nfunction getParamsDefinition( proto ) {\n\tif ( !proto._parameters ) {\n\t\tproto._parameters = { defined: {} };\n\t}\n\telse if( !proto._parameters.defined ) {\n\t\tproto._parameters.defined = {};\n\t}\n\treturn proto._parameters.defined;\n}\n\n\nfunction ComponentParameters ( component, attributes, defined ) {\n\tthis.component = component;\n\tthis.parentViewmodel = component.root.viewmodel;\n\tthis.data = {};\n\tthis.mappings = create( null );\n\tthis.newKeys = []; // TODO it's not obvious that this does anything?\n\tthis.keys = Object.keys( attributes );\n\n\tthis.keys.forEach( key => {\n\t\tif( defined && !defined[ key ] ) {\n\t\t\tthis.newKeys.push( key );\n\t\t}\n\t\tthis.add( getKeypath( key ), attributes[ key ] );\n\t});\n}\n\nComponentParameters.prototype = {\n\tadd: function ( key, template ) {\n\t\t// We have static data\n\t\tif ( typeof template === 'string' ) {\n\t\t\tlet parsed = parseJSON( template );\n\t\t\tthis.addData( key.str, parsed ? parsed.value : template );\n\t\t}\n\t\t// Empty string\n\t\t// TODO valueless attributes also end up here currently\n\t\t// (i.e. `<widget bool>` === `<widget bool=''>`) - this\n\t\t// is probably incorrect\n\t\telse if ( template === 0 ) {\n\t\t\tthis.addData( key.str );\n\t\t}\n\t\t// Interpolators\n\t\telse {\n\t\t\tlet resolver;\n\t\t\t// Single interpolator\n\t\t\tif ( isSingleInterpolator(template) ) {\n\t\t\t\tresolver = new ParameterResolver( this, key, template[0]).resolver;\n\t\t\t}\n\t\t\t// We have a 'complex' parameter, e.g.\n\t\t\t// `<widget foo='{{bar}} {{baz}}'/>`\n\t\t\telse {\n\t\t\t\tresolver = new ComplexParameter( this, key, template );\n\t\t\t}\n\t\t\tthis.component.resolvers.push( resolver );\n\t\t}\n\t},\n\n\taddData: function ( key, value ) {\n\t\tthis.data[ key ] = value;\n\t},\n\n\taddMapping: function ( key, keypath, force ) {\n\t\treturn this.mappings[ key.str ] = new Mapping( key, {\n\t\t\torigin: this.parentViewmodel,\n\t\t\tkeypath: keypath,\n\t\t\tforce: force\n\t\t});\n\t}\n};\n\nfunction isSingleInterpolator( template ){\n\treturn template.length === 1 && template[0].t === INTERPOLATOR;\n}\n\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { warn } from 'utils/log';\n\n// TODO how should event arguments be handled? e.g.\n// <widget on-foo='bar:1,2,3'/>\n// The event 'bar' will be fired on the parent instance\n// when 'foo' fires on the child, but the 1,2,3 arguments\n// will be lost\n\nexport default function propagateEvents ( component, eventsDescriptor ) {\n\tvar eventName;\n\n\tfor ( eventName in eventsDescriptor ) {\n\t\tif ( eventsDescriptor.hasOwnProperty( eventName ) ) {\n\t\t\tpropagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );\n\t\t}\n\t}\n}\n\nfunction propagateEvent ( childInstance, parentInstance, eventName, proxyEventName ) {\n\tif ( typeof proxyEventName !== 'string' ) {\n\t\twarn( 'Components currently only support simple events - you cannot include arguments. Sorry!' );\n\t}\n\n\tchildInstance.on( eventName, function () {\n\t\tvar event, args;\n\n\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\tif ( arguments.length && arguments[0] && arguments[0].node ) {\n\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t}\n\n\t\targs = Array.prototype.slice.call( arguments );\n\n\t\tfireEvent( parentInstance, proxyEventName, { event: event, args: args } );\n\n\t\t// cancel bubbling\n\t\treturn false;\n\t});\n}\n","import createInstance from 'virtualdom/items/Component/initialise/createInstance';\nimport createParameters from 'shared/parameters/createParameters';\nimport propagateEvents from 'virtualdom/items/Component/initialise/propagateEvents';\nimport { COMPONENT } from 'config/types';\nimport updateLiveQueries from 'virtualdom/items/Component/initialise/updateLiveQueries';\nimport { warn } from 'utils/log';\n\nexport default function Component$init ( options, Component ) {\n\tvar parentFragment, root, parameters;\n\n\tif ( !Component ) {\n\t\tthrow new Error( 'Component \"' + this.name + '\" not found' );\n\t}\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\troot = parentFragment.root;\n\n\tthis.root = root;\n\tthis.type = COMPONENT;\n\tthis.name = options.template.e;\n\tthis.index = options.index;\n\tthis.indexRefBindings = {};\n\tthis.yielders = {};\n\tthis.resolvers = [];\n\n\tparameters = createParameters( this, Component.prototype, options.template.a );\n\tcreateInstance( this, Component, parameters, options.template.f, options.template.p );\n\tpropagateEvents( this, options.template.v );\n\n\t// intro, outro and decorator directives have no effect\n\tif ( options.template.t1 || options.template.t2 || options.template.o ) {\n\t\twarn( 'The \"intro\", \"outro\" and \"decorator\" directives have no effect on components' );\n\t}\n\n\tupdateLiveQueries( this );\n}\n","export default function Component$rebind ( oldKeypath, newKeypath ) {\n\tvar query;\n\n\tthis.resolvers.forEach( rebind );\n\n\tfor ( let k in this.yielders ) {\n\t\tif ( this.yielders[k][0] ) {\n\t\t\trebind( this.yielders[k][0] );\n\t\t}\n\t}\n\n\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\tquery._makeDirty();\n\t}\n\n\tfunction rebind ( x ) {\n\t\tx.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function Component$render () {\n\tvar instance = this.instance;\n\n\tinstance.render( this.parentFragment.getNode() );\n\n\tthis.rendered = true;\n\treturn instance.fragment.detach();\n}\n","export default function Component$toString () {\n\treturn this.instance.fragment.toString();\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\nimport { unbind } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\nexport default function Component$unbind () {\n\tvar instance = this.instance;\n\n\tthis.resolvers.forEach( unbind );\n\n\tremoveFromLiveComponentQueries( this );\n\n\t// teardown the instance\n\tinstance.fragment.unbind();\n\tinstance.viewmodel.teardown();\n\n\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t}\n\n\tteardownHook.fire( instance );\n}\n\nfunction removeFromLiveComponentQueries ( component ) {\n\tvar instance, query;\n\n\tinstance = component.root;\n\n\tdo {\n\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery._remove( component );\n\t\t}\n\t} while ( instance = instance.parent );\n}\n","export default function Component$unrender ( shouldDestroy ) {\n\tthis.shouldDestroy = shouldDestroy;\n\tthis.instance.unrender();\n}\n","import { YIELDER, INTERPOLATOR, SECTION, TRIPLE, ELEMENT, PARTIAL, COMMENT, DOCTYPE } from 'config/types';\nimport Text from 'virtualdom/items/Text';\nimport Interpolator from 'virtualdom/items/Interpolator';\nimport Section from 'virtualdom/items/Section/_Section';\nimport Triple from 'virtualdom/items/Triple/_Triple';\nimport Element from 'virtualdom/items/Element/_Element';\nimport Partial from 'virtualdom/items/Partial/_Partial';\nimport getComponent from 'virtualdom/items/Component/getComponent';\nimport Component from 'virtualdom/items/Component/_Component';\nimport Comment from 'virtualdom/items/Comment';\nimport Yielder from 'virtualdom/items/Yielder';\nimport Doctype from 'virtualdom/items/Doctype';\n\nexport default function Fragment$init ( options ) {\n\tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\tthis.parent = this.owner.parentFragment;\n\n\t// inherited properties\n\tthis.root = options.root;\n\tthis.pElement = options.pElement;\n\tthis.context = options.context;\n\tthis.index = options.index;\n\tthis.key = options.key;\n\tthis.registeredIndexRefs = [];\n\n\tthis.items = options.template.map( ( template, i ) => createItem({\n\t\tparentFragment: this,\n\t\tpElement: options.pElement,\n\t\ttemplate: template,\n\t\tindex: i\n\t}) );\n\n\tthis.value = this.argsList = null;\n\tthis.dirtyArgs = this.dirtyValue = true;\n\n\tthis.bound = true;\n}\n\nfunction createItem ( options ) {\n\tif ( typeof options.template === 'string' ) {\n\t\treturn new Text( options );\n\t}\n\n\tswitch ( options.template.t ) {\n\t\tcase YIELDER:      return new Yielder( options );\n\t\tcase INTERPOLATOR: return new Interpolator( options );\n\t\tcase SECTION:      return new Section( options );\n\t\tcase TRIPLE:       return new Triple( options );\n\t\tcase ELEMENT:\n\t\t\tlet constructor;\n\t\t\tif ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {\n\t\t\t\treturn new Component( options, constructor );\n\t\t\t}\n\t\t\treturn new Element( options );\n\t\tcase PARTIAL:      return new Partial( options );\n\t\tcase COMMENT:      return new Comment( options );\n\t\tcase DOCTYPE:      return new Doctype( options );\n\n\t\tdefault: throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );\n\t}\n}","import { assignNewKeypath } from 'shared/keypaths';\n\nexport default function Fragment$rebind ( oldKeypath, newKeypath ) {\n\n\t// assign new context keypath if needed\n\tassignNewKeypath( this, 'context', oldKeypath, newKeypath );\n\n\tthis.items.forEach( item => {\n\t\tif ( item.rebind ) {\n\t\t\titem.rebind( oldKeypath, newKeypath );\n\t\t}\n\t});\n}\n","export default function Fragment$render () {\n\tvar result;\n\n\tif ( this.items.length === 1 ) {\n\t\tresult = this.items[0].render();\n\t} else {\n\t\tresult = document.createDocumentFragment();\n\n\t\tthis.items.forEach( item => {\n\t\t\tresult.appendChild( item.render() );\n\t\t});\n\t}\n\n\tthis.rendered = true;\n\treturn result;\n}\n","export default function Fragment$toString ( escape ) {\n\tif ( !this.items ) {\n\t\treturn '';\n\t}\n\n\treturn this.items.map( escape ? toEscapedString : toString ).join( '' );\n}\n\nfunction toString ( item ) {\n\treturn item.toString();\n}\n\nfunction toEscapedString ( item ) {\n\treturn item.toString( true );\n}","export default function Fragment$unbind () {\n\tif ( !this.bound ) {\n\t\treturn;\n\t}\n\n\tthis.items.forEach( unbindItem );\n\tthis.bound = false;\n}\n\nfunction unbindItem ( item ) {\n\tif ( item.unbind ) {\n\t\titem.unbind();\n\t}\n}\n","export default function Fragment$unrender ( shouldDestroy ) {\n\tif ( !this.rendered ) {\n\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t}\n\n\tthis.items.forEach( i => i.unrender( shouldDestroy ) );\n\tthis.rendered = false;\n}\n","import config from 'Ractive/config/config';\nimport Fragment from 'virtualdom/Fragment';\nimport Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { rootKeypath } from 'shared/keypaths';\n\nvar shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ],\n\tresetHook = new Hook( 'reset' );\n\nexport default function Ractive$reset ( data ) {\n\tvar promise, wrapper, changes, i, rerender;\n\n\tdata = data || {};\n\n\tif ( typeof data !== 'object' ) {\n\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t}\n\n\t// If the root object is wrapped, try and use the wrapper's reset value\n\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t// reset was rejected, we need to replace the object\n\t\t\tthis.data = data;\n\t\t}\n\t} else {\n\t\tthis.data = data;\n\t}\n\n\t// reset config items and track if need to rerender\n\tchanges = config.reset( this );\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t\t\trerender = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( rerender ) {\n\t\tlet component;\n\n\t\tthis.viewmodel.mark( rootKeypath );\n\n\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t \t// flag, otherwise it will assume by default that a parent node\n\t \t// will be detached, and therefore it doesn't need to bother\n\t \t// detaching its own nodes\n\t \tif ( component = this.component ) {\n\t \t\tcomponent.shouldDestroy = true;\n\t \t}\n\n\t\tthis.unrender();\n\n\t\tif ( component ) {\n\t\t\tcomponent.shouldDestroy = false;\n\t\t}\n\n\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t// TODO if we're here, presumably it did?\n\t\tif ( this.fragment.template !== this.template ) {\n\t\t\tthis.fragment.unbind();\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tpromise = this.render( this.el, this.anchor );\n\t} else {\n\t\tpromise = runloop.start( this, true );\n\t\tthis.viewmodel.mark( rootKeypath );\n\t\trunloop.end();\n\t}\n\n\tresetHook.fire( this, data );\n\n\treturn promise;\n}\n","import { default as templateConfigurator } from 'Ractive/config/custom/template/template';\nimport Fragment from 'virtualdom/Fragment';\n\n// TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\nexport default function Ractive$resetTemplate ( template ) {\n\tvar transitionsEnabled, component;\n\n\ttemplateConfigurator.init( null, this, { template: template });\n\n\ttransitionsEnabled = this.transitionsEnabled;\n\tthis.transitionsEnabled = false;\n\n\t// Is this is a component, we need to set the `shouldDestroy`\n\t// flag, otherwise it will assume by default that a parent node\n\t// will be detached, and therefore it doesn't need to bother\n\t// detaching its own nodes\n\tif ( component = this.component ) {\n\t\tcomponent.shouldDestroy = true;\n\t}\n\n\tthis.unrender();\n\n\tif ( component ) {\n\t\tcomponent.shouldDestroy = false;\n\t}\n\n\t// remove existing fragment and create new one\n\tthis.fragment.unbind();\n\tthis.fragment = new Fragment({\n\t\ttemplate: this.template,\n\t\troot: this,\n\t\towner: this\n\t});\n\n\tthis.render( this.el, this.anchor );\n\n\tthis.transitionsEnabled = transitionsEnabled;\n}\n","import { isObject } from 'utils/is';\nimport { getMatchingKeypaths, getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\n\nvar wildcard = /\\*/;\n\nexport default function Ractive$set ( keypath, value ) {\n\tvar map, promise;\n\n\tpromise = runloop.start( this, true );\n\n\t// Set multiple keypaths in one go\n\tif ( isObject( keypath ) ) {\n\t\tmap = keypath;\n\n\t\tfor ( keypath in map ) {\n\t\t\tif ( map.hasOwnProperty( keypath) ) {\n\t\t\t\tvalue = map[ keypath ];\n\t\t\t\tkeypath = getKeypath( normalise( keypath ) );\n\n\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set a single keypath\n\telse {\n\t\tkeypath = getKeypath( normalise( keypath ) );\n\n\t\t// TODO a) wildcard test should probably happen at viewmodel level,\n\t\t// b) it should apply to multiple/single set operations\n\t\tif ( wildcard.test( keypath.str ) ) {\n\t\t\tgetMatchingKeypaths( this, keypath.str ).forEach( keypath => {\n\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t});\n\t\t} else {\n\t\t\tthis.viewmodel.set( keypath, value );\n\t\t}\n\t}\n\n\trunloop.end();\n\n\treturn promise;\n}\n","import add from './shared/add';\n\nexport default function Ractive$subtract ( keypath, d ) {\n\treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n}\n","import Hook from './shared/hooks/Hook';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\n\nvar teardownHook = new Hook( 'teardown' );\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nexport default function Ractive$teardown () {\n\tvar promise;\n\n\tthis.fragment.unbind();\n\tthis.viewmodel.teardown();\n\n\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\n\tthis.shouldDestroy = true;\n\tpromise = ( this.fragment.rendered ? this.unrender() : Promise.resolve() );\n\n\tteardownHook.fire( this );\n\n\tthis._boundFunctions.forEach( deleteFunctionCopy );\n\n\treturn promise;\n}\n\nfunction deleteFunctionCopy ( bound ) {\n\tdelete bound.fn[ bound.prop ];\n}\n","import { badArguments } from 'config/errors';\n\nexport default function Ractive$toggle ( keypath ) {\n\tif ( typeof keypath !== 'string' ) {\n\t\tthrow new TypeError( badArguments );\n\t}\n\n\treturn this.set( keypath, !this.get( keypath ) );\n}\n","export default function Ractive$toHTML () {\n\treturn this.fragment.toString( true );\n}\n","import css from 'global/css';\nimport Hook from './shared/hooks/Hook';\nimport { warn } from 'utils/log';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nvar unrenderHook = new Hook( 'unrender' );\n\nexport default function Ractive$unrender () {\n\tvar promise, shouldDestroy;\n\n\tif ( !this.fragment.rendered ) {\n\t\twarn( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t\treturn Promise.resolve();\n\t}\n\n\tpromise = runloop.start( this, true );\n\n\t// If this is a component, and the component isn't marked for destruction,\n\t// don't detach nodes from the DOM unnecessarily\n\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n\tif ( this.constructor.css ) {\n\t\tpromise.then( () => {\n\t\t\tcss.remove( this.constructor );\n\t\t});\n\t}\n\n\t// Cancel any animations in progress\n\twhile ( this._animations[0] ) {\n\t\tthis._animations[0].stop(); // it will remove itself from the index\n\t}\n\n\tthis.fragment.unrender( shouldDestroy );\n\n\tremoveFromArray( this.el.__ractive_instances__, this );\n\n\tunrenderHook.fire( this );\n\n\trunloop.end();\n\treturn promise;\n}\n","import Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { getKeypath, rootKeypath } from 'shared/keypaths';\n\nvar updateHook = new Hook( 'update' );\n\nexport default function Ractive$update ( keypath ) {\n\tvar promise;\n\n\tkeypath = getKeypath( keypath ) || rootKeypath;\n\n\tpromise = runloop.start( this, true );\n\tthis.viewmodel.mark( keypath );\n\trunloop.end();\n\n\tupdateHook.fire( this, keypath );\n\n\treturn promise;\n}\n","import { arrayContentsMatch } from 'utils/array';\nimport { getKeypath } from 'shared/keypaths';\nimport { isEqual } from 'utils/is';\n\nexport default function Ractive$updateModel ( keypath, cascade ) {\n\tvar values, key, bindings;\n\n\tif ( typeof keypath === 'string' && !cascade ) {\n\t\tbindings = this._twowayBindings[ keypath ];\n\t} else {\n\t\tbindings = [];\n\n\t\tfor ( key in this._twowayBindings ) {\n\t\t\tif ( !keypath || getKeypath( key ).equalsOrStartsWith( keypath ) ) { // TODO is this right?\n\t\t\t\tbindings.push.apply( bindings, this._twowayBindings[ key ]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalues = consolidate( this, bindings );\n\treturn this.set( values );\n}\n\nfunction consolidate ( ractive, bindings ) {\n\tvar values = {}, checkboxGroups = [];\n\n\tbindings.forEach( b => {\n\t\tvar oldValue, newValue;\n\n\t\t// special case - radio name bindings\n\t\tif ( b.radioName && !b.element.node.checked ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - checkbox name bindings come in groups, so\n\t\t// we want to get the value once at most\n\t\tif ( b.checkboxName ) {\n\t\t\tif ( !checkboxGroups[ b.keypath.str ] && !b.changed() ) {\n\t\t\t\tcheckboxGroups.push( b.keypath );\n\t\t\t\tcheckboxGroups[ b.keypath.str ] = b;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\toldValue = b.attribute.value;\n\t\tnewValue = b.getValue();\n\n\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !isEqual( oldValue, newValue ) ) {\n\t\t\tvalues[ b.keypath.str ] = newValue;\n\t\t}\n\t});\n\n\t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n\tif ( checkboxGroups.length ) {\n\t\tcheckboxGroups.forEach( keypath => {\n\t\t\tvar binding, oldValue, newValue;\n\n\t\t\tbinding = checkboxGroups[ keypath.str ]; // one to represent the entire group\n\t\t\toldValue = binding.attribute.value;\n\t\t\tnewValue = binding.getValue();\n\n\t\t\tif ( !arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\tvalues[ keypath.str ] = newValue;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn values;\n}\n","import wrap from 'utils/wrapMethod';\nimport registries from 'Ractive/config/registries';\nimport Ractive from 'Ractive';\n\nexport default function unwrap ( Child ) {\n\tlet options = {};\n\n\twhile ( Child ) {\n\t\taddRegistries( Child, options );\n\t\taddOtherOptions( Child, options );\n\n\t\tif ( Child._Parent !== Ractive ) {\n\t\t\tChild = Child._Parent;\n\t\t} else {\n\t\t\tChild = false;\n\t\t}\n\t}\n\n\treturn options;\n}\n\nfunction addRegistries ( Child, options ) {\n\tregistries.forEach( r => {\n\t\taddRegistry(\n\t\t\tr.useDefaults ? Child.prototype : Child,\n\t\t\toptions, r.name );\n\t});\n}\n\nfunction addRegistry ( target, options, name ) {\n\tvar registry, keys = Object.keys( target[ name ] );\n\n\tif ( !keys.length ) { return; }\n\n\tif ( !( registry = options[ name ] ) ) {\n\t\tregistry = options[ name ] = {};\n\t}\n\n\tkeys\n\t\t.filter( key => !( key in registry ) )\n\t\t.forEach( key => registry[ key ] = target[ name ][ key ] );\n}\n\nfunction addOtherOptions ( Child, options ) {\n\tObject.keys( Child.prototype ).forEach( key => {\n\t\tif ( key === 'computed' ) { return; }\n\n\t\tvar value = Child.prototype[ key ];\n\n\t\tif ( !( key in options ) ) {\n\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t}\n\n\t\t// is it a wrapped function?\n\t\telse if ( typeof options[ key ] === 'function'\n\t\t\t\t&& typeof value === 'function'\n\t\t\t\t&& options[ key ]._method ) {\n\n\t\t\tlet result, needsSuper = value._method;\n\n\t\t\tif ( needsSuper ) { value = value._method; }\n\n\t\t\t// rewrap bound directly to parent fn\n\t\t\tresult = wrap( options[ key ]._method, value );\n\n\t\t\tif ( needsSuper ) { result._method = result; }\n\n\t\t\toptions[ key ] = result;\n\t\t}\n\t});\n}","import { create, defineProperties } from 'utils/object';\nimport config from 'Ractive/config/config';\nimport initialise from 'Ractive/initialise';\nimport Ractive from 'Ractive';\nimport unwrapExtended from './unwrapExtended';\n\nvar uid = 1;\n\nexport default function extend ( options = {} ) {\n\tvar Parent = this, Child, proto;\n\n\t// if we're extending with another Ractive instance...\n\t//\n\t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t//   var Spiderman = Human.extend( Spider );\n\t//\n\t// ...inherit prototype methods and default options as well\n\tif ( options.prototype instanceof Ractive ) {\n\t\toptions = unwrapExtended( options );\n\t}\n\n\tChild = function ( options ) {\n\t\tinitialise( this, options );\n\t};\n\n\tproto = create( Parent.prototype );\n\tproto.constructor = Child;\n\n\t// Static properties\n\tdefineProperties( Child, {\n\t\t// each component needs a unique ID, for managing CSS\n\t\t_guid: { value: uid++ },\n\n\t\t// alias prototype as defaults\n\t\tdefaults: { value: proto },\n\n\t\t// extendable\n\t\textend: { value: extend, writable: true, configurable: true },\n\n\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t_Parent: { value: Parent }\n\t});\n\n\t// extend configuration\n\tconfig.extend( Parent, proto, options );\n\n\tChild.prototype = proto;\n\n\treturn Child;\n}\n","import { TEMPLATE_VERSION } from 'config/template';\n\nvar defaultOptions = {\n\n\t// render placement:\n\tel:                 void 0,\n\tappend:\t\t\t\tfalse,\n\n\t// template:\n\ttemplate:           { v: TEMPLATE_VERSION, t: [] },\n\n\t// parse:     // TODO static delimiters?\n\tpreserveWhitespace: false,\n\tsanitize:           false,\n\tstripComments:      true,\n\tdelimiters:         [ '{{', '}}' ],\n\ttripleDelimiters:   [ '{{{', '}}}' ],\n\tinterpolate:        false,\n\n\t// data & binding:\n\tdata:               {},\n\tcomputed:           {},\n\tmagic:              false,\n\tmodifyArrays:       true,\n\tadapt:              [],\n\tisolated:           false,\n\tparameters: \t\ttrue,\n\ttwoway:             true,\n\tlazy:               false,\n\n\t// transitions:\n\tnoIntro:            false,\n\ttransitionsEnabled: true,\n\tcomplete:           void 0,\n\n\t// css:\n\tcss:                null,\n\tnoCssTransform:     false,\n\n\t// debug:\n\tdebug:              false\n};\n\nexport default defaultOptions;\n","// These are a subset of the easing equations found at\n// https://raw.github.com/danro/easing-js - license info\n// follows:\n\n// --------------------------------------------------\n// easing.js v0.5.4\n// Generic set of easing functions with AMD support\n// https://github.com/danro/easing-js\n// This code may be freely distributed under the MIT license\n// http://danro.mit-license.org/\n// --------------------------------------------------\n// All functions adapted from Thomas Fuchs & Jeremy Kahn\n// Easing Equations (c) 2003 Robert Penner, BSD license\n// https://raw.github.com/danro/easing-js/master/LICENSE\n// --------------------------------------------------\n\n// In that library, the functions named easeIn, easeOut, and\n// easeInOut below are named easeInCubic, easeOutCubic, and\n// (you guessed it) easeInOutCubic.\n//\n// You can add additional easing functions to this list, and they\n// will be globally available.\n\n\nexport default {\n\tlinear: function ( pos ) { return pos; },\n\teaseIn: function ( pos ) { return Math.pow( pos, 3 ); },\n\teaseOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },\n\teaseInOut: function ( pos ) {\n\t\tif ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }\n\t\treturn ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );\n\t}\n};\n","/*global console */\nvar isClient, hasConsole, magic, namespaces, svg, vendors;\n\nisClient = ( typeof document === 'object' );\n\nhasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\tmagic = true;\n} catch ( e ) {\n\tmagic = false;\n}\n\nnamespaces = {\n\thtml:   'http://www.w3.org/1999/xhtml',\n\tmathml: 'http://www.w3.org/1998/Math/MathML',\n\tsvg:    'http://www.w3.org/2000/svg',\n\txlink:  'http://www.w3.org/1999/xlink',\n\txml:    'http://www.w3.org/XML/1998/namespace',\n\txmlns:  'http://www.w3.org/2000/xmlns/'\n};\n\nif ( typeof document === 'undefined' ) {\n\tsvg = false;\n} else {\n\tsvg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );\n}\n\nvendors = [ 'o', 'ms', 'moz', 'webkit' ];\n\nexport { hasConsole, isClient, magic, namespaces, svg, vendors };","var win, doc, exportedShims;\n\nif ( typeof window === 'undefined' ) {\n\texportedShims = null;\n} else {\n\twin = window;\n\tdoc = win.document;\n\texportedShims = {};\n\n\tif ( !doc ) {\n\t\texportedShims = null;\n\t}\n\n\t// Shims for older browsers\n\n\tif ( !Date.now ) {\n\t\tDate.now = function () { return +new Date(); };\n\t}\n\n\tif ( !String.prototype.trim ) {\n\t\tString.prototype.trim = function () {\n\t\t\treturn this.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t\t};\n\t}\n\n\t// Polyfill for Object.keys\n\t// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys\n\tif ( !Object.keys ) {\n\t\tObject.keys = (function () {\n\t\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\n\t\t\t\thasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\n\t\t\t\tdontEnums = [\n\t\t\t\t\t'toString',\n\t\t\t\t\t'toLocaleString',\n\t\t\t\t\t'valueOf',\n\t\t\t\t\t'hasOwnProperty',\n\t\t\t\t\t'isPrototypeOf',\n\t\t\t\t\t'propertyIsEnumerable',\n\t\t\t\t\t'constructor'\n\t\t\t\t],\n\t\t\t\tdontEnumsLength = dontEnums.length;\n\n\t\t\treturn function ( obj ) {\n\t\t\t\tif ( typeof obj !== 'object' && typeof obj !== 'function' || obj === null ) {\n\t\t\t\t\tthrow new TypeError( 'Object.keys called on non-object' );\n\t\t\t\t}\n\n\t\t\t\tvar result = [];\n\n\t\t\t\tfor ( var prop in obj ) {\n\t\t\t\t\tif ( hasOwnProperty.call( obj, prop ) ){\n\t\t\t\t\t\tresult.push( prop );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( hasDontEnumBug ) {\n\t\t\t\t\tfor ( var i=0; i < dontEnumsLength; i++ ) {\n\t\t\t\t\t\tif ( hasOwnProperty.call( obj, dontEnums[i] ) ){\n\t\t\t\t\t\t\tresult.push( dontEnums[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}());\n\t}\n\n\t// TODO: use defineProperty to make these non-enumerable\n\n\t// Array extras\n\tif ( !Array.prototype.indexOf ) {\n\t\tArray.prototype.indexOf = function ( needle, i ) {\n\t\t\tvar len;\n\n\t\t\tif ( i === undefined ) {\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tif ( i < 0 ) {\n\t\t\t\ti+= this.length;\n\t\t\t}\n\n\t\t\tif ( i < 0 ) {\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tfor ( len = this.length; i<len; i++ ) {\n\t\t\t\tif ( this.hasOwnProperty( i ) && this[i] === needle ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t};\n\t}\n\n\tif ( !Array.prototype.forEach ) {\n\t\tArray.prototype.forEach = function ( callback, context ) {\n\t\t\tvar i, len;\n\n\t\t\tfor ( i=0, len=this.length; i<len; i+=1 ) {\n\t\t\t\tif ( this.hasOwnProperty( i ) ) {\n\t\t\t\t\tcallback.call( context, this[i], i, this );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( !Array.prototype.map ) {\n\t\tArray.prototype.map = function ( mapper, context ) {\n\t\t\tvar array = this, i, len, mapped = [], isActuallyString;\n\n\t\t\t// incredibly, if you do something like\n\t\t\t// Array.prototype.map.call( someString, iterator )\n\t\t\t// then `this` will become an instance of String in IE8.\n\t\t\t// And in IE8, you then can't do string[i]. Facepalm.\n\t\t\tif ( array instanceof String ) {\n\t\t\t\tarray = array.toString();\n\t\t\t\tisActuallyString = true;\n\t\t\t}\n\n\t\t\tfor ( i=0, len=array.length; i<len; i+=1 ) {\n\t\t\t\tif ( array.hasOwnProperty( i ) || isActuallyString ) {\n\t\t\t\t\tmapped[i] = mapper.call( context, array[i], i, array );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mapped;\n\t\t};\n\t}\n\n\tif ( typeof Array.prototype.reduce !== 'function' ) {\n\t\tArray.prototype.reduce = function(callback, opt_initialValue){\n\t\t\tvar i, value, len, valueIsSet;\n\n\t\t\tif ('function' !== typeof callback) {\n\t\t\t\tthrow new TypeError(callback + ' is not a function');\n\t\t\t}\n\n\t\t\tlen = this.length;\n\t\t\tvalueIsSet = false;\n\n\t\t\tif ( arguments.length > 1 ) {\n\t\t\t\tvalue = opt_initialValue;\n\t\t\t\tvalueIsSet = true;\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < len; i += 1) {\n\t\t\t\tif ( this.hasOwnProperty( i ) ) {\n\t\t\t\t\tif ( valueIsSet ) {\n\t\t\t\t\t\tvalue = callback(value, this[i], i, this);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalue = this[i];\n\t\t\t\t\tvalueIsSet = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !valueIsSet ) {\n\t\t\t\tthrow new TypeError( 'Reduce of empty array with no initial value' );\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\t}\n\n\tif ( !Array.prototype.filter ) {\n\t\tArray.prototype.filter = function ( filter, context ) {\n\t\t\tvar i, len, filtered = [];\n\n\t\t\tfor ( i=0, len=this.length; i<len; i+=1 ) {\n\t\t\t\tif ( this.hasOwnProperty( i ) && filter.call( context, this[i], i, this ) ) {\n\t\t\t\t\tfiltered[ filtered.length ] = this[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn filtered;\n\t\t};\n\t}\n\n\tif ( !Array.prototype.every ) {\n\t\tArray.prototype.every = function ( iterator, context ) {\n\t\t\tvar t, len, i;\n\n\t\t\tif ( this == null ) {\n\t\t\t\tthrow new TypeError();\n\t\t\t}\n\n\t\t\tt = Object( this );\n\t\t\tlen = t.length >>> 0;\n\n\t\t\tif ( typeof iterator !== 'function' ) {\n\t\t\t\tthrow new TypeError();\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tif ( i in t && !iterator.call( context, t[i], i, t) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/*\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n\tif (!Array.prototype.find) {\n\t\tArray.prototype.find = function(predicate) {\n\t\t\tif (this == null) {\n\t\t\tthrow new TypeError('Array.prototype.find called on null or undefined');\n\t\t\t}\n\t\t\tif (typeof predicate !== 'function') {\n\t\t\tthrow new TypeError('predicate must be a function');\n\t\t\t}\n\t\t\tvar list = Object(this);\n\t\t\tvar length = list.length >>> 0;\n\t\t\tvar thisArg = arguments[1];\n\t\t\tvar value;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (i in list) {\n\t\t\t\t\tvalue = list[i];\n\t\t\t\t\tif (predicate.call(thisArg, value, i, list)) {\n\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\t}\n\t*/\n\n\tif ( typeof Function.prototype.bind !== 'function' ) {\n\t\tFunction.prototype.bind = function ( context ) {\n\t\t\tvar args, fn, Empty, bound, slice = [].slice;\n\n\t\t\tif ( typeof this !== 'function' ) {\n\t\t\t\tthrow new TypeError( 'Function.prototype.bind called on non-function' );\n\t\t\t}\n\n\t\t\targs = slice.call( arguments, 1 );\n\t\t\tfn = this;\n\t\t\tEmpty = function () {};\n\n\t\t\tbound = function () {\n\t\t\t\tvar ctx = this instanceof Empty && context ? this : context;\n\t\t\t\treturn fn.apply( ctx, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\n\t\t\tEmpty.prototype = this.prototype;\n\t\t\tbound.prototype = new Empty();\n\n\t\t\treturn bound;\n\t\t};\n\t}\n\n\t// https://gist.github.com/Rich-Harris/6010282 via https://gist.github.com/jonathantneal/2869388\n\t// addEventListener polyfill IE6+\n\tif ( !win.addEventListener ) {\n\t\t((function(win, doc) {\n\t\t\tvar Event, addEventListener, removeEventListener, head, style, origCreateElement;\n\n\t\t\t// because sometimes inquiring minds want to know\n\t\t\twin.appearsToBeIELessEqual8 = true;\n\n\t\t\tEvent = function ( e, element ) {\n\t\t\t\tvar property, instance = this;\n\n\t\t\t\tfor ( property in e ) {\n\t\t\t\t\tinstance[ property ] = e[ property ];\n\t\t\t\t}\n\n\t\t\t\tinstance.currentTarget =  element;\n\t\t\t\tinstance.target = e.srcElement || element;\n\t\t\t\tinstance.timeStamp = +new Date();\n\n\t\t\t\tinstance.preventDefault = function () {\n\t\t\t\t\te.returnValue = false;\n\t\t\t\t};\n\n\t\t\t\tinstance.stopPropagation = function () {\n\t\t\t\t\te.cancelBubble = true;\n\t\t\t\t};\n\t\t\t};\n\n\t\t\taddEventListener = function ( type, listener ) {\n\t\t\t\tvar element = this, listeners, i;\n\n\t\t\t\tlisteners = element.listeners || ( element.listeners = [] );\n\t\t\t\ti = listeners.length;\n\n\t\t\t\tlisteners[i] = [ listener, function (e) {\n\t\t\t\t\tlistener.call( element, new Event( e, element ) );\n\t\t\t\t}];\n\n\t\t\t\telement.attachEvent( 'on' + type, listeners[i][1] );\n\t\t\t};\n\n\t\t\tremoveEventListener = function ( type, listener ) {\n\t\t\t\tvar element = this, listeners, i;\n\n\t\t\t\tif ( !element.listeners ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlisteners = element.listeners;\n\t\t\t\ti = listeners.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif (listeners[i][0] === listener) {\n\t\t\t\t\t\telement.detachEvent( 'on' + type, listeners[i][1] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twin.addEventListener = doc.addEventListener = addEventListener;\n\t\t\twin.removeEventListener = doc.removeEventListener = removeEventListener;\n\n\t\t\tif ( 'Element' in win ) {\n\t\t\t\twin.Element.prototype.addEventListener = addEventListener;\n\t\t\t\twin.Element.prototype.removeEventListener = removeEventListener;\n\t\t\t} else {\n\t\t\t\t// First, intercept any calls to document.createElement - this is necessary\n\t\t\t\t// because the CSS hack (see below) doesn't come into play until after a\n\t\t\t\t// node is added to the DOM, which is too late for a lot of Ractive setup work\n\t\t\t\torigCreateElement = doc.createElement;\n\n\t\t\t\tdoc.createElement = function ( tagName ) {\n\t\t\t\t\tvar el = origCreateElement( tagName );\n\t\t\t\t\tel.addEventListener = addEventListener;\n\t\t\t\t\tel.removeEventListener = removeEventListener;\n\t\t\t\t\treturn el;\n\t\t\t\t};\n\n\t\t\t\t// Then, mop up any additional elements that weren't created via\n\t\t\t\t// document.createElement (i.e. with innerHTML).\n\t\t\t\thead = doc.getElementsByTagName('head')[0];\n\t\t\t\tstyle = doc.createElement('style');\n\n\t\t\t\thead.insertBefore( style, head.firstChild );\n\n\t\t\t\t//style.styleSheet.cssText = '*{-ms-event-prototype:expression(!this.addEventListener&&(this.addEventListener=addEventListener)&&(this.removeEventListener=removeEventListener))}';\n\t\t\t}\n\t\t})( win, doc ));\n\t}\n\n\t// The getComputedStyle polyfill interacts badly with jQuery, so we don't attach\n\t// it to window. Instead, we export it for other modules to use as needed\n\n\t// https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/getComputedStyle.js\n\tif ( !win.getComputedStyle ) {\n\t\texportedShims.getComputedStyle = (function () {\n\t\t\tvar borderSizes = {};\n\n\t\t\tfunction getPixelSize(element, style, property, fontSize) {\n\t\t\t\tvar\n\t\t\t\tsizeWithSuffix = style[property],\n\t\t\t\tsize = parseFloat(sizeWithSuffix),\n\t\t\t\tsuffix = sizeWithSuffix.split(/\\d/)[0],\n\t\t\t\trootSize;\n\n\t\t\t\tif ( isNaN( size ) ) {\n\t\t\t\t\tif ( /^thin|medium|thick$/.test( sizeWithSuffix ) ) {\n\t\t\t\t\t\tsize = getBorderPixelSize( sizeWithSuffix );\n\t\t\t\t\t\tsuffix = '';\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// TODO...\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfontSize = fontSize != null ? fontSize : /%|em/.test(suffix) && element.parentElement ? getPixelSize(element.parentElement, element.parentElement.currentStyle, 'fontSize', null) : 16;\n\t\t\t\trootSize = property == 'fontSize' ? fontSize : /width/i.test(property) ? element.clientWidth : element.clientHeight;\n\n\t\t\t\treturn (suffix == 'em') ? size * fontSize : (suffix == 'in') ? size * 96 : (suffix == 'pt') ? size * 96 / 72 : (suffix == '%') ? size / 100 * rootSize : size;\n\t\t\t}\n\n\t\t\tfunction getBorderPixelSize ( size ) {\n\t\t\t\tvar div, bcr;\n\n\t\t\t\t// `thin`, `medium` and `thick` vary between browsers. (Don't ever use them.)\n\t\t\t\tif ( !borderSizes[ size ] ) {\n\t\t\t\t\tdiv = document.createElement( 'div' );\n\t\t\t\t\tdiv.style.display = 'block';\n\t\t\t\t\tdiv.style.position = 'fixed';\n\t\t\t\t\tdiv.style.width = div.style.height = '0';\n\t\t\t\t\tdiv.style.borderRight = size + ' solid black';\n\n\t\t\t\t\tdocument.getElementsByTagName( 'body' )[0].appendChild( div );\n\t\t\t\t\tbcr = div.getBoundingClientRect();\n\n\t\t\t\t\tborderSizes[ size ] = bcr.right - bcr.left;\n\t\t\t\t}\n\n\t\t\t\treturn borderSizes[ size ];\n\t\t\t}\n\n\t\t\tfunction setShortStyleProperty(style, property) {\n\t\t\t\tvar\n\t\t\t\tborderSuffix = property == 'border' ? 'Width' : '',\n\t\t\t\tt = property + 'Top' + borderSuffix,\n\t\t\t\tr = property + 'Right' + borderSuffix,\n\t\t\t\tb = property + 'Bottom' + borderSuffix,\n\t\t\t\tl = property + 'Left' + borderSuffix;\n\n\t\t\t\tstyle[property] = (style[t] == style[r] == style[b] == style[l] ? [style[t]]\n\t\t\t\t: style[t] == style[b] && style[l] == style[r] ? [style[t], style[r]]\n\t\t\t\t: style[l] == style[r] ? [style[t], style[r], style[b]]\n\t\t\t\t: [style[t], style[r], style[b], style[l]]).join(' ');\n\t\t\t}\n\n\t\t\tfunction CSSStyleDeclaration(element) {\n\t\t\t\tvar currentStyle, style, fontSize, property;\n\n\t\t\t\tcurrentStyle = element.currentStyle;\n\t\t\t\tstyle = this;\n\t\t\t\tfontSize = getPixelSize(element, currentStyle, 'fontSize', null);\n\n\t\t\t\t// TODO tidy this up, test it, send PR to jonathantneal!\n\t\t\t\tfor (property in currentStyle) {\n\t\t\t\t\tif ( /width|height|margin.|padding.|border.+W/.test(property) ) {\n\t\t\t\t\t\tif ( currentStyle[ property ] === 'auto' ) {\n\t\t\t\t\t\t\tif ( /^width|height/.test( property ) ) {\n\t\t\t\t\t\t\t\t// just use clientWidth/clientHeight...\n\t\t\t\t\t\t\t\tstyle[ property ] = ( property === 'width' ? element.clientWidth : element.clientHeight ) + 'px';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\telse if ( /(?:padding)?Top|Bottom$/.test( property ) ) {\n\t\t\t\t\t\t\t\tstyle[ property ] = '0px';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tstyle[ property ] = getPixelSize(element, currentStyle, property, fontSize) + 'px';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (property === 'styleFloat') {\n\t\t\t\t\t\tstyle.float = currentStyle[property];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstyle[property] = currentStyle[property];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsetShortStyleProperty(style, 'margin');\n\t\t\t\tsetShortStyleProperty(style, 'padding');\n\t\t\t\tsetShortStyleProperty(style, 'border');\n\n\t\t\t\tstyle.fontSize = fontSize + 'px';\n\n\t\t\t\treturn style;\n\t\t\t}\n\n\t\t\tCSSStyleDeclaration.prototype = {\n\t\t\t\tconstructor: CSSStyleDeclaration,\n\t\t\t\tgetPropertyPriority: function () {},\n\t\t\t\tgetPropertyValue: function ( prop ) {\n\t\t\t\t\treturn this[prop] || '';\n\t\t\t\t},\n\t\t\t\titem: function () {},\n\t\t\t\tremoveProperty: function () {},\n\t\t\t\tsetProperty: function () {},\n\t\t\t\tgetPropertyCSSValue: function () {}\n\t\t\t};\n\n\t\t\tfunction getComputedStyle(element) {\n\t\t\t\treturn new CSSStyleDeclaration(element);\n\t\t\t}\n\n\t\t\treturn getComputedStyle;\n\t\t}());\n\t}\n}\n\nexport default exportedShims;\n","// Error messages that are used (or could be) in multiple places\nexport var badArguments = 'Bad arguments';\nexport var noRegistryFunctionReturn = 'A function was specified for \"%s\" %s, but no %s was returned';\nexport var missingPlugin = ( name, type ) => `Missing \"${name}\" ${type} plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#${type}s`;","import { hasOwn } from 'utils/object';\nimport { isArray, isObject, isNumeric } from 'utils/is';\nimport interpolate from 'shared/interpolate';\n\nvar interpolators = {\n\tnumber: function ( from, to ) {\n\t\tvar delta;\n\n\t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfrom = +from;\n\t\tto = +to;\n\n\t\tdelta = to - from;\n\n\t\tif ( !delta ) {\n\t\t\treturn function () { return from; };\n\t\t}\n\n\t\treturn function ( t ) {\n\t\t\treturn from + ( t * delta );\n\t\t};\n\t},\n\n\tarray: function ( from, to ) {\n\t\tvar intermediate, interpolators, len, i;\n\n\t\tif ( !isArray( from ) || !isArray( to ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tintermediate = [];\n\t\tinterpolators = [];\n\n\t\ti = len = Math.min( from.length, to.length );\n\t\twhile ( i-- ) {\n\t\t\tinterpolators[i] = interpolate( from[i], to[i] );\n\t\t}\n\n\t\t// surplus values - don't interpolate, but don't exclude them either\n\t\tfor ( i=len; i<from.length; i+=1 ) {\n\t\t\tintermediate[i] = from[i];\n\t\t}\n\n\t\tfor ( i=len; i<to.length; i+=1 ) {\n\t\t\tintermediate[i] = to[i];\n\t\t}\n\n\t\treturn function ( t ) {\n\t\t\tvar i = len;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tintermediate[i] = interpolators[i]( t );\n\t\t\t}\n\n\t\t\treturn intermediate;\n\t\t};\n\t},\n\n\tobject: function ( from, to ) {\n\t\tvar properties, len, interpolators, intermediate, prop;\n\n\t\tif ( !isObject( from ) || !isObject( to ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tproperties = [];\n\t\tintermediate = {};\n\t\tinterpolators = {};\n\n\t\tfor ( prop in from ) {\n\t\t\tif ( hasOwn.call( from, prop ) ) {\n\t\t\t\tif ( hasOwn.call( to, prop ) ) {\n\t\t\t\t\tproperties.push( prop );\n\t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tintermediate[ prop ] = from[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ( prop in to ) {\n\t\t\tif ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {\n\t\t\t\tintermediate[ prop ] = to[ prop ];\n\t\t\t}\n\t\t}\n\n\t\tlen = properties.length;\n\n\t\treturn function ( t ) {\n\t\t\tvar i = len, prop;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = properties[i];\n\n\t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n\t\t\t}\n\n\t\t\treturn intermediate;\n\t\t};\n\t}\n};\n\nexport default interpolators;\n","import { vendors } from 'config/environment';\n\nvar requestAnimationFrame;\n\n// If window doesn't exist, we don't need requestAnimationFrame\nif ( typeof window === 'undefined' ) {\n\trequestAnimationFrame = null;\n} else {\n\t// https://gist.github.com/paulirish/1579671\n\t(function(vendors, lastTime, window) {\n\n\t\tvar x, setTimeout;\n\n\t\tif ( window.requestAnimationFrame ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {\n\t\t\twindow.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n\t\t}\n\n\t\tif ( !window.requestAnimationFrame ) {\n\t\t\tsetTimeout = window.setTimeout;\n\n\t\t\twindow.requestAnimationFrame = function(callback) {\n\t\t\t\tvar currTime, timeToCall, id;\n\n\t\t\t\tcurrTime = Date.now();\n\t\t\t\ttimeToCall = Math.max( 0, 16 - (currTime - lastTime ) );\n\t\t\t\tid = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );\n\n\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\treturn id;\n\t\t\t};\n\t\t}\n\n\t}( vendors, 0, window ));\n\n\trequestAnimationFrame = window.requestAnimationFrame;\n}\n\nexport default requestAnimationFrame;\n","var getTime;\n\nif ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {\n\tgetTime = function () {\n\t\treturn window.performance.now();\n\t};\n} else {\n\tgetTime = function () {\n\t\treturn Date.now();\n\t};\n}\n\nexport default getTime;\n","import { rootKeypath } from 'shared/keypaths';\n\nexport default function ( fragment ) {\n\tdo {\n\t\tif ( fragment.context !== undefined ) {\n\t\t\treturn fragment.context;\n\t\t}\n\t} while ( fragment = fragment.parent );\n\n\treturn rootKeypath;\n}\n","import rAF from 'utils/requestAnimationFrame';\nimport getTime from 'utils/getTime';\nimport runloop from 'global/runloop';\n\nvar queue = [];\n\nvar animations = {\n\ttick: function () {\n\t\tvar i, animation, now;\n\n\t\tnow = getTime();\n\n\t\trunloop.start();\n\n\t\tfor ( i=0; i<queue.length; i+=1 ) {\n\t\t\tanimation = queue[i];\n\n\t\t\tif ( !animation.tick( now ) ) {\n\t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n\t\t\t\tqueue.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\n\t\trunloop.end();\n\n\t\tif ( queue.length ) {\n\t\t\trAF( animations.tick );\n\t\t} else {\n\t\t\tanimations.running = false;\n\t\t}\n\t},\n\n\tadd: function ( animation ) {\n\t\tqueue.push( animation );\n\n\t\tif ( !animations.running ) {\n\t\t\tanimations.running = true;\n\t\t\trAF( animations.tick );\n\t\t}\n\t},\n\n\t// TODO optimise this\n\tabort: function ( keypath, root ) {\n\t\tvar i = queue.length, animation;\n\n\t\twhile ( i-- ) {\n\t\t\tanimation = queue[i];\n\n\t\t\tif ( animation.root === root && animation.keypath === keypath ) {\n\t\t\t\tanimation.stop();\n\t\t\t}\n\t\t}\n\t}\n};\n\nexport default animations;\n","import { warn } from 'utils/log';\nimport runloop from 'global/runloop';\nimport interpolate from 'shared/interpolate';\n\nvar Animation = function ( options ) {\n\tvar key;\n\n\tthis.startTime = Date.now();\n\n\t// from and to\n\tfor ( key in options ) {\n\t\tif ( options.hasOwnProperty( key ) ) {\n\t\t\tthis[ key ] = options[ key ];\n\t\t}\n\t}\n\n\tthis.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );\n\tthis.running = true;\n\n\tthis.tick();\n};\n\nAnimation.prototype = {\n\ttick: function () {\n\t\tvar elapsed, t, value, timeNow, index, keypath;\n\n\t\tkeypath = this.keypath;\n\n\t\tif ( this.running ) {\n\t\t\ttimeNow = Date.now();\n\t\t\telapsed = timeNow - this.startTime;\n\n\t\t\tif ( elapsed >= this.duration ) {\n\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\tthis.root.viewmodel.set( keypath, this.to );\n\t\t\t\t\trunloop.end();\n\t\t\t\t}\n\n\t\t\t\tif ( this.step ) {\n\t\t\t\t\tthis.step( 1, this.to );\n\t\t\t\t}\n\n\t\t\t\tthis.complete( this.to );\n\n\t\t\t\tindex = this.root._animations.indexOf( this );\n\n\t\t\t\t// TODO investigate why this happens\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\twarn( 'Animation was not found' );\n\t\t\t\t}\n\n\t\t\t\tthis.root._animations.splice( index, 1 );\n\n\t\t\t\tthis.running = false;\n\t\t\t\treturn false; // remove from the stack\n\t\t\t}\n\n\t\t\tt = this.easing ? this.easing ( elapsed / this.duration ) : ( elapsed / this.duration );\n\n\t\t\tif ( keypath !== null ) {\n\t\t\t\tvalue = this.interpolator( t );\n\t\t\t\trunloop.start( this.root );\n\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\trunloop.end();\n\t\t\t}\n\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( t, value );\n\t\t\t}\n\n\t\t\treturn true; // keep in the stack\n\t\t}\n\n\t\treturn false; // remove from the stack\n\t},\n\n\tstop: function () {\n\t\tvar index;\n\n\t\tthis.running = false;\n\n\t\tindex = this.root._animations.indexOf( this );\n\n\t\t// TODO investigate why this happens\n\t\tif ( index === -1 ) {\n\t\t\twarn( 'Animation was not found' );\n\t\t}\n\n\t\tthis.root._animations.splice( index, 1 );\n\t}\n};\n\nexport default Animation;\n","import { matches } from 'utils/dom';\n\nexport default function ( item, noDirty ) {\n\tvar itemMatches;\n\n\tif ( this._isComponentQuery ) {\n\t\titemMatches = !this.selector || item.name === this.selector;\n\t} else {\n\t\titemMatches = item.node ? matches( item.node, this.selector ) : null;\n\t}\n\n\tif ( itemMatches ) {\n\t\tthis.push( item.node || item.instance );\n\n\t\tif ( !noDirty ) {\n\t\t\tthis._makeDirty();\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","export default function () {\n\tvar liveQueries, selector, index;\n\n\tliveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\tselector = this.selector;\n\n\tindex = liveQueries.indexOf( selector );\n\n\tif ( index !== -1 ) {\n\t\tliveQueries.splice( index, 1 );\n\t\tliveQueries[ selector ] = null;\n\t}\n}\n","import sortByItemPosition from './sortByItemPosition';\n\nexport default function ( node, otherNode ) {\n\tvar bitmask;\n\n\tif ( node.compareDocumentPosition ) {\n\t\tbitmask = node.compareDocumentPosition( otherNode );\n\t\treturn ( bitmask & 2 ) ? 1 : -1;\n\t}\n\n\t// In old IE, we can piggy back on the mechanism for\n\t// comparing component positions\n\treturn sortByItemPosition( node, otherNode );\n}\n","import sortByDocumentPosition from './sortByDocumentPosition';\nimport sortByItemPosition from './sortByItemPosition';\n\nexport default function () {\n\tthis.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\tthis._dirty = false;\n}\n","import runloop from 'global/runloop';\n\nexport default function () {\n\tif ( !this._dirty ) {\n\t\tthis._dirty = true;\n\n\t\t// Once the DOM has been updated, ensure the query\n\t\t// is correctly ordered\n\t\trunloop.scheduleTask( () => {\n\t\t\tthis._sort();\n\t\t});\n\t}\n}\n","export default function ( nodeOrComponent ) {\n\tvar index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\n\tif ( index !== -1 ) {\n\t\tthis.splice( index, 1 );\n\t}\n}\n","var eventStack = {\n\tenqueue: function( ractive, event ) {\n\t\tif ( ractive.event ) {\n\t\t\tractive._eventQueue = ractive._eventQueue || [];\n\t\t\tractive._eventQueue.push( ractive.event );\n\t\t}\n\t\tractive.event = event;\n\t},\n\tdequeue: function( ractive ) {\n\t\tif ( ractive._eventQueue && ractive._eventQueue.length ) {\n\t\t\tractive.event = ractive._eventQueue.pop();\n\t\t} else {\n\t\t\tdelete ractive.event;\n\t\t}\n\t}\n};\n\nexport default eventStack;\n","import runloop from 'global/runloop';\nimport { isEqual } from 'utils/is';\n\nvar Observer = function ( ractive, keypath, callback, options ) {\n\tthis.root = ractive;\n\tthis.keypath = keypath;\n\tthis.callback = callback;\n\tthis.defer = options.defer;\n\n\t// default to root as context, but allow it to be overridden\n\tthis.context = ( options && options.context ? options.context : ractive );\n};\n\nObserver.prototype = {\n\tinit: function ( immediate ) {\n\t\tthis.value = this.root.get( this.keypath.str );\n\n\t\tif ( immediate !== false ) {\n\t\t\tthis.update();\n\t\t} else {\n\t\t\tthis.oldValue = this.value;\n\t\t}\n\t},\n\n\tsetValue: function ( value ) {\n\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\tthis.value = value;\n\n\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\trunloop.scheduleTask( () => this.update() );\n\t\t\t} else {\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\t// Prevent infinite loops\n\t\tif ( this.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updating = true;\n\n\t\tthis.callback.call( this.context, this.value, this.oldValue, this.keypath.str );\n\t\tthis.oldValue = this.value;\n\n\t\tthis.updating = false;\n\t}\n};\n\nexport default Observer;\n","import runloop from 'global/runloop';\nimport { getKeypath } from 'shared/keypaths';\nimport { isEqual } from 'utils/is';\nimport getPattern from './getPattern';\n\nvar PatternObserver, wildcard = /\\*/, slice = Array.prototype.slice;\n\nPatternObserver = function ( ractive, keypath, callback, options ) {\n\tthis.root = ractive;\n\n\tthis.callback = callback;\n\tthis.defer = options.defer;\n\n\tthis.keypath = keypath;\n\tthis.regex = new RegExp( '^' + keypath.str.replace( /\\./g, '\\\\.' ).replace( /\\*/g, '([^\\\\.]+)' ) + '$' );\n\tthis.values = {};\n\n\tif ( this.defer ) {\n\t\tthis.proxies = [];\n\t}\n\n\t// default to root as context, but allow it to be overridden\n\tthis.context = ( options && options.context ? options.context : ractive );\n};\n\nPatternObserver.prototype = {\n\tinit: function ( immediate ) {\n\t\tvar values, keypath;\n\n\t\tvalues = getPattern( this.root, this.keypath );\n\n\t\tif ( immediate !== false ) {\n\t\t\tfor ( keypath in values ) {\n\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\tthis.update( getKeypath( keypath ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.values = values;\n\t\t}\n\t},\n\n\tupdate: function ( keypath ) {\n\t\tvar values;\n\n\t\tif ( wildcard.test( keypath.str ) ) {\n\t\t\tvalues = getPattern( this.root, keypath );\n\n\t\t\tfor ( keypath in values ) {\n\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\tthis.update( getKeypath( keypath ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - array mutation should not trigger `array.*`\n\t\t// pattern observer with `array.length`\n\t\tif ( this.root.viewmodel.implicitChanges[ keypath.str ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.defer && this.ready ) {\n\t\t\trunloop.scheduleTask( () => this.getProxy( keypath ).update() );\n\t\t\treturn;\n\t\t}\n\n\t\tthis.reallyUpdate( keypath );\n\t},\n\n\treallyUpdate: function ( keypath ) {\n\t\tvar keypathStr, value, keys, args;\n\n\t\tkeypathStr = keypath.str;\n\t\tvalue = this.root.viewmodel.get( keypath );\n\n\t\t// Prevent infinite loops\n\t\tif ( this.updating ) {\n\t\t\tthis.values[ keypathStr ] = value;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updating = true;\n\n\t\tif ( !isEqual( value, this.values[ keypathStr ] ) || !this.ready ) {\n\t\t\tkeys = slice.call( this.regex.exec( keypathStr ), 1 );\n\t\t\targs = [ value, this.values[ keypathStr ], keypathStr ].concat( keys );\n\n\t\t\tthis.values[ keypathStr ] = value;\n\t\t\tthis.callback.apply( this.context, args );\n\t\t}\n\n\t\tthis.updating = false;\n\t},\n\n\tgetProxy: function ( keypath ) {\n\t\tif ( !this.proxies[ keypath.str ] ) {\n\t\t\tthis.proxies[ keypath.str ] = {\n\t\t\t\tupdate: () => this.reallyUpdate( keypath )\n\t\t\t};\n\t\t}\n\n\t\treturn this.proxies[ keypath.str ];\n\t}\n};\n\nexport default PatternObserver;\n","import runloop from 'global/runloop';\nimport { isClient } from 'config/environment';\nimport { removeFromArray } from 'utils/array';\n\nvar css,\n\tupdate,\n\tstyleElement,\n\thead,\n\tstyleSheet,\n\tinDom,\n\tprefix = '/* Ractive.js component styles */\\n',\n\tcomponentsInPage = {},\n\tstyles = [];\n\nif ( !isClient ) {\n\tcss = null;\n} else {\n\tstyleElement = document.createElement( 'style' );\n\tstyleElement.type = 'text/css';\n\n\thead = document.getElementsByTagName( 'head' )[0];\n\n\tinDom = false;\n\n\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n\t// use styleSheet.cssText instead\n\tstyleSheet = styleElement.styleSheet;\n\n\tupdate = function () {\n\t\tvar css;\n\n\t\tif ( styles.length ) {\n\t\t\tcss = prefix + styles.join( ' ' );\n\n\t\t\tif ( styleSheet ) {\n\t\t\t\tstyleSheet.cssText = css;\n\t\t\t} else {\n\t\t\t\tstyleElement.innerHTML = css;\n\t\t\t}\n\n\t\t\tif ( !inDom ) {\n\t\t\t\thead.appendChild( styleElement );\n\t\t\t\tinDom = true;\n\t\t\t}\n\t\t}\n\n\t\telse if ( inDom ) {\n\t\t\thead.removeChild( styleElement );\n\t\t\tinDom = false;\n\t\t}\n\t};\n\n\tcss = {\n\t\tadd: function ( Component ) {\n\t\t\tif ( !Component.css ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\t// we create this counter so that we can in/decrement it as\n\t\t\t\t// instances are added and removed. When all components are\n\t\t\t\t// removed, the style is too\n\t\t\t\tcomponentsInPage[ Component._guid ] = 0;\n\t\t\t\tstyles.push( Component.css );\n\n\t\t\t\tupdate(); // TODO can we only do this once for each runloop turn, but still ensure CSS is updated before onrender() methods are called?\n\t\t\t}\n\n\t\t\tcomponentsInPage[ Component._guid ] += 1;\n\t\t},\n\n\t\tremove: function ( Component ) {\n\t\t\tif ( !Component.css ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomponentsInPage[ Component._guid ] -= 1;\n\n\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\tremoveFromArray( styles, Component.css );\n\t\t\t\trunloop.scheduleTask( update );\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport default css;\n","export default str => str.trim();\n","export default str => str !== '';\n","import { isArray } from 'utils/is';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\nimport getNewIndices from 'shared/getNewIndices';\n\nvar arrayProto = Array.prototype;\n\nexport default function ( methodName ) {\n\treturn function ( keypath, ...args ) {\n\t\tvar array, newIndices = [], len, promise, result;\n\n\t\tkeypath = getKeypath( normalise( keypath ) );\n\n\t\tarray = this.viewmodel.get( keypath );\n\t\tlen = array.length;\n\n\t\tif ( !isArray( array ) ) {\n\t\t\tthrow new Error( 'Called ractive.' + methodName + '(\\'' + keypath + '\\'), but \\'' + keypath + '\\' does not refer to an array' );\n\t\t}\n\n\t\tnewIndices = getNewIndices( array, methodName, args );\n\n\t\tresult = arrayProto[ methodName ].apply( array, args );\n\t\tpromise = runloop.start( this, true ).then( () => result );\n\n\t\tif ( !!newIndices ) {\n\t\t\tthis.viewmodel.smartUpdate( keypath, array, newIndices );\n\t\t} else {\n\t\t\tthis.viewmodel.mark( keypath );\n\t\t}\n\n\t\trunloop.end();\n\n\t\treturn promise;\n\t};\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'pop' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'push' );\n","import runloop from 'global/runloop';\nimport { defineProperty } from 'utils/object';\nimport getNewIndices from 'shared/getNewIndices';\nimport processWrapper from './processWrapper';\n\nvar patchedArrayProto = [],\n\tmutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ],\n\ttestObj,\n\tpatchArrayMethods,\n\tunpatchArrayMethods;\n\nmutatorMethods.forEach( function ( methodName ) {\n\tvar method = function ( ...args ) {\n\t\tvar newIndices,\n\t\t\tresult,\n\t\t\twrapper,\n\t\t\ti;\n\n\t\tnewIndices = getNewIndices( this, methodName, args );\n\n\t\t// apply the underlying method\n\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\n\t\t// trigger changes\n\t\trunloop.start();\n\n\t\tthis._ractive.setting = true;\n\t\ti = this._ractive.wrappers.length;\n\t\twhile ( i-- ) {\n\t\t\twrapper = this._ractive.wrappers[i];\n\n\t\t\trunloop.addViewmodel( wrapper.root.viewmodel );\n\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t}\n\n\t\trunloop.end();\n\n\t\tthis._ractive.setting = false;\n\t\treturn result;\n\t};\n\n\tdefineProperty( patchedArrayProto, methodName, {\n\t\tvalue: method\n\t});\n});\n\n// can we use prototype chain injection?\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\ntestObj = {};\n\nif ( testObj.__proto__ ) {\n\t// yes, we can\n\tpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = patchedArrayProto;\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = Array.prototype;\n\t};\n}\n\nelse {\n\t// no, we can't\n\tpatchArrayMethods = function ( array ) {\n\t\tvar i, methodName;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tmethodName = mutatorMethods[i];\n\t\t\tdefineProperty( array, methodName, {\n\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tvar i;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t}\n\t};\n}\n\npatchArrayMethods.unpatch = unpatchArrayMethods;\nexport default patchArrayMethods;\n","export default function ( wrapper, array, methodName, newIndices ) {\n\tvar { root, keypath } = wrapper;\n\n\t// If this is a sort or reverse, we just do root.set()...\n\t// TODO use merge logic?\n\tif ( methodName === 'sort' || methodName === 'reverse' ) {\n\t\troot.viewmodel.set( keypath, array );\n\t\treturn;\n\t}\n\n\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n}\n","import { defineProperty } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport { getKeypath } from 'shared/keypaths';\nimport patch from './patch';\n\nvar arrayAdaptor,\n\n\t// helpers\n\tArrayWrapper,\n\terrorMessage;\n\narrayAdaptor = {\n\tfilter: function ( object ) {\n\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t// or the array didn't trigger the get() itself\n\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t},\n\twrap: function ( ractive, array, keypath ) {\n\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t}\n};\n\nArrayWrapper = function ( ractive, array, keypath ) {\n\tthis.root = ractive;\n\tthis.value = array;\n\tthis.keypath = getKeypath( keypath );\n\n\t// if this array hasn't already been ractified, ractify it\n\tif ( !array._ractive ) {\n\n\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\tdefineProperty( array, '_ractive', {\n\t\t\tvalue: {\n\t\t\t\twrappers: [],\n\t\t\t\tinstances: [],\n\t\t\t\tsetting: false\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\n\t\tpatch( array );\n\t}\n\n\t// store the ractive instance, so we can handle transitions later\n\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\tarray._ractive.instances.push( ractive );\n\t}\n\n\tarray._ractive.instances[ ractive._guid ] += 1;\n\tarray._ractive.wrappers.push( this );\n};\n\nArrayWrapper.prototype = {\n\tget: function () {\n\t\treturn this.value;\n\t},\n\tteardown: function () {\n\t\tvar array, storage, wrappers, instances, index;\n\n\t\tarray = this.value;\n\t\tstorage = array._ractive;\n\t\twrappers = storage.wrappers;\n\t\tinstances = storage.instances;\n\n\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t// and immediate setup\n\t\tif ( storage.setting ) {\n\t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n\t\t}\n\n\t\tindex = wrappers.indexOf( this );\n\t\tif ( index === -1 ) {\n\t\t\tthrow new Error( errorMessage );\n\t\t}\n\n\t\twrappers.splice( index, 1 );\n\n\t\t// if nothing else depends on this array, we can revert it to its\n\t\t// natural state\n\t\tif ( !wrappers.length ) {\n\t\t\tdelete array._ractive;\n\t\t\tpatch.unpatch( this.value );\n\t\t}\n\n\t\telse {\n\t\t\t// remove ractive instance if possible\n\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\tindex = instances.indexOf( this.root );\n\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\n\t\t\t\tinstances.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t}\n};\n\nerrorMessage = 'Something went wrong in a rather interesting way';\nexport default arrayAdaptor;\n","var numeric = /^\\s*[0-9]+\\s*$/;\n\nexport default function ( key ) {\n\treturn numeric.test( key ) ? [] : {};\n}\n","import magicAdaptor from './magic';\nimport arrayAdaptor from './array/index';\n\nvar magicArrayAdaptor, MagicArrayWrapper;\n\nif ( magicAdaptor ) {\n\tmagicArrayAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t},\n\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\tMagicArrayWrapper = function ( ractive, array, keypath ) {\n\t\tthis.value = array;\n\n\t\tthis.magic = true;\n\n\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t};\n\n\tMagicArrayWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tthis.arrayWrapper.teardown();\n\t\t\tthis.magicWrapper.teardown();\n\t\t},\n\t\treset: function ( value ) {\n\t\t\treturn this.magicWrapper.reset( value );\n\t\t}\n\t};\n}\n\nexport default magicArrayAdaptor;\n","import { create, hasOwn } from 'utils/object';\n\nvar Parser, ParseError, leadingWhitespace = /^\\s+/;\n\nParseError = function ( message ) {\n\tthis.name = 'ParseError';\n\tthis.message = message;\n\ttry {\n\t\tthrow new Error(message);\n\t} catch (e) {\n\t\tthis.stack = e.stack;\n\t}\n};\n\nParseError.prototype = Error.prototype;\n\nParser = function ( str, options ) {\n\tvar items, item, lineStart = 0;\n\n\tthis.str = str;\n\tthis.options = options || {};\n\tthis.pos = 0;\n\n\tthis.lines = this.str.split( '\\n' );\n\tthis.lineEnds = this.lines.map( line => {\n\t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n\t\tlineStart = lineEnd;\n\t\treturn lineEnd;\n\t}, 0 );\n\n\t// Custom init logic\n\tif ( this.init ) this.init( str, options );\n\n\titems = [];\n\n\twhile ( ( this.pos < this.str.length ) && ( item = this.read() ) ) {\n\t\titems.push( item );\n\t}\n\n\tthis.leftover = this.remaining();\n\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n};\n\nParser.prototype = {\n\tread: function ( converters ) {\n\t\tvar pos, i, len, item;\n\n\t\tif ( !converters ) converters = this.converters;\n\n\t\tpos = this.pos;\n\n\t\tlen = converters.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.pos = pos; // reset for each attempt\n\n\t\t\tif ( item = converters[i]( this ) ) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tgetLinePos: function ( char ) {\n\t\tvar lineNum = 0, lineStart = 0, columnNum;\n\n\t\twhile ( char >= this.lineEnds[ lineNum ] ) {\n\t\t\tlineStart = this.lineEnds[ lineNum ];\n\t\t\tlineNum += 1;\n\t\t}\n\n\t\tcolumnNum = char - lineStart;\n\t\treturn [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!\n\t},\n\n\terror: function ( message ) {\n\t\tvar pos, lineNum, columnNum, line, annotation, error;\n\n\t\tpos = this.getLinePos( this.pos );\n\t\tlineNum = pos[0];\n\t\tcolumnNum = pos[1];\n\n\t\tline = this.lines[ pos[0] - 1 ];\n\t\tannotation = line + '\\n' + new Array( pos[1] ).join( ' ' ) + '^----';\n\n\t\terror = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\\n' + annotation );\n\n\t\terror.line = pos[0];\n\t\terror.character = pos[1];\n\t\terror.shortMessage = message;\n\n\t\tthrow error;\n\t},\n\n\tmatchString: function ( string ) {\n\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\tthis.pos += string.length;\n\t\t\treturn string;\n\t\t}\n\t},\n\n\tmatchPattern: function ( pattern ) {\n\t\tvar match;\n\n\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\tthis.pos += match[0].length;\n\t\t\treturn match[1] || match[0];\n\t\t}\n\t},\n\n\tallowWhitespace: function () {\n\t\tthis.matchPattern( leadingWhitespace );\n\t},\n\n\tremaining: function () {\n\t\treturn this.str.substring( this.pos );\n\t},\n\n\tnextChar: function () {\n\t\treturn this.str.charAt( this.pos );\n\t}\n};\n\nParser.extend = function ( proto ) {\n\tvar Parent = this, Child, key;\n\n\tChild = function ( str, options ) {\n\t\tParser.call( this, str, options );\n\t};\n\n\tChild.prototype = create( Parent.prototype );\n\n\tfor ( key in proto ) {\n\t\tif ( hasOwn.call( proto, key ) ) {\n\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t}\n\t}\n\n\tChild.extend = Parser.extend;\n\treturn Child;\n};\n\nexport default Parser;\n","export var TEXT              = 1;\nexport var INTERPOLATOR      = 2;\nexport var TRIPLE            = 3;\nexport var SECTION           = 4;\nexport var INVERTED          = 5;\nexport var CLOSING           = 6;\nexport var ELEMENT           = 7;\nexport var PARTIAL           = 8;\nexport var COMMENT           = 9;\nexport var DELIMCHANGE       = 10;\nexport var MUSTACHE          = 11;\nexport var TAG               = 12;\nexport var ATTRIBUTE         = 13;\nexport var CLOSING_TAG       = 14;\nexport var COMPONENT         = 15;\nexport var YIELDER           = 16;\nexport var INLINE_PARTIAL    = 17;\nexport var DOCTYPE           = 18;\n\nexport var NUMBER_LITERAL    = 20;\nexport var STRING_LITERAL    = 21;\nexport var ARRAY_LITERAL     = 22;\nexport var OBJECT_LITERAL    = 23;\nexport var BOOLEAN_LITERAL   = 24;\n\nexport var GLOBAL            = 26;\nexport var KEY_VALUE_PAIR    = 27;\n\n\nexport var REFERENCE         = 30;\nexport var REFINEMENT        = 31;\nexport var MEMBER            = 32;\nexport var PREFIX_OPERATOR   = 33;\nexport var BRACKETED         = 34;\nexport var CONDITIONAL       = 35;\nexport var INFIX_OPERATOR    = 36;\n\nexport var INVOCATION        = 40;\n\nexport var SECTION_IF        = 50;\nexport var SECTION_UNLESS    = 51;\nexport var SECTION_EACH      = 52;\nexport var SECTION_WITH      = 53;\nexport var SECTION_IF_WITH   = 54;\nexport var SECTION_PARTIAL   = 55;\n\nexport var ELSE              = 60;\nexport var ELSEIF            = 61;","var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n// Match one or more characters until: \", ', \\, or EOL/EOF.\n// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\nstringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n// Match one escape sequence, including the backslash.\nescapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n// Match one ES5 line continuation (backslash + line terminator).\nlineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n// Helper for defining getDoubleQuotedString and getSingleQuotedString.\nexport default function ( okQuote ) {\n\treturn function ( parser ) {\n\t\tvar start, literal, done, next;\n\n\t\tstart = parser.pos;\n\t\tliteral = '\"';\n\t\tdone = false;\n\n\t\twhile ( !done ) {\n\t\t\tnext = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||\n\t\t\t\tparser.matchString( okQuote ) );\n\t\t\tif ( next ) {\n\t\t\t\tif ( next === '\"' ) {\n\t\t\t\t\tliteral += '\\\\\"';\n\t\t\t\t} else if ( next === \"\\\\'\" ) {\n\t\t\t\t\tliteral += \"'\";\n\t\t\t\t} else {\n\t\t\t\t\tliteral += next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t\t\t\tif ( next ) {\n\t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );\n\t\t\t\t} else {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tliteral += '\"';\n\n\t\t// use JSON.parse to interpret escapes\n\t\treturn JSON.parse( literal );\n\t};\n}","import { STRING_LITERAL } from 'config/types';\nimport makeQuotedStringMatcher from './stringLiteral/makeQuotedStringMatcher';\n\nvar getSingleQuotedString = makeQuotedStringMatcher( '\"' );\nvar getDoubleQuotedString = makeQuotedStringMatcher( \"'\" );\n\nexport default function ( parser ) {\n\tvar start, string;\n\n\tstart = parser.pos;\n\n\tif ( parser.matchString( '\"' ) ) {\n\t\tstring = getDoubleQuotedString( parser );\n\n\t\tif ( !parser.matchString( '\"' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: STRING_LITERAL,\n\t\t\tv: string\n\t\t};\n\t}\n\n\tif ( parser.matchString( \"'\" ) ) {\n\t\tstring = getSingleQuotedString( parser );\n\n\t\tif ( !parser.matchString( \"'\" ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: STRING_LITERAL,\n\t\t\tv: string\n\t\t};\n\t}\n\n\treturn null;\n}\n","import { OBJECT_LITERAL } from 'config/types';\nimport readKeyValuePairs from './objectLiteral/keyValuePairs';\n\nexport default function ( parser ) {\n\tvar start, keyValuePairs;\n\n\tstart = parser.pos;\n\n\t// allow whitespace\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '{' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tkeyValuePairs = readKeyValuePairs( parser );\n\n\t// allow whitespace between final value and '}'\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '}' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tt: OBJECT_LITERAL,\n\t\tm: keyValuePairs\n\t};\n}\n","import { ARRAY_LITERAL } from 'config/types';\nimport readExpressionList from '../../shared/readExpressionList';\n\nexport default function ( parser ) {\n\tvar start, expressionList;\n\n\tstart = parser.pos;\n\n\t// allow whitespace before '['\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '[' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\texpressionList = readExpressionList( parser );\n\n\tif ( !parser.matchString( ']' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tt: ARRAY_LITERAL,\n\t\tm: expressionList\n\t};\n}\n","import readLiteral from './primary/readLiteral';\nimport readReference from './primary/readReference';\nimport readBracketedExpression from './primary/readBracketedExpression';\n\nexport default function ( parser ) {\n\treturn readLiteral( parser )\n\t\t|| readReference( parser )\n\t\t|| readBracketedExpression( parser );\n}\n","import { MEMBER, INVOCATION } from 'config/types';\nimport readPrimary from './readPrimary';\nimport readExpressionList from './shared/readExpressionList';\nimport readRefinement from './shared/readRefinement';\nimport { expectedParen } from './shared/errors';\n\nexport default function ( parser ) {\n\tvar current, expression, refinement, expressionList;\n\n\texpression = readPrimary( parser );\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\twhile ( expression ) {\n\t\tcurrent = parser.pos;\n\n\t\tif ( refinement = readRefinement( parser ) ) {\n\t\t\texpression = {\n\t\t\t\tt: MEMBER,\n\t\t\t\tx: expression,\n\t\t\t\tr: refinement\n\t\t\t};\n\t\t}\n\n\t\telse if ( parser.matchString( '(' ) ) {\n\t\t\tparser.allowWhitespace();\n\t\t\texpressionList = readExpressionList( parser );\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\tparser.error( expectedParen );\n\t\t\t}\n\n\t\t\texpression = {\n\t\t\t\tt: INVOCATION,\n\t\t\t\tx: expression\n\t\t\t};\n\n\t\t\tif ( expressionList ) {\n\t\t\t\texpression.o = expressionList;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn expression;\n}\n","import { PREFIX_OPERATOR } from 'config/types';\nimport { expectedExpression } from './shared/errors';\nimport readMemberOrInvocation from './readMemberOrInvocation';\nimport readExpression from 'parse/converters/readExpression';\n\nvar readTypeOf, makePrefixSequenceMatcher;\n\nmakePrefixSequenceMatcher = function ( symbol, fallthrough ) {\n\treturn function ( parser ) {\n\t\tvar expression;\n\n\t\tif ( expression = fallthrough( parser ) ) {\n\t\t\treturn expression;\n\t\t}\n\n\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\texpression = readExpression( parser );\n\t\tif ( !expression ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\treturn {\n\t\t\ts: symbol,\n\t\t\to: expression,\n\t\t\tt: PREFIX_OPERATOR\n\t\t};\n\t};\n};\n\n// create all prefix sequence matchers, return readTypeOf\n(function() {\n\tvar i, len, matcher, prefixOperators, fallthrough;\n\n\tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\n\tfallthrough = readMemberOrInvocation;\n\tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );\n\t\tfallthrough = matcher;\n\t}\n\n\t// typeof operator is higher precedence than multiplication, so provides the\n\t// fallthrough for the multiplication sequence matcher we're about to create\n\t// (we're skipping void and delete)\n\treadTypeOf = fallthrough;\n}());\n\nexport default readTypeOf;\n","import { INFIX_OPERATOR } from 'config/types';\nimport readTypeof from './readTypeof';\n\nvar readLogicalOr, makeInfixSequenceMatcher;\n\nmakeInfixSequenceMatcher = function ( symbol, fallthrough ) {\n\treturn function ( parser ) {\n\t\tvar start, left, right;\n\n\t\tleft = fallthrough( parser );\n\t\tif ( !left ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t\t// to parse `left` because that would be infinite regress.\n\t\twhile ( true ) {\n\t\t\tstart = parser.pos;\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t   parser.allowWhitespace();\n\n\t\t\t// right operand must also consist of only higher-precedence operators\n\t\t\tright = fallthrough( parser );\n\t\t\tif ( !right ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\tleft = {\n\t\t\t\tt: INFIX_OPERATOR,\n\t\t\t\ts: symbol,\n\t\t\t\to: [ left, right ]\n\t\t\t};\n\n\t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n\t\t\t// we'll return left.\n\t\t}\n\t};\n};\n\n// create all infix sequence matchers, and return readLogicalOr\n(function() {\n\tvar i, len, matcher, infixOperators, fallthrough;\n\n\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t// Each sequence matcher will initially fall through to its higher precedence\n\t// neighbour, and only attempt to match if one of the higher precedence operators\n\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\n\t// A typeof operator is higher precedence than multiplication\n\tfallthrough = readTypeof;\n\tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t\tmatcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );\n\t\tfallthrough = matcher;\n\t}\n\n\t// Logical OR is the fallthrough for the conditional matcher\n\treadLogicalOr = fallthrough;\n}());\n\nexport default readLogicalOr;\n","import { SECTION_EACH, SECTION_IF, SECTION_IF_WITH, SECTION_WITH, SECTION_UNLESS, SECTION_PARTIAL } from 'config/types';\n\nexport default {\n\t'each':    SECTION_EACH,\n\t'if':      SECTION_IF,\n\t'if-with': SECTION_IF_WITH,\n\t'with':    SECTION_WITH,\n\t'unless':  SECTION_UNLESS,\n\t'partial': SECTION_PARTIAL\n};\n","export default function ( haystack, needles ) {\n\tvar i, index, lowest;\n\n\ti = needles.length;\n\twhile ( i-- ) {\n\t\tindex = haystack.indexOf( needles[i] );\n\n\t\t// short circuit\n\t\tif ( !index ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ( index === -1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( !lowest || ( index < lowest ) ) {\n\t\t\tlowest = index;\n\t\t}\n\t}\n\n\treturn lowest || -1;\n}\n","import { lastItem } from 'utils/array';\n\nvar leadingWhitespace = /^[ \\t\\f\\r\\n]+/,\n\ttrailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\nexport default function ( items, leading, trailing ) {\n\tvar item;\n\n\tif ( leading ) {\n\t\titem = items[0];\n\t\tif ( typeof item === 'string' ) {\n\t\t\titem = item.replace( leadingWhitespace, '' );\n\n\t\t\tif ( !item ) {\n\t\t\t\titems.shift();\n\t\t\t} else {\n\t\t\t\titems[0] = item;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( trailing ) {\n\t\titem = lastItem( items );\n\t\tif ( typeof item === 'string' ) {\n\t\t\titem = item.replace( trailingWhitespace, '' );\n\n\t\t\tif ( !item ) {\n\t\t\t\titems.pop();\n\t\t\t} else {\n\t\t\t\titems[ items.length - 1 ] = item;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { create } from 'utils/object';\nimport 'legacy';\n\nvar registryNames, Registry, registries;\n\nregistryNames = [\n\t'adaptors',\n\t'components',\n\t'computed',\n\t'decorators',\n\t'easing',\n\t'events',\n\t'interpolators',\n\t'partials',\n\t'transitions'\n];\n\nRegistry = function ( name, useDefaults ) {\n\tthis.name = name;\n\tthis.useDefaults = useDefaults;\n};\n\nRegistry.prototype = {\n\tconstructor: Registry,\n\n \textend: function ( Parent, proto, options ) {\n\t\tthis.configure(\n\t\t\tthis.useDefaults ? Parent.defaults : Parent,\n\t\t\tthis.useDefaults ? proto : proto.constructor,\n\t\t\toptions );\n\t},\n\n\tinit: function ( Parent, ractive, options ) {\n\t\tthis.configure(\n\t\t\tthis.useDefaults ? Parent.defaults : Parent,\n\t\t\tractive,\n\t\t\toptions );\n\t},\n\n\tconfigure: function ( Parent, target, options ) {\n\t\tvar name = this.name, option = options[ name ], registry;\n\n\t\tregistry = create( Parent[name] );\n\n\t\tfor ( let key in option ) {\n\t\t\tregistry[ key ] = option[ key ];\n\t\t}\n\n\t\ttarget[ name ] = registry;\n\t},\n\n\treset: function ( ractive ) {\n\t\tvar registry = ractive[ this.name ];\n\t\tvar changed = false;\n\t\tObject.keys( registry ).forEach( key => {\n\t\t\tvar item = registry[key];\n\t\t\tif ( item._fn ) {\n\t\t\t\tif ( item._fn.isOwner ) {\n\t\t\t\t\tregistry[key] = item._fn;\n\t\t\t\t} else {\n\t\t\t\t\tdelete registry[key];\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t});\n\t\treturn changed;\n\t}\n};\n\nregistries = registryNames.map( name => new Registry( name, name === 'computed' ) );\n\nexport default registries;","import { detachNode } from 'utils/dom';\n\nexport default function () {\n\treturn detachNode( this.node );\n}\n","import { TEXT } from 'config/types';\nimport { escapeHtml } from 'utils/html';\nimport detach from './shared/detach';\n\nvar Text = function ( options ) {\n\tthis.type = TEXT;\n\tthis.text = options.template;\n};\n\nText.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createTextNode( this.text );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString ( escape ) {\n\t\treturn escape ? escapeHtml( this.text ) : this.text;\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\treturn this.detach();\n\t\t}\n\t}\n};\n\nexport default Text;\n","import runloop from 'global/runloop';\nimport { getKeypath } from 'shared/keypaths';\nimport resolveRef from 'shared/resolveRef';\n\nvar ReferenceResolver = function ( owner, ref, callback ) {\n\tvar keypath;\n\n\tthis.ref = ref;\n\tthis.resolved = false;\n\n\tthis.root = owner.root;\n\tthis.parentFragment = owner.parentFragment;\n\tthis.callback = callback;\n\n\tkeypath = resolveRef( owner.root, ref, owner.parentFragment );\n\tif ( keypath != undefined ) {\n\t\tthis.resolve( keypath );\n\t}\n\n\telse {\n\t\trunloop.addUnresolved( this );\n\t}\n};\n\nReferenceResolver.prototype = {\n\tresolve: function ( keypath ) {\n\t\tif ( this.keypath && !keypath ) {\n\t\t\t// it was resolved, and now it's not. Can happen if e.g. `bar` in\n\t\t\t// `{{foo[bar]}}` becomes undefined\n\t\t\trunloop.addUnresolved( this );\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\tthis.keypath = keypath;\n\t\tthis.callback( keypath );\n\t},\n\n\tforceResolution: function () {\n\t\tthis.resolve( getKeypath( this.ref ) );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tvar keypath;\n\n\t\tif ( this.keypath != undefined ) {\n\t\t\tkeypath = this.keypath.replace( oldKeypath, newKeypath );\n\t\t\t// was a new keypath created?\n\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t// resolve it\n\t\t\t\tthis.resolve( keypath );\n\t\t\t}\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tif ( !this.resolved ) {\n\t\t\trunloop.removeUnresolved( this );\n\t\t}\n\t}\n};\n\n\nexport default ReferenceResolver;\n","import { getKeypath } from 'shared/keypaths'; // TODO find a better way than @\n\nvar IndexResolver = function ( owner, ref, callback ) {\n\tthis.parentFragment = owner.parentFragment;\n\tthis.ref = ref;\n\tthis.callback = callback;\n\n\tref.ref.fragment.registerIndexRef( this );\n\n\tthis.rebind();\n};\n\nIndexResolver.prototype = {\n\trebind: function () {\n\t\tvar index, ref = this.ref.ref;\n\n\t\tif ( ref.ref.t === 'k' ) {\n\t\t\tindex = 'k' + ref.fragment.key;\n\t\t} else {\n\t\t\tindex = 'i' + ref.fragment.index;\n\t\t}\n\n\t\tif ( index !== undefined ) {\n\t\t\tthis.callback( getKeypath( '@' + index ) );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tthis.ref.ref.fragment.unregisterIndexRef( this );\n\t}\n};\n\nexport default IndexResolver;\n","import { REFERENCE } from 'config/types';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\n\nvar MemberResolver = function ( template, resolver, parentFragment ) {\n\tthis.resolver = resolver;\n\tthis.root = resolver.root;\n\tthis.parentFragment = parentFragment;\n\tthis.viewmodel = resolver.root.viewmodel;\n\n\tif ( typeof template === 'string' ) {\n\t\tthis.value = template;\n\t}\n\n\t// Simple reference?\n\telse if ( template.t === REFERENCE ) {\n\t\tthis.refResolver = createReferenceResolver( this, template.n, keypath => {\n\t\t\tthis.resolve( keypath );\n\t\t});\n\t}\n\n\t// Otherwise we have an expression in its own right\n\telse {\n\t\tnew ExpressionResolver( resolver, parentFragment, template, keypath => {\n\t\t\tthis.resolve( keypath );\n\t\t});\n\t}\n};\n\nMemberResolver.prototype = {\n\tresolve: function ( keypath ) {\n\t\tif ( this.keypath ) {\n\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.value = this.viewmodel.get( keypath );\n\n\t\tthis.bind();\n\n\t\tthis.resolver.bubble();\n\t},\n\n\tbind: function () {\n\t\tthis.viewmodel.register( this.keypath, this );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tsetValue: function ( value ) {\n\t\tthis.value = value;\n\t\tthis.resolver.bubble();\n\t},\n\n\tunbind: function () {\n\t\tif ( this.keypath ) {\n\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t}\n\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.unbind();\n\t\t}\n\t},\n\n\tforceResolution: function () {\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.forceResolution();\n\t\t}\n\t}\n};\n\nexport default MemberResolver;\n","import { INTERPOLATOR } from 'config/types';\nimport runloop from 'global/runloop';\nimport { escapeHtml } from 'utils/html';\nimport { detachNode } from 'utils/dom';\nimport { isEqual } from 'utils/is';\nimport unbind from './shared/unbind';\nimport Mustache from './shared/Mustache/_Mustache';\nimport detach from './shared/detach';\n\nvar Interpolator = function ( options ) {\n\tthis.type = INTERPOLATOR;\n\tMustache.init( this, options );\n};\n\nInterpolator.prototype = {\n\tupdate () {\n\t\tthis.node.data = ( this.value == undefined ? '' : this.value );\n\t},\n\tresolve: Mustache.resolve,\n\trebind: Mustache.rebind,\n\tdetach: detach,\n\n\tunbind: unbind,\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createTextNode( this.value != undefined ? this.value : '' );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tdetachNode( this.node );\n\t\t}\n\t},\n\n\tgetValue: Mustache.getValue,\n\n\t// TEMP\n\tsetValue ( value ) {\n\t\tvar wrapper;\n\n\t\t// TODO is there a better way to approach this?\n\t\tif ( this.keypath && ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) ) {\n\t\t\tvalue = wrapper.get();\n\t\t}\n\n\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\tthis.value = value;\n\t\t\tthis.parentFragment.bubble();\n\n\t\t\tif ( this.node ) {\n\t\t\t\trunloop.addView( this );\n\t\t\t}\n\t\t}\n\t},\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\ttoString ( escape ) {\n\t\tvar string = ( this.value != undefined ? '' + this.value : '' );\n\t\treturn escape ? escapeHtml( string ) : string;\n\t}\n};\n\nexport default Interpolator;\n","import Mustache from '../../shared/Mustache/_Mustache';\n\nexport default function( oldKeypath, newKeypath ) {\n\tMustache.rebind.call( this, oldKeypath, newKeypath );\n}\n","import { SECTION, SECTION_UNLESS } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport shuffle from './prototype/shuffle';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nvar Section = function ( options ) {\n\tthis.type = SECTION;\n\tthis.subtype = this.currentSubtype = options.template.n;\n\tthis.inverted = this.subtype === SECTION_UNLESS;\n\n\n\tthis.pElement = options.pElement;\n\n\tthis.fragments = [];\n\tthis.fragmentsToCreate = [];\n\tthis.fragmentsToRender = [];\n\tthis.fragmentsToUnrender = [];\n\n\tif ( options.template.i ) {\n\t\tthis.indexRefs = options.template.i.split(',').map( ( k, i ) => {\n\t\t\treturn { n: k, t: i === 0 ? 'k' : 'i' };\n\t\t});\n\t}\n\n\tthis.renderedFragments = [];\n\n\tthis.length = 0; // number of times this section is rendered\n\n\tMustache.init( this, options );\n};\n\nSection.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetIndexRef: function( name ) {\n\t\tif ( this.indexRefs ) {\n\t\t\tlet i = this.indexRefs.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tlet ref = this.indexRefs[i];\n\t\t\t\tif ( ref.n === name ) {\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetValue: Mustache.getValue,\n\tshuffle: shuffle,\n\trebind: rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Section;\n","import { TRIPLE } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport firstNode from './prototype/firstNode';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nimport unbind from '../shared/unbind';\n\nvar Triple = function ( options ) {\n\tthis.type = TRIPLE;\n\tMustache.init( this, options );\n};\n\nTriple.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfirstNode: firstNode,\n\tgetValue: Mustache.getValue,\n\trebind: Mustache.rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Triple;\n","export default function () {\n\tthis.parentFragment.bubble();\n}\n","import { matches } from 'utils/dom';\n\nexport default function ( selector ) {\n\tif ( !this.node ) {\n\t\t// this element hasn't been rendered yet\n\t\treturn null;\n\t}\n\n\tif ( matches( this.node, selector ) ) {\n\t\treturn this.node;\n\t}\n\n\tif ( this.fragment && this.fragment.find ) {\n\t\treturn this.fragment.find( selector );\n\t}\n}\n","export default function ( selector, query ) {\n\t// Add this node to the query, if applicable, and register the\n\t// query on this element\n\tif ( query._test( this, true ) && query.live ) {\n\t\t( this.liveQueries || ( this.liveQueries = [] ) ).push( query );\n\t}\n\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAll( selector, query );\n\t}\n}\n","export default function ( selector, query ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function ( selector ) {\n\tif ( this.fragment ) {\n\t\treturn this.fragment.findComponent( selector );\n\t}\n}\n","var truthy = /^true|on|yes|1$/i;\nvar isNumeric = /^[0-9]+$/;\n\nexport default function( element, template ) {\n\tvar val, attrs, attributes;\n\n\tattributes = template.a || {};\n\tattrs = {};\n\n\t// attributes that are present but don't have a value (=)\n\t// will be set to the number 0, which we condider to be true\n\t// the string '0', however is false\n\n\tval = attributes.twoway;\n\tif ( val !== undefined ) {\n\t\tattrs.twoway = val === 0 || truthy.test( val );\n\t}\n\n\tval = attributes.lazy;\n\tif ( val !== undefined ) {\n\t\t// check for timeout value\n\t\tif ( val !== 0 && isNumeric.test( val ) ) {\n\t\t\tattrs.lazy = parseInt( val );\n\t\t} else {\n\t\t\tattrs.lazy = val === 0 || truthy.test( val );\n\t\t}\n\t}\n\n\treturn attrs;\n}\n","var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\nsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\nsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\n\ncreateMap = function ( items ) {\n\tvar map = {}, i = items.length;\n\twhile ( i-- ) {\n\t\tmap[ items[i].toLowerCase() ] = items[i];\n\t}\n\treturn map;\n};\n\nmap = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );\n\nexport default function ( elementName ) {\n\tvar lowerCaseElementName = elementName.toLowerCase();\n\treturn map[ lowerCaseElementName ] || lowerCaseElementName;\n}\n","import { namespaces } from 'config/environment';\nimport enforceCase from 'virtualdom/items/Element/shared/enforceCase';\n\nexport default function ( attribute, name ) {\n\tvar colonIndex, namespacePrefix;\n\n\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\tcolonIndex = name.indexOf( ':' );\n\tif ( colonIndex !== -1 ) {\n\n\t\t// looks like we are, yes...\n\t\tnamespacePrefix = name.substr( 0, colonIndex );\n\n\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n\t\t// that only valid namespaces will be used)\n\t\tif ( namespacePrefix !== 'xmlns' ) {\n\t\t\tname = name.substring( colonIndex + 1 );\n\n\t\t\tattribute.name = enforceCase( name );\n\t\t\tattribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];\n\t\t\tattribute.namespacePrefix = namespacePrefix;\n\n\t\t\tif ( !attribute.namespace ) {\n\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// SVG attribute names are case sensitive\n\tattribute.name = ( attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name );\n}\n","import bubble from './prototype/bubble';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport update from './prototype/update';\n\nvar Attribute = function ( options ) {\n\tthis.init( options );\n};\n\nAttribute.prototype = {\n\tbubble: bubble,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tupdate: update\n};\n\nexport default Attribute;\n","import Attribute from '../../Attribute/_Attribute';\n\nexport default function ( element, attributes ) {\n\tvar name, attribute, result = [];\n\n\tfor ( name in attributes ) {\n\t\t// skip binding attributes\n\t\tif ( name === 'twoway' || name === 'lazy') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\tattribute = new Attribute({\n\t\t\t\telement: element,\n\t\t\t\tname:    name,\n\t\t\t\tvalue:   attributes[ name ],\n\t\t\t\troot:    element.root\n\t\t\t});\n\n\t\t\tresult[ name ] = attribute;\n\n\t\t\tif ( name !== 'value' ) {\n\t\t\t\tresult.push( attribute );\n\t\t\t}\n\t\t}\n\t}\n\n\t// value attribute goes last. This is because it\n\t// may get clamped on render otherwise, e.g. in\n\t// `<input type='range' value='999' min='0' max='1000'>`\n\t// since default max is 100\n\tif ( attribute = result.value ) {\n\t\tresult.push( attribute );\n\t}\n\n\treturn result;\n}\n","import ConditionalAttribute from '../../ConditionalAttribute/_ConditionalAttribute';\n\nexport default function ( element, attributes ) {\n\tif ( !attributes ) {\n\t\treturn [];\n\t}\n\n\treturn attributes.map( a => {\n\t\treturn new ConditionalAttribute( element, a );\n\t});\n}\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar ContentEditableBinding = Binding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( !this.root.lazy ) {\n\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t}\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.innerHTML;\n\t}\n});\n\nexport default ContentEditableBinding;\n","import runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar RadioBinding = Binding.extend({\n\tname: 'checked',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\tthis.siblings.push( this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\n\t\tthis.siblings.forEach( binding => {\n\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t});\n\n\t\trunloop.end();\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioBinding;\n","import { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport getSiblings from './shared/getSiblings';\n\nvar RadioNameBinding = Binding.extend({\n\tname: 'name',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n\t},\n\n\tgetInitialValue: function () {\n\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\treturn this.element.getAttribute( 'value' );\n\t\t}\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\tvar node = this.element.node;\n\t\treturn node._ractive ? node._ractive.value : node.value;\n\t},\n\n\thandleChange: function () {\n\t\t// If this <input> is the one that's checked, then the value of its\n\t\t// `name` keypath gets set to its value\n\t\tif ( this.element.node.checked ) {\n\t\t\tBinding.prototype.handleChange.call( this );\n\t\t}\n\t},\n\n\trebound: function ( oldKeypath, newKeypath ) {\n\t\tvar node;\n\n\t\tBinding.prototype.rebound.call( this, oldKeypath, newKeypath );\n\n\t\tif ( node = this.element.node ) {\n\t\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioNameBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxBinding = Binding.extend({\n\tname: 'checked',\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t}\n});\n\nexport default CheckboxBinding;\n","import runloop from 'global/runloop';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar SelectBinding = Binding.extend({\n\tgetInitialValue: function () {\n\t\tvar options = this.element.options, len, i, value, optionWasSelected;\n\n\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\ti = len = options.length;\n\n\t\tif ( !len ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// take the final selected option...\n\t\twhile ( i-- ) {\n\t\t\tif ( options[i].getAttribute( 'selected' ) ) {\n\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\toptionWasSelected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// or the first non-disabled option, if none are selected\n\t\tif ( !optionWasSelected ) {\n\t\t\twhile ( ++i < len ) {\n\t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t// other more expensive work\n\t\tif ( value !== undefined ) {\n\t\t\tthis.element.attributes.value.value = value;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\t// TODO this method is an anomaly... is it necessary?\n\tsetValue: function ( value ) {\n\t\tthis.root.viewmodel.set( this.keypath, value );\n\t},\n\n\tgetValue: function () {\n\t\tvar options, i, len, option, optionValue;\n\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( options[i].selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\treturn optionValue;\n\t\t\t}\n\t\t}\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t}\n});\n\nexport default SelectBinding;\n","import runloop from 'global/runloop';\nimport { arrayContentsMatch } from 'utils/array';\nimport SelectBinding from './SelectBinding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar MultipleSelectBinding = SelectBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.options\n\t\t\t.filter( option => option.getAttribute( 'selected' ) )\n\t\t\t.map( option => option.getAttribute( 'value' ) );\n\t},\n\n\trender: function () {\n\t\tvar valueFromModel;\n\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\n\t\tif ( valueFromModel === undefined ) {\n\t\t\t// get value from DOM, if possible\n\t\t\tthis.handleChange();\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tsetValue: function () {\n\t\tthrow new Error( 'TODO not implemented yet' );\n\t},\n\n\tgetValue: function () {\n\t\tvar selectedValues, options, i, len, option, optionValue;\n\n\t\tselectedValues = [];\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i=0; i<len; i+=1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( option.selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\tselectedValues.push( optionValue );\n\t\t\t}\n\t\t}\n\n\t\treturn selectedValues;\n\t},\n\n\thandleChange: function () {\n\t\tvar attribute, previousValue, value;\n\n\t\tattribute = this.attribute;\n\t\tpreviousValue = attribute.value;\n\n\t\tvalue = this.getValue();\n\n\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t},\n\n\tupdateModel: function () {\n\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t}\n\t}\n});\n\nexport default MultipleSelectBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar FileListBinding = Binding.extend({\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.files;\n\t}\n});\n\nexport default FileListBinding;\n","import GenericBinding from './GenericBinding';\n\nexport default GenericBinding.extend({\n\tgetInitialValue: () => undefined,\n\n\tgetValue: function () {\n\t\tvar value = parseFloat( this.element.node.value );\n\t\treturn isNaN( value ) ? undefined : value;\n\t}\n});\n","import bubble from './prototype/bubble';\nimport fire from './prototype/fire';\nimport getAction from './prototype/getAction';\nimport init from './prototype/init';\nimport listen from './prototype/listen';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport resolve from './prototype/resolve';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar EventHandler = function ( element, name, template ) {\n\tthis.init( element, name, template );\n};\n\nEventHandler.prototype = {\n\tbubble: bubble,\n\tfire: fire,\n\tgetAction: getAction,\n\tinit: init,\n\tlisten: listen,\n\trebind: rebind,\n\trender: render,\n\tresolve: resolve,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default EventHandler;\n","import EventHandler from '../../EventHandler/_EventHandler';\n\nexport default function ( element, template ) {\n\tvar i, name, names, handler, result = [];\n\n\tfor ( name in template ) {\n\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\tnames = name.split( '-' );\n\t\t\ti = names.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\thandler = new EventHandler( element, names[i], template[ name ] );\n\t\t\t\tresult.push( handler );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n","import { warn } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar Decorator = function ( element, template ) {\n\tvar self = this, ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no decorator\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = this.fragment.getArgsList();\n\n\t\tthis.fragment.bubble = function () {\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\tself.params = this.getArgsList();\n\n\t\t\tif ( self.ready ) {\n\t\t\t\tself.update();\n\t\t\t}\n\t\t};\n\t}\n\n\tthis.fn = findInViewHierarchy( 'decorators', ractive, name );\n\n\tif ( !this.fn ) {\n\t\twarn( missingPlugin( name, 'decorator' ) );\n\t}\n};\n\nDecorator.prototype = {\n\tinit: function () {\n\t\tvar node, result, args;\n\n\t\tnode = this.element.node;\n\n\t\tif ( this.params ) {\n\t\t\targs = [ node ].concat( this.params );\n\t\t\tresult = this.fn.apply( this.root, args );\n\t\t} else {\n\t\t\tresult = this.fn.call( this.root, node );\n\t\t}\n\n\t\tif ( !result || !result.teardown ) {\n\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t}\n\n\t\t// TODO does this make sense?\n\t\tthis.actual = result;\n\t\tthis.ready = true;\n\t},\n\n\tupdate: function () {\n\t\tif ( this.actual.update ) {\n\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t}\n\n\t\telse {\n\t\t\tthis.actual.teardown( true );\n\t\t\tthis.init();\n\t\t}\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tteardown: function ( updating ) {\n\t\tthis.torndown = true;\n\t\tif ( this.ready ) {\n\t\t\tthis.actual.teardown();\n\t\t}\n\n\t\tif ( !updating && this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t}\n};\n\nexport default Decorator;\n","export default function ( hyphenatedStr ) {\n\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t\treturn $1.toUpperCase();\n\t});\n}\n","import { isClient, vendors } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\n\nvar prefix, prefixCache, testStyle;\n\nif ( !isClient ) {\n\tprefix = null;\n} else {\n\tprefixCache = {};\n\ttestStyle = createElement( 'div' ).style;\n\n\tprefix = function ( prop ) {\n\t\tvar i, vendor, capped;\n\n\t\tprop = camelCase( prop );\n\n\t\tif ( !prefixCache[ prop ] ) {\n\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// test vendors...\n\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\n\t\t\t\ti = vendors.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvendor = vendors[i];\n\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn prefixCache[ prop ];\n\t};\n}\n\nexport default prefix;\n","import legacy from 'legacy';\nimport { isClient } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport prefix from '../helpers/prefix';\n\nvar getStyle, getComputedStyle;\n\nif ( !isClient ) {\n\tgetStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tgetStyle = function ( props ) {\n\t\tvar computedStyle, styles, i, prop, value;\n\n\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\tif ( typeof props === 'string' ) {\n\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( !isArray( props ) ) {\n\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t}\n\n\t\tstyles = {};\n\n\t\ti = props.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = props[i];\n\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tstyles[ prop ] = value;\n\t\t}\n\n\t\treturn styles;\n\t};\n}\n\nexport default getStyle;\n","import prefix from '../helpers/prefix';\n\nexport default function ( style, value ) {\n\tvar prop;\n\n\tif ( typeof style === 'string' ) {\n\t\tthis.node.style[ prefix( style ) ] = value;\n\t}\n\n\telse {\n\t\tfor ( prop in style ) {\n\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n}\n","import { isClient } from 'config/environment';\nimport { warn } from 'utils/log';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\nimport interpolate from 'shared/interpolate';\nimport Ticker from 'shared/Ticker';\nimport prefix from '../../helpers/prefix';\nimport unprefix from '../../helpers/unprefix';\nimport hyphenate from '../../helpers/hyphenate';\n\nvar createTransitions,\n\ttestStyle,\n\tTRANSITION,\n\tTRANSITIONEND,\n\tCSS_TRANSITIONS_ENABLED,\n\tTRANSITION_DURATION,\n\tTRANSITION_PROPERTY,\n\tTRANSITION_TIMING_FUNCTION,\n\tcanUseCssTransitions = {},\n\tcannotUseCssTransitions = {};\n\nif ( !isClient ) {\n\tcreateTransitions = null;\n} else {\n\ttestStyle = createElement( 'div' ).style;\n\n\t// determine some facts about our environment\n\t(function() {\n\t\tif ( testStyle.transition !== undefined ) {\n\t\t\tTRANSITION = 'transition';\n\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\tTRANSITION = 'webkitTransition';\n\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else {\n\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t}\n\t}());\n\n\tif ( TRANSITION ) {\n\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t}\n\n\tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\n\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t// TODO use a fastdom-style mechanism?\n\t\tsetTimeout( function () {\n\n\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n\t\t\tcheckComplete = function () {\n\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t// which properties\n\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\n\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\tt.node.style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\n\t\t\ttransitionEndHandler = function ( event ) {\n\t\t\t\tvar index;\n\n\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t// still transitioning...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\tcheckComplete();\n\t\t\t};\n\n\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\tsetTimeout( function () {\n\t\t\t\tvar i = changedProperties.length, hash, originalValue, index, propertiesToTransitionInJs = [], prop, suffix;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = changedProperties[i];\n\t\t\t\t\thash = hashPrefix + prop;\n\n\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\n\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\n\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\n\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\twarn( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\n\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t// javascript transitions\n\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\tnew Ticker({\n\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\tstep: function ( pos ) {\n\t\t\t\t\t\t\tvar prop, i;\n\n\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t}\n\n\n\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}, 0 );\n\t\t}, options.delay || 0 );\n\t};\n}\n\nexport default createTransitions;\n","import { vendors } from 'config/environment';\n\nvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\nexport default function ( prop ) {\n\treturn prop.replace( unprefixPattern, '' );\n}\n","import { vendors } from 'config/environment';\n\nvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\nexport default function ( str ) {\n\tvar hyphenated;\n\n\tif ( !str ) {\n\t\treturn ''; // edge case\n\t}\n\n\tif ( vendorPattern.test( str ) ) {\n\t\tstr = '-' + str;\n\t}\n\n\thyphenated = str.replace( /[A-Z]/g, function ( match ) {\n\t\treturn '-' + match.toLowerCase();\n\t});\n\n\treturn hyphenated;\n}\n","import { warn } from 'utils/log';\nimport { isClient } from 'config/environment';\nimport legacy from 'legacy';\nimport prefix from 'virtualdom/items/Element/Transition/helpers/prefix';\nimport Promise from 'utils/Promise';\nimport createTransitions from './createTransitions';\nimport visibility from './visibility';\n\nvar animateStyle, getComputedStyle, resolved;\n\nif ( !isClient ) {\n\tanimateStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tanimateStyle = function ( style, value, options ) {\n\t\tvar to;\n\n\t\tif ( arguments.length === 4 ) {\n\t\t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t\t}\n\n\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t// that way you'll never get CSS transitionend events\n\t\tif ( visibility.hidden ) {\n\t\t\tthis.setStyle( style, value );\n\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t}\n\n\t\tif ( typeof style === 'string' ) {\n\t\t\tto = {};\n\t\t\tto[ style ] = value;\n\t\t} else {\n\t\t\tto = style;\n\n\t\t\t// shuffle arguments\n\t\t\toptions = value;\n\t\t}\n\n\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t// callback function that gets called after the animation completes\n\n\t\t// TODO remove this check in a future version\n\t\tif ( !options ) {\n\t\t\twarn( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t\t\toptions = this;\n\t\t}\n\n\t\tvar promise = new Promise( resolve => {\n\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\tif ( !options.duration ) {\n\t\t\t\tthis.setStyle( to );\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get a list of the properties we're animating\n\t\t\tpropertyNames = Object.keys( to );\n\t\t\tchangedProperties = [];\n\n\t\t\t// Store the current styles\n\t\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\t\tfrom = {};\n\t\t\ti = propertyNames.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = propertyNames[i];\n\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\n\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\tcurrent = 0;\n\t\t\t\t}\n\n\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\tchangedProperties.push( prop );\n\n\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\tthis.node.style[ prefix( prop ) ] = current;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t// will never fire! So we complete early\n\t\t\tif ( !changedProperties.length ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcreateTransitions( this, to, options, changedProperties, resolve );\n\t\t});\n\n\t\treturn promise;\n\t};\n}\n\nexport default animateStyle;\n","import { fillGaps } from 'utils/object';\n\nexport default function ( params, defaults ) {\n\tif ( typeof params === 'number' ) {\n\t\tparams = { duration: params };\n\t}\n\n\telse if ( typeof params === 'string' ) {\n\t\tif ( params === 'slow' ) {\n\t\t\tparams = { duration: 600 };\n\t\t} else if ( params === 'fast' ) {\n\t\t\tparams = { duration: 200 };\n\t\t} else {\n\t\t\tparams = { duration: 400 };\n\t\t}\n\t} else if ( !params ) {\n\t\tparams = {};\n\t}\n\n\treturn fillGaps( {}, params, defaults );\n}\n","import init from './prototype/init';\nimport getStyle from './prototype/getStyle';\nimport setStyle from './prototype/setStyle';\nimport animateStyle from './prototype/animateStyle/_animateStyle';\nimport processParams from './prototype/processParams';\nimport start from './prototype/start';\n\nvar Transition = function ( owner, template, isIntro ) {\n\tthis.init( owner, template, isIntro );\n};\n\nTransition.prototype = {\n\tinit: init,\n\tstart: start,\n\tgetStyle: getStyle,\n\tsetStyle: setStyle,\n\tanimateStyle: animateStyle,\n\tprocessParams: processParams\n};\n\nexport default Transition;\n","import bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport getAttribute from './prototype/getAttribute';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Element = function ( options ) {\n\tthis.init( options );\n};\n\nElement.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetAttribute: getAttribute,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Element;\n","export default function ( string, indent ) {\n\tvar indented;\n\n\tif ( !indent ) {\n\t\treturn string;\n\t}\n\n\tindented = string.split( '\\n' ).map( function ( line, notFirstLine ) {\n\t\treturn notFirstLine ? indent + line : line;\n\t}).join( '\\n' );\n\n\treturn indented;\n}\n","import { fatal, warnOnce } from 'utils/log';\nimport { PARTIAL, TEXT } from 'config/types';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\nimport Mustache from '../shared/Mustache/_Mustache';\nimport rebind from '../shared/Mustache/rebind';\nimport unbind from '../shared/unbind';\nimport getPartialTemplate from './getPartialTemplate';\nimport applyIndent from './applyIndent';\n\nvar Partial = function ( options ) {\n\tvar parentFragment, template;\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\n\tthis.root = parentFragment.root;\n\tthis.type = PARTIAL;\n\tthis.index = options.index;\n\tthis.name = options.template.r;\n\n\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n\tMustache.init( this, options );\n\n\t// If this didn't resolve, it most likely means we have a named partial\n\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t// whose name is the value of `foo`')\n\tif ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\tunbind.call( this ); // prevent any further changes\n\t\tthis.isNamed = true;\n\n\t\tthis.setTemplate( template );\n\t}\n};\n\nPartial.prototype = {\n\tbubble: function () {\n\t\tthis.parentFragment.bubble();\n\t},\n\n\tdetach: function () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind: function ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll: function ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent: function ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents: function ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfirstNode: function () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tfindNextNode: function () {\n\t\treturn this.parentFragment.findNextNode( this );\n\t},\n\n\tgetPartialName: function () {\n\t\tif ( this.isNamed && this.name ) return this.name;\n\t\telse if ( this.value === undefined ) return this.name;\n\t\telse return this.value;\n\t},\n\n\tgetValue: function () {\n\t\treturn this.fragment.getValue();\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\t// named partials aren't bound, so don't rebind\n\t\tif ( !this.isNamed ) {\n\t\t\trebind.call( this, oldKeypath, newKeypath );\n\t\t}\n\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\trender: function () {\n\t\tthis.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\n\t\tthis.rendered = true;\n\t\treturn this.docFrag;\n\t},\n\n\tresolve: Mustache.resolve,\n\n\tsetValue: function ( value ) {\n\t\tvar template;\n\n\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t// nothing has changed, so no work to be done\n\t\t\treturn;\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\ttemplate = getPartialTemplate( this.root, '' + value );\n\t\t}\n\n\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t// and a partial. In those cases, this becomes a named partial\n\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\t\tunbind.call( this );\n\t\t\tthis.isNamed = true;\n\t\t}\n\n\t\tif ( !template ) {\n\t\t\t( this.root.debug ? fatal : warnOnce )( 'Could not find template for partial \"%s\"', this.name );\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.setTemplate( template || [] );\n\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tsetTemplate: function ( template ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t}\n\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template,\n\t\t\troot: this.root,\n\t\t\towner: this,\n\t\t\tpElement: this.parentFragment.pElement\n\t\t});\n\n\t\tthis.fragmentToRender = this.fragment;\n\t},\n\n\ttoString: function ( toString ) {\n\t\tvar string, previousItem, lastLine, match;\n\n\t\tstring = this.fragment.toString( toString );\n\n\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\n\t\tif ( !previousItem || ( previousItem.type !== TEXT ) ) {\n\t\t\treturn string;\n\t\t}\n\n\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\n\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\treturn applyIndent( string, match[0] );\n\t\t}\n\n\t\treturn string;\n\t},\n\n\tunbind: function () {\n\t\tif ( !this.isNamed ) { // dynamic partial - need to unbind self\n\t\t\tunbind.call( this );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t},\n\n\tunrender: function ( shouldDestroy ) {\n\t\tif ( this.rendered ) {\n\t\t\tif( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t}\n\t\t\tthis.rendered = false;\n\t\t}\n\t},\n\n\tupdate: function() {\n\t\tvar target, anchor;\n\n\t\tif ( this.fragmentToUnrender ) {\n\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\tthis.fragmentToUnrender = null;\n\t\t}\n\n\t\tif ( this.fragmentToRender ) {\n\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\tthis.fragmentToRender = null;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t}\n};\n\nexport default Partial;\n","var UnresolvedDependency = function ( computation, ref ) {\n\tthis.computation = computation;\n\tthis.viewmodel = computation.viewmodel;\n\tthis.ref = ref;\n\n\t// TODO this seems like a red flag!\n\tthis.root = this.viewmodel.ractive;\n\tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n};\n\nUnresolvedDependency.prototype = {\n\tresolve: function ( keypath ) {\n\t\tthis.computation.softDeps.push( keypath );\n\t\tthis.computation.unresolvedDeps[ keypath.str ] = null;\n\t\tthis.viewmodel.register( keypath, this.computation, 'computed' );\n\t}\n};\n\nexport default UnresolvedDependency;","export default function ( oldArray, newArray ) {\n\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n\tusedIndices = {};\n\tfirstUnusedIndex = 0;\n\n\tnewIndices = oldArray.map( function ( item, i ) {\n\t\tvar index, start, len;\n\n\t\tstart = firstUnusedIndex;\n\t\tlen = newArray.length;\n\n\t\tdo {\n\t\t\tindex = newArray.indexOf( item, start );\n\n\t\t\tif ( index === -1 ) {\n\t\t\t\tchanged = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstart = index + 1;\n\t\t} while ( usedIndices[ index ] && start < len );\n\n\t\t// keep track of the first unused index, so we don't search\n\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\tif ( index === firstUnusedIndex ) {\n\t\t\tfirstUnusedIndex += 1;\n\t\t}\n\n\t\tif ( index !== i ) {\n\t\t\tchanged = true;\n\t\t}\n\n\t\tusedIndices[ index ] = true;\n\t\treturn index;\n\t});\n\n\treturn newIndices;\n}\n","import { create } from 'utils/object';\nimport adapt from './prototype/adapt';\nimport applyChanges from './prototype/applyChanges';\nimport capture from './prototype/capture';\nimport clearCache from './prototype/clearCache';\nimport compute from './prototype/compute';\nimport get from './prototype/get';\nimport init from './prototype/init';\nimport map from './prototype/map';\nimport mark from './prototype/mark';\nimport merge from './prototype/merge';\nimport register from './prototype/register';\nimport release from './prototype/release';\nimport set from './prototype/set';\nimport smartUpdate from './prototype/smartUpdate';\nimport teardown from './prototype/teardown';\nimport unregister from './prototype/unregister';\n\nvar Viewmodel = function ( ractive, mappings ) {\n\tvar key, mapping;\n\n\tthis.ractive = ractive; // TODO eventually, we shouldn't need this reference\n\n\t// set up explicit mappings\n\tthis.mappings = mappings || create( null );\n\tfor ( key in mappings ) {\n\t\tmappings[ key ].initViewmodel( this );\n\t}\n\n\tif ( ractive.data && ractive.parameters !== true ) {\n\t\t// if data exists locally, but is missing on the parent,\n\t\t// we transfer ownership to the parent\n\t\tfor ( key in ractive.data ) {\n\t\t\tif ( ( mapping = this.mappings[ key ] ) && mapping.getValue() === undefined ) {\n\t\t\t\tmapping.setValue( ractive.data[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n\tthis.cacheMap = create( null );\n\n\tthis.deps = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\tthis.depsMap = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\n\tthis.patternObservers = [];\n\n\tthis.specials = create( null );\n\n\tthis.wrapped = create( null );\n\tthis.computations = create( null );\n\n\tthis.captureGroups = [];\n\tthis.unresolvedImplicitDependencies = [];\n\n\tthis.changes = [];\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n};\n\nViewmodel.prototype = {\n\tadapt: adapt,\n\tapplyChanges: applyChanges,\n\tcapture: capture,\n\tclearCache: clearCache,\n\tcompute: compute,\n\tget: get,\n\tinit: init,\n\tmap: map,\n\tmark: mark,\n\tmerge: merge,\n\tregister: register,\n\trelease: release,\n\tset: set,\n\tsmartUpdate: smartUpdate,\n\tteardown: teardown,\n\tunregister: unregister\n};\n\nexport default Viewmodel;\n","import { YIELDER } from 'config/types';\nimport { warn } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport initialise from 'Ractive/initialise';\n\nexport default function ( component, Component, parameters, yieldTemplate, partials ) {\n\tvar instance, parentFragment, ractive, fragment, container, inlinePartials = {};\n\n\tparentFragment = component.parentFragment;\n\tractive = component.root;\n\n\tpartials = partials || {};\n\textend( inlinePartials, partials || {} );\n\n\t// Make contents available as a {{>content}} partial\n\tpartials.content = yieldTemplate || [];\n\n\t// set a default partial for yields with no name\n\tinlinePartials[''] = partials.content;\n\n\tif ( Component.defaults.el ) {\n\t\twarn( 'The <%s/> component has a default `el` property; it has been disregarded', component.name );\n\t}\n\n\t// find container\n\tfragment = parentFragment;\n\twhile ( fragment ) {\n\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\tcontainer = fragment.owner.container;\n\t\t\tbreak;\n\t\t}\n\n\t\tfragment = fragment.parent;\n\t}\n\n\tinstance = create( Component.prototype );\n\n\tinitialise( instance, {\n\t\tel: null,\n\t\tappend: true,\n\t\tdata: parameters.data,\n\t\tpartials: partials,\n\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\tmodifyArrays: ractive.modifyArrays,\n\t\t// need to inherit runtime parent adaptors\n\t\tadapt: ractive.adapt\n\t}, {\n\t\tparent: ractive,\n\t\tcomponent: component,\n\t\tcontainer: container,\n\t\tmappings: parameters.mappings,\n\t\tinlinePartials: inlinePartials\n\t});\n\n\treturn instance;\n}\n","export default function ( component ) {\n\tvar ancestor, query;\n\n\t// If there's a live query for this component type, add it\n\tancestor = component.root;\n\twhile ( ancestor ) {\n\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery.push( component.instance );\n\t\t}\n\n\t\tancestor = ancestor.parent;\n\t}\n}\n","import detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Component = function ( options, Constructor ) {\n\tthis.init( options, Constructor );\n};\n\nComponent.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Component;\n","import { COMMENT } from 'config/types';\nimport detach from './shared/detach';\n\nvar Comment = function ( options ) {\n\tthis.type = COMMENT;\n\tthis.value = options.template.c;\n};\n\nComment.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createComment( this.value );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString () {\n\t\treturn '<!--' + this.value + '-->';\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t}\n\t}\n};\n\nexport default Comment;\n","import { YIELDER } from 'config/types';\nimport runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\nimport { isArray } from 'utils/is';\n\nvar Yielder = function ( options ) {\n\tvar container, component;\n\n\tthis.type = YIELDER;\n\n\tthis.container = container = options.parentFragment.root;\n\tthis.component = component = container.component;\n\n\tthis.container = container;\n\tthis.containerFragment = options.parentFragment;\n\tthis.parentFragment = component.parentFragment;\n\n\tlet name = this.name = options.template.n || '';\n\n\tthis.fragment = new Fragment({\n\t\towner: this,\n\t\troot: container.parent,\n\t\ttemplate: container._inlinePartials[ name ] || [],\n\t\tpElement: this.containerFragment.pElement\n\t});\n\n\t// even though only one yielder is allowed, we need to have an array of them\n\t// as it's possible to cause a yielder to be created before the last one\n\t// was destroyed in the same turn of the runloop\n\tif ( !isArray( component.yielders[ name ] ) ) {\n\t\tcomponent.yielders[ name ] = [ this ];\n\t} else {\n\t\tcomponent.yielders[ name ].push( this );\n\t}\n\n\trunloop.scheduleTask( () => {\n\t\tif ( component.yielders[ name ].length > 1 ) {\n\t\t\tthrow new Error( 'A component template can only have one {{yield' + (name ? ' ' + name : '') + '}} declaration at a time' );\n\t\t}\n\t});\n};\n\nYielder.prototype = {\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfindNextNode () {\n\t\treturn this.containerFragment.findNextNode( this );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tgetValue ( options ) {\n\t\treturn this.fragment.getValue( options );\n\t},\n\n\trender () {\n\t\treturn this.fragment.render();\n\t},\n\n\tunbind () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tthis.fragment.unrender( shouldDestroy );\n\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\ttoString () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default Yielder;\n","import noop from 'utils/noop';\n\nvar Doctype = function ( options ) {\n\tthis.declaration = options.template.a;\n};\n\nDoctype.prototype = {\n\tinit: noop,\n\trender: noop,\n\tunrender: noop,\n\tteardown: noop,\n\ttoString () {\n\t\treturn '<!DOCTYPE' + this.declaration + '>';\n\t}\n};\n\nexport default Doctype;","import bubble from './Fragment/prototype/bubble';\nimport detach from './Fragment/prototype/detach';\nimport find from './Fragment/prototype/find';\nimport findAll from './Fragment/prototype/findAll';\nimport findAllComponents from './Fragment/prototype/findAllComponents';\nimport findComponent from './Fragment/prototype/findComponent';\nimport findNextNode from './Fragment/prototype/findNextNode';\nimport firstNode from './Fragment/prototype/firstNode';\nimport getArgsList from './Fragment/prototype/getArgsList';\nimport getNode from './Fragment/prototype/getNode';\nimport getValue from './Fragment/prototype/getValue';\nimport init from './Fragment/prototype/init';\nimport rebind from './Fragment/prototype/rebind';\nimport render from './Fragment/prototype/render';\nimport toString from './Fragment/prototype/toString';\nimport unbind from './Fragment/prototype/unbind';\nimport unrender from './Fragment/prototype/unrender';\n\nvar Fragment = function ( options ) {\n\tthis.init( options );\n};\n\nFragment.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetArgsList: getArgsList,\n\tgetNode: getNode,\n\tgetValue: getValue,\n\tinit: init,\n\trebind: rebind,\n\tregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tif ( idxs.indexOf( idx ) === -1 ) {\n\t\t\tidxs.push( idx );\n\t\t}\n\t},\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tidxs.splice( idxs.indexOf( idx ), 1 );\n\t},\n\tunrender: unrender\n};\n\nexport default Fragment;\n","import { isArray } from 'utils/is';\nimport runloop from 'global/runloop';\nimport { PARTIAL, COMPONENT, ELEMENT } from 'config/types';\n\nexport default function ( name, partial ) {\n\tvar promise, collection = [];\n\n\tfunction collect( source, dest, ractive ) {\n\t\t// if this is a component and it has its own partial, bail\n\t\tif ( ractive && ractive.partials[name] ) return;\n\n\t\tsource.forEach( item => {\n\t\t\t// queue to rerender if the item is a partial and the current name matches\n\t\t\tif ( item.type === PARTIAL && item.getPartialName() === name ) {\n\t\t\t\tdest.push( item );\n\t\t\t}\n\n\t\t\t// if it has a fragment, process its items\n\t\t\tif ( item.fragment ) {\n\t\t\t\tcollect( item.fragment.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it has fragments\n\t\t\tif ( isArray( item.fragments ) ) {\n\t\t\t\tcollect( item.fragments, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is itself a fragment, process its items\n\t\t\telse if ( isArray( item.items ) ) {\n\t\t\t\tcollect( item.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is a component, step in and process its items\n\t\t\telse if ( item.type === COMPONENT && item.instance ) {\n\t\t\t\tcollect( item.instance.fragment.items, dest, item.instance );\n\t\t\t}\n\n\t\t\t// if the item is an element, process its attributes too\n\t\t\tif ( item.type === ELEMENT ) {\n\t\t\t\tif ( isArray( item.attributes ) ) {\n\t\t\t\t\tcollect( item.attributes, dest, ractive );\n\t\t\t\t}\n\n\t\t\t\tif ( isArray( item.conditionalAttributes ) ) {\n\t\t\t\t\tcollect( item.conditionalAttributes, dest, ractive );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tcollect( this.fragment.items, collection );\n\tthis.partials[name] = partial;\n\n\tpromise = runloop.start( this, true );\n\n\tcollection.forEach( item => {\n\t\titem.value = undefined;\n\t\titem.setValue( name );\n\t});\n\n\trunloop.end();\n\n\treturn promise;\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'reverse' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'shift' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'sort' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'splice' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'unshift' );\n","import add from 'Ractive/prototype/add';\nimport animate from 'Ractive/prototype/animate';\nimport detach from 'Ractive/prototype/detach';\nimport find from 'Ractive/prototype/find';\nimport findAll from 'Ractive/prototype/findAll';\nimport findAllComponents from 'Ractive/prototype/findAllComponents';\nimport findComponent from 'Ractive/prototype/findComponent';\nimport findContainer from 'Ractive/prototype/findContainer';\nimport findParent from 'Ractive/prototype/findParent';\nimport fire from 'Ractive/prototype/fire';\nimport get from 'Ractive/prototype/get';\nimport insert from 'Ractive/prototype/insert';\nimport merge from 'Ractive/prototype/merge';\nimport observe from 'Ractive/prototype/observe';\nimport observeOnce from 'Ractive/prototype/observeOnce';\nimport off from 'Ractive/prototype/off';\nimport on from 'Ractive/prototype/on';\nimport once from 'Ractive/prototype/once';\nimport pop from 'Ractive/prototype/pop';\nimport push from 'Ractive/prototype/push';\nimport render from 'Ractive/prototype/render';\nimport reset from 'Ractive/prototype/reset';\nimport resetPartial from 'Ractive/prototype/resetPartial';\nimport resetTemplate from 'Ractive/prototype/resetTemplate';\nimport reverse from 'Ractive/prototype/reverse';\nimport set from 'Ractive/prototype/set';\nimport shift from 'Ractive/prototype/shift';\nimport sort from 'Ractive/prototype/sort';\nimport splice from 'Ractive/prototype/splice';\nimport subtract from 'Ractive/prototype/subtract';\nimport teardown from 'Ractive/prototype/teardown';\nimport toggle from 'Ractive/prototype/toggle';\nimport toHTML from 'Ractive/prototype/toHTML';\nimport unrender from 'Ractive/prototype/unrender';\nimport unshift from 'Ractive/prototype/unshift';\nimport update from 'Ractive/prototype/update';\nimport updateModel from 'Ractive/prototype/updateModel';\n\nexport default {\n\tadd: add,\n\tanimate: animate,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindContainer: findContainer,\n\tfindParent: findParent,\n\tfire: fire,\n\tget: get,\n\tinsert: insert,\n\tmerge: merge,\n\tobserve: observe,\n\tobserveOnce: observeOnce,\n\toff: off,\n\ton: on,\n\tonce: once,\n\tpop: pop,\n\tpush: push,\n\trender: render,\n\treset: reset,\n\tresetPartial: resetPartial,\n\tresetTemplate: resetTemplate,\n\treverse: reverse,\n\tset: set,\n\tshift: shift,\n\tsort: sort,\n\tsplice: splice,\n\tsubtract: subtract,\n\tteardown: teardown,\n\ttoggle: toggle,\n\ttoHTML: toHTML,\n\ttoHtml: toHTML,\n\tunrender: unrender,\n\tunshift: unshift,\n\tupdate: update,\n\tupdateModel: updateModel\n};\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function( node ) {\n\tvar info = {}, priv, indices;\n\n\tif ( !node || !( priv = node._ractive ) ) {\n\t\treturn info;\n\t}\n\n\tinfo.ractive = priv.root;\n\tinfo.keypath = priv.keypath.str;\n\tinfo.index = {};\n\n\t// find all index references and resolve them\n\tif ( indices = findIndexRefs( priv.proxy.parentFragment ) ) {\n\t\tinfo.index = findIndexRefs.resolve( indices );\n\t}\n\n\treturn info;\n}\n","import defaults from 'Ractive/config/defaults';\nimport easing from 'Ractive/static/easing';\nimport interpolators from 'Ractive/static/interpolators';\nimport { magic, svg } from 'config/environment';\nimport { defineProperties, extend as extendObj } from 'utils/object';\nimport proto from 'Ractive/prototype';\nimport Promise from 'utils/Promise';\nimport extend from 'extend/_extend';\nimport parse from 'parse/_parse';\nimport getNodeInfo from 'Ractive/static/getNodeInfo';\nimport initialise from 'Ractive/initialise';\n\nvar Ractive, properties;\n\n// Main Ractive required object\nRactive = function ( options ) {\n\tinitialise( this, options );\n};\n\n\n// Ractive properties\nproperties = {\n\n\t// static methods:\n\textend:        { value: extend },\n\tgetNodeInfo:   { value: getNodeInfo },\n\tparse:         { value: parse },\n\n\t// Namespaced constructors\n\tPromise:       { value: Promise },\n\n\t// support\n\tsvg:           { value: svg },\n\tmagic:         { value: magic },\n\n\t// version\n\tVERSION:       { value: '${version}' },\n\n\t// Plugins\n\tadaptors:      { writable: true, value: {} },\n\tcomponents:    { writable: true, value: {} },\n\tdecorators:    { writable: true, value: {} },\n\teasing:        { writable: true, value: easing },\n\tevents:        { writable: true, value: {} },\n\tinterpolators: { writable: true, value: interpolators },\n\tpartials:      { writable: true, value: {} },\n\ttransitions:   { writable: true, value: {} }\n};\n\n\n// Ractive properties\ndefineProperties( Ractive, properties );\n\nRactive.prototype = extendObj( proto, defaults );\n\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as defaults\nRactive.defaults = Ractive.prototype;\n\n// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n// older browsers, these are made available via a shim - here, we do a quick\n// pre-flight check to make sure that either a) we're not in a shit browser,\n// or b) we're using a Ractive-legacy.js build\nvar FUNCTION = 'function';\n\nif (\n\ttypeof Date.now !== FUNCTION                 ||\n\ttypeof String.prototype.trim !== FUNCTION    ||\n\ttypeof Object.keys !== FUNCTION              ||\n\ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\ttypeof Array.prototype.forEach !== FUNCTION  ||\n\ttypeof Array.prototype.map !== FUNCTION      ||\n\ttypeof Array.prototype.filter !== FUNCTION   ||\n\t( typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION )\n) {\n\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n}\n\nexport default Ractive;\n"],"names":["input","output","window","document","nodeType","getElementById","querySelector","detachNode","node","parentNode","removeChild","target","sources","prop","source","shift","hasOwnProperty","fillGaps","forEach","s","key","thing","call","obj","arrayLikePattern","test","a","b","isNaN","isFinite","format","message","args","replace","consoleError","err","hasConsole","error","fatal","Error","warn","warnOnce","alreadyWarned","registryName","ractive","name","instance","findInstance","isolated","parent","snap","to","root","keypath","d","value","get","set","add","undefined","Hook","event","method","deprecate","deprecations","array","index","indexOf","push","i","isArray","length","x","member","splice","arrayLike","wait","callback","makeDispatcher","handlers","result","handler","promise","fulfil","reject","then","TypeError","_Promise","e","called","resolvePromise","rejectPromise","y","r","keys","starMap","mapper","wildcardKeypath","split","getStarMap","star","map","num","max","binary","ones","starMaps","parseInt","digit","toString","Array","prototype","property","oldKeypath","newKeypath","existingKeypath","equalsOrStartsWith","slice","str","keypathCache","pattern","matchingKeypaths","wrapper","viewmodel","wrapped","join","rootKeypath","reduce","expand","getKeypath","concatenate","ref","fragment","normalise","substring","firstKey","resolveAncestorRef","getInnerContext","resolveAmbiguousReference","baseContext","contextKeys","substr","pop","isParentLookup","context","parentValue","hasContextChain","parentKeypath","isRoot","isRootProperty","component","parentFragment","createMappingIfNecessary","data","computations","mappings","teardown","unbind","unrender","element","detach","tm","detachNodes","decrementOutros","outrosComplete","decrementTotal","flushChanges","changeHash","batch","viewmodels","applyChanges","fire","views","update","tasks","attemptKeypathResolution","item","resolved","unresolved","resolveRef","resolve","options","fulfilPromise","k","animation","animations","easing","duration","step","complete","makeValueCollector","currentValues","collectValue","dummy","dummyOptions","t","noop","animate","this","stop","from","abort","isEqual","noAnimation","Animation","interpolator","_animations","detached","el","__ractive_instances__","selector","find","owner","ancestry","ancestor","getParent","live","isComponentQuery","query","cancel","sort","dirty","remove","writable","liveQueries","_liveQueries","makeQuery","findAll","_liveComponentQueries","findAllComponents","findComponent","container","findContainer","findParent","eventName","eventNames","wildcardMatches","subscribers","initialFire","bubble","enqueue","_subs","notifySubscribers","dequeue","fullName","originalEvent","stopEvent","_noArg","concat","len","apply","original","preventDefault","stopPropagation","arguments","anchor","getElement","insertBefore","child","currentArray","runloop","start","merge","end","values","getMatchingKeypaths","getObserverFacade","observer","isPatternObserver","cancelled","emptyObject","PatternObserver","patternObservers","Observer","init","register","ready","unregister","observers","keypaths","isObject","observe","defer","filter","notEmptyString","_this","listeners","n","on","listener","off","methodName","spliceArguments","removeStart","removeEnd","balance","newIndices","getSpliceEquivalent","Math","min","instances","transitionsEnabled","noIntro","scheduleTask","renderHook","rendered","append","others","innerHTML","constructor","css","render","appendChild","completeHook","removeOtherInstances","createAccessors","originalWrapper","template","object","oldGet","oldSet","updating","mark","configurable","v","_ractiveWrappers","updateWrapper","defineProperty","enumerable","c","id","transformed","dataAttr","addGuid","selectorUnits","match","unit","base","prepended","appended","selectorUnitPattern","exec","extractString","modifiers","dataRvcGuidPattern","commentsPattern","selectorsPattern","$1","selectors","mediaQueryPattern","trim","getCss","guid","noCssTransform","transformCss","needsSuper","superMethod","Parent","getAddedKeys","dispatch","temp","extendFn","fromFn","fromProperties","copy","fillOnly","_mappings","updatable","parentFn","childFn","readDelimiterChange","parser","opening","closing","matchString","pos","allowWhitespace","matchPattern","delimiterChangePattern","whitespacePattern","mustache","inside","readMustacheOfType","tag","reader","open","close","sortMustacheTags","delimiterChangeToken","readers","isStatic","includeLinePositions","p","getLinePos","NUMBER_LITERAL","remaining","BOOLEAN_LITERAL","token","identifier","readKey","readExpression","KEY_VALUE_PAIR","pairs","pair","keyValuePairs","readKeyValuePairs","expressions","expr","next","expression","readExpressionList","expectedExpression","readNumberLiteral","readBooleanLiteral","readStringLiteral","readObjectLiteral","readArrayLiteral","startPos","prefix","global","reference","lastDotIndex","prefixPattern","legalReference","relaxedNames","keywords","globals","GLOBAL","lastIndexOf","REFERENCE","expectedParen","BRACKETED","REFINEMENT","ifTrue","ifFalse","readLogicalOr","CONDITIONAL","refs","STRING_LITERAL","JSON","stringify","String","ARRAY_LITERAL","m","OBJECT_LITERAL","PREFIX_OPERATOR","o","INFIX_OPERATOR","INVOCATION","MEMBER","list","unshift","referenceExpression","arrayMemberPattern","getReferenceExpression","rx","flattenExpression","refinement","members","triple","TRIPLE","nameStart","partial","PARTIAL","SECTION","SECTION_WITH","COMMENT","expectedFollowers","readReference","readExpressionOrReference","charAt","nextChar","INTERPOLATOR","yielder","yieldPattern","YIELDER","CLOSING","content","closed","partialDefinitionSectionPattern","readClosing","read","INLINE_PARTIAL","ELSE","ELSEIF","section","children","hasElse","block","unlessBlock","conditions","expectedClose","f","SECTION_UNLESS","handlebarsBlockCodes","indexRefPattern","extra","sectionDepth","createUnlessBlock","SECTION_IF","invert","SECTION_IF_WITH","l","sectionType","parensIfNecessary","endIndex","comment","OPEN_COMMENT","html","entity","code","htmlEntities","fromCharCode","validateCode","controlCharacters","amp","lessThan","greaterThan","closingTagPattern","CLOSING_TAG","attr","readAttributeValue","valueStart","startDepth","readQuotedAttributeValue","readUnquotedAttributeValue","decodeCharacterReferences","readUnquotedAttributeValueToken","text","haystack","needles","unquotedAttributeValueTextPattern","tags","getLowestIndex","tokens","inAttribute","readMustache","quoteMark","readQuotedStringToken","getKeyValuePair","valueToken","colonIndex","directiveName","directiveArgs","parsed","methodCallPattern","ExpressionParser","parseJSON","lowerCaseName","addProxyEvent","attribute","directive","selfClosing","DOCTYPE","ELEMENT","tagNamePattern","validTagNameFollower","reservedEventNames","readAttribute","directives","processDirective","proxyEventPattern","sanitizeEventAttributes","onPattern","toLowerCase","voidElementNames","canContain","readClosingTag","standardDelimiters","sanitizeElements","exclude","disallowed","disallowedContents","firstPos","startPattern","finishPattern","endPattern","RegExp","escapeRegExp","barrier","isString","isComment","DELIMCHANGE","isSection","INVERTED","path","items","cmp","isPartial","components","cleanup","stripComments","preserveWhitespace","removeLeadingWhitespace","removeTrailingWhitespace","previousItem","nextItem","preserveWhitespaceInsideFragment","removeLeadingWhitespaceInsideFragment","removeTrailingWhitespaceInsideFragment","preserveWhitespaceElements","contiguousWhitespace","parseOptions","helper","create","parse","doParse","fromId","isClient","noThrow","isHashedId","tagName","toUpperCase","isParsed","getParseOptions","defaults","val","resetValue","initial","_config","fn","getDynamicTemplate","parseIfString","TEMPLATE_VERSION","extendPartials","existingPartials","newPartials","overwrite","getSuperMethod","_parent","hasSuper","oldSuper","_super","_method","deprecated","correct","isError","deprecateOption","deprecatedOption","getMessage","adaptors","configure","isStandardKey","registry","extendOtherMethods","isBlacklisted","makeObj","dirtyValue","dirtyArgs","docFrag","createDocumentFragment","queryResult","firstNode","findNextNode","counter","placeholderId","fragments","processItems","getValue","_guid","argsList","pElement","resolver","refName","fragRefs","hit","indexRefs","getIndexRef","componentBoundary","indexRef","SpecialResolver","IndexResolver","ReferenceResolver","cache","Function","getUniqueString","isSpecial","createExpressionKeypath","uniqueString","isValidDependency","wrapFunction","__ractive_nowrap","bind","_boundFunctions","isDefined","forceResolution","rebind","type","registered","createReferenceResolver","ExpressionResolver","resolveAndRebindChildren","ReferenceExpressionResolver","setValue","wasResolved","twowayBinding","rebound","firstChange","newLength","reboundFragments","fragmentOptions","shuffling","unbound","currentSubtype","SECTION_EACH","newIndex","oldIndex","by","deps","fragmentsToUnrender","registeredIndexRefs","addView","fragmentsToCreate","dep","renderedFragments","fragmentsToRender","Fragment","reevaluateSection","changeCurrentSubtype","subtype","reevaluateConditionalSection","reevaluateContextSection","reevaluateConditionalContextSection","reevaluateListObjectSection","ordered","isArrayLike","reevaluateListSection","hasKey","changed","removeSectionFragments","inverted","doRender","emptyArray","isRendered","escape","removeFromArray","shouldDestroy","renderIndex","getNode","childNodes","nodes","matches","queryAllResult","numNodes","j","querySelectorAll","elementCache","createElement","parentElement","selectedOptions","option","toArray","isSelected","binding","selected","insertHtml","attributes","useProperty","_ractive","ATTRIBUTE","isBoolean","booleanAttributes","getInterpolator","isBindable","propertyName","propertyNames","isTwoway","namespacePrefix","getAttribute","optionValue","locked","arrayContains","checked","wasChecked","bindings","siblings","addViewmodel","handleChange","valueAttribute","isChecked","className","style","setAttribute","namespace","setAttributeNS","removeAttribute","updateMethod","namespaceURI","namespaces","parseAttributes","isSvg","notIn","needle","findParentForm","group","hash","sets","handleBlur","handleDelay","_timeout","clearTimeout","setTimeout","lazy","Binding","bindName","bindChecked","contenteditable","ContentEditableBinding","RadioNameBinding","CheckboxNameBinding","RadioBinding","CheckboxBinding","FileListBinding","NumericBinding","GenericBinding","MultipleSelectBinding","SelectBinding","hasAction","getAction","hasListener","listen","action","debug","invalid","getFunctionFromString","refResolvers","eventPattern","fireMethodCall","dynamicParams","fireEventWithDynamicParams","params","fireEventWithParams","eventObject","refinements","getArgsList","storage","indices","events","findIndexRefs","definition","findInViewHierarchy","custom","getCustomHandler","touchEvents","missingPlugin","addEventListener","genericHandler","customHandlers","removeEventListener","sync","selectElement","selectNode","selectValue","isMultiple","optionWasSelected","shouldSelect","valueContains","forceUpdate","select","findParentSelect","twoway","bindingAttrs","enforceCase","formBindings","processBindingAttributes","createAttributes","conditionalAttributes","createConditionalAttributes","createTwowayBinding","_twowayBindings","eventHandlers","createEventHandlers","decorator","Decorator","intro","t0","t1","outro","t2","_makeDirty","img","loadHandler","width","height","proxy","isIntro","_fn","onChange","hidden","onHide","onShow","originalStyle","completed","noReset","transition","_manager","resetStyle","getNamespace","updateScript","updateCss","h","defaultValue","defaultSelected","torndown","Transition","registerTransition","autofocus","focus","xmlns","svg","processOption","multiple","updateLiveQueries","_test","optionIsSelected","inputIsCheckedRadio","typeAttribute","nameAttribute","stringifyAttribute","detachWhenReady","registerDecorator","removeFromLiveQueries","_remove","reducer","previous","line","lineIndent","deIndent","partials","isOwner","noRegistryFunctionReturn","findOwner","findConstructor","_Parent","Component","adaptor","adapt","wrap","getPrefixer","prefixKeypath","prefixed","rootDot","prefixers","relativeKeypath","changes","upstreamChanges","onlyDirect","potentialWildcardMatches","upstreamPattern","actualChildKeypath","depsMap","childKeypath","lastKey","regex","self","noCascade","computed","clearCache","invalidate","cascade","getUpstreamChanges","notifyPatternObservers","notifyUpstreamDependants","implicitChanges","groupName","dependants","findDependants","refineValue","notifyBindings","useSet","notifyAllDependants","addKeypath","childDeps","queue","captureGroups","keepExistingWrapper","cacheMap","signature","functionBody","isUnresolved","getComputationSignature","Computation","mapping","computation","captureGroup","keypathStr","lastItem","bypass","retrieve","noUnwrap","FAILED_LOOKUP","compute","localKey","origin","force","trackData","Mapping","initViewmodel","implicit","oldArray","newArray","comparator","compare","getComparatorFunction","mapOldToNewIndex","smartUpdate","comparators","dependant","depsByKeypath","noMapping","setting","reset","silent","resolveSet","wrapperSet","valueSet","createBranch","Viewmodel$smartUpdate","oldLength","noCascadeOption","canShuffle","shuffle","implicitOption","unresolvedImplicitDependency","unresolvedImplicitDependencies","hook","inProcess","getChildQueue","hookQueue","childQueue","userOptions","config","getConstructTarget","magic","begin","Viewmodel","initialiseProperties","_inlinePartials","inlinePartials","parameters","addData","proto","createDataFromPrototype","createLegacyData","ComponentData","getConstructor","protoparams","_parameters","Constructor","newKeys","makeConstructor","defined","properties","_data","toJSON","json","reservedKeys","isFunction","addMapping","getParamsDefinition","ComponentParameters","createComponentData","parentViewmodel","Object","eventsDescriptor","childInstance","parentInstance","proxyEventName","COMPONENT","indexRefBindings","yielders","resolvers","createParameters","createItem","bound","Text","Yielder","Interpolator","Section","Triple","Element","Partial","Comment","Doctype","rerender","shouldRerender","badArguments","consolidate","checkboxGroups","oldValue","newValue","radioName","checkboxName","arrayContentsMatch","Child","Ractive","useDefaults","addRegistry","addOtherOptions","extend","pow","console","implementation","hasFeature","ns","createElementNS","methodNames","unprefixed","makeFunction","vendors","cloneNode","win","now","Date","hasDontEnumBug","propertyIsEnumerable","dontEnums","dontEnumsLength","isActuallyString","mapped","opt_initialValue","valueIsSet","filtered","every","iterator","Empty","ctx","doc","Event","head","origCreateElement","appearsToBeIELessEqual8","currentTarget","srcElement","timeStamp","returnValue","cancelBubble","attachEvent","detachEvent","getElementsByTagName","firstChild","getComputedStyle","fontSize","rootSize","sizeWithSuffix","size","parseFloat","suffix","getBorderPixelSize","getPixelSize","currentStyle","clientWidth","clientHeight","div","bcr","borderSizes","display","position","borderRight","getBoundingClientRect","right","left","borderSuffix","CSSStyleDeclaration","defineProperties","props","F","log","printWarning","hasOwn","interpol","interpolators","number","delta","intermediate","interpolate","lastTime","requestAnimationFrame","currTime","timeToCall","performance","arg","replacement","PENDING","FULFILLED","REJECTED","Promise","dispatchHandlers","makeResolver","fulfilledHandlers","rejectedHandlers","state","newState","onFulfilled","onRejected","promise2","processResolutionHandler","forward","p1result","all","promises","pending","processPromise","reason","decodeKeypath","startsWith","_wildcardMatches","getPotentialWildcardMatches","intros","outros","totalChildren","outroChildren","detachQueue","decoratorQueue","addChild","changeHook","returnPromise","TransitionManager","transitionManager","previousBatch","addDecorator","view","task","postRender","_batch","getTime","tick","running","startTime","elapsed","timeNow","noDirty","itemMatches","_root","ancestryA","ancestryB","oldestA","oldestB","mutualAncestor","indexA","indexB","fragmentA","fragmentB","getAncestry","otherNode","bitmask","compareDocumentPosition","sortByItemPosition","_dirty","_sort","nodeOrComponent","_eventQueue","immediate","proxies","getPattern","getProxy","reallyUpdate","_this2","styleElement","styleSheet","inDom","getNewIndices","arrayProto","componentsInPage","styles","cssText","testObj","patchArrayMethods","unpatchArrayMethods","mutatorMethods","wrappers","patchedArrayProto","__proto__","unpatch","ArrayWrapper","errorMessage","arrayAdaptor","numeric","parentWrapper","MagicWrapper","objKeypath","originalDescriptor","getOwnPropertyDescriptor","magicAdaptor","MagicArrayWrapper","magicWrapper","arrayWrapper","ParseError","ensureArray","protoAdapt","lookup","modifyArrays","magicArrayAdaptor","stack","Parser","lineStart","lines","lineEnds","lineEnd","leftover","postProcess","converters","char","columnNum","lineNum","annotation","character","shortMessage","string","okQuote","literal","done","escapeSequencePattern","lineContinuationPattern","charCodeAt","getDoubleQuotedString","getSingleQuotedString","expressionList","readLiteral","readBracketedExpression","current","readPrimary","readRefinement","symbol","fallthrough","matcher","prefixOperators","readMemberOrInvocation","makePrefixSequenceMatcher","infixOperators","readTypeof","makeInfixSequenceMatcher","SECTION_PARTIAL","keyIndexRefPattern","handlebarsBlockPattern","CLOSE_COMMENT","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","lowest","specials","onlyWhitespace","placeholder","placeholderAtStartPattern","special","specialsPattern","stringLiteral","placeholderPattern","JsonParser","intro-outro","leading","trailing","trailingLinebreak","backOne","backTwo","lastSectionItem","leadingLinebreak","STANDARD_READERS","readPartial","readUnescaped","readPartialDefinitionSection","readSection","readYielder","readInterpolator","TRIPLE_READERS","readTriple","STATIC_READERS","StandardParser","tripleDelimiters","staticDelimiters","staticTripleDelimiters","delimiters","isTriple","script","sanitize","elements","eventAttributes","readPartialDefinitionComment","readHtmlComment","readElement","readText","isEmptyObject","Registry","registries","registryNames","adaptConfigurator","cssConfigurator","dataConfigurator","templateConfigurator","defaultKeys","order","onconstruct","TEXT","createTextNode","escapeHtml","addUnresolved","removeUnresolved","cached","getProp","registerIndexRef","unregisterIndexRef","createEvaluator","valueGetters","refResolver","MemberResolver","baseResolver","Mustache","ieBug","ieBlacklist","selectedOption","selectedIndex","attrs","truthy","createMap","svgCamelCaseElements","svgCamelCaseAttributes","elementName","lowerCaseElementName","Attribute","ConditionalAttribute","parentForm","getInitialValue","SpecialisedBinding","getSiblings","noInitialValue","existingValue","bindingValue","valueFromModel","selectedValues","previousValue","initialValue","files","timeout","names","EventHandler","actual","hyphenatedStr","vendor","capped","camelCase","prefixCache","legacy","computedStyle","linear","eased","TRANSITION","TRANSITIONEND","CSS_TRANSITIONS_ENABLED","TRANSITION_DURATION","TRANSITION_PROPERTY","TRANSITION_TIMING_FUNCTION","hyphenated","canUseCssTransitions","cannotUseCssTransitions","webkitTransition","hashPrefix","jsTransitionsComplete","cssTransitionsComplete","checkComplete","transitionEndHandler","changedProperties","hyphenate","unprefix","originalValue","propertiesToTransitionInJs","getStyle","Ticker","delay","visibility","setStyle","animateStyle","processParams","hasChildNodes","dd","firstLine","lastLine","minIndent","indent","indented","notFirstLine","fragmentToRender","fragmentToUnrender","getPartialTemplate","isNamed","setTemplate","applyIndent","createFunctionFromString","softDeps","unresolvedDeps","getter","setter","hardDeps","depValues","_firstRun","newDeps","dependenciesChanged","dependencyValuesChanged","getting","capture","release","updateDependencies","oldDeps","UnresolvedDependency","local","setup","ensureKeypath","tracker","DataTracker","keepLocal","usedIndices","firstUnusedIndex","HookQueue","configHook","initHook","yieldTemplate","readyResolve","notReadyResolve","reversedMappings","isSingleInterpolator","ParameterResolver","ComplexParameter","createComment","containerFragment","declaration","idx","idxs","resetHook","dest","getPartialName","collection","resetPartial","reverse","priv","info","getNodeInfo","FUNCTION"],"mappings":"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"}