import { getComponentName, isComponentPath, isComponentName } from './utils'

const linkPattern = /^<link((?:\s+[-a-z:]+(?:="(?:\\.|[^"])*")?)*)\s*(\/?)>/i
const containerPattern = /^<(template|style|script)((?:\s+[-a-z:]+(?:="(?:\\.|[^"])*")?)*)\s*>([\s\S]*?)<\/\1>/i
const whitespacePattern = /^(\s+?)/
const attributePairsPattern = /[-a-z:]+(?:="((?:\\.|[^"])*)")?/g
const attributeComponentsPattern = /([-a-z:]+)(?:="((?:\\.|[^"])*)")?/

const getAttributes = attributesString => {
  const attributePairs = attributesString.match(attributePairsPattern)
  return attributePairs ? attributePairs.reduce((attributes, attribute) => {
    const match = attribute.match(attributeComponentsPattern)
    if (match) attributes[match[1]] = match[2] === undefined ? '' : match[2]
    return attributes
  }, {}) : {}
}

// Note: Parser doesn't care if you wrote ES or CJS. It knows nothing about the
// script format yet. It only knows a bunch of strings inside elements.
export const toParts = source => {
  const parts = {
    components: [],
    template: null,
    style: null,
    script: null
  }

  // eslint-disable-next-line
  while (source) {
    let match

    // eslint-disable-next-line
    if (match = source.match(linkPattern)) {
      const attributes = getAttributes(match[1].trim())

      const module = attributes.href
      if (!module) throw new Error('Linked components must have the href attribute.')
      if (!isComponentPath(module)) throw new Error('Linked components must either have a .html or .ractive.html extension')

      const name = attributes.name || getComponentName(module)
      if (!name) throw new Error('Linked components must have the name attribute.')
      if (!isComponentName(name)) throw new Error(`Cannot use ${name} as component name.`)

      parts.components.push({ name, module })

      source = source.slice(match[0].length)
    // eslint-disable-next-line
    } else if (match = source.match(containerPattern)) {
      const elementName = match[1]

      if (parts[elementName]) throw new Error(`There can only be one top-level <${elementName}>.`)

      parts[elementName] = { code: match[3], map: null }

      source = source.slice(match[0].length)
    // eslint-disable-next-line
    } else if (match = source.match(whitespacePattern)) {
      // Strip whitespace from the top level. Not really important.
      source = source.slice(match[0].length)
    } else {
      throw new Error(`Unexpected syntax at ${source.slice(0, 80)}...`)
    }
  }

  return parts
}
